# ExportCallTree.py
# @category Stars
# @description: Export a function and all functions it calls (recursively)
#
# Usage (headless): -postScript ExportCallTree.py <output_file> <root_function> [max_depth]

from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor


def find_function_by_name(fm, name):
    """Find a function by exact name (case-insensitive)."""
    name_lower = name.lower()
    for f in fm.getFunctions(True):
        if f.getName().lower() == name_lower:
            return f
    return None


def get_called_functions(func, fm):
    """Get all functions called by this function."""
    called = set()
    if func is None:
        return called

    body = func.getBody()
    listing = currentProgram.getListing()
    ref_mgr = currentProgram.getReferenceManager()

    # Iterate through all addresses in the function
    addr_set = body
    addr_iter = addr_set.getAddresses(True)

    while addr_iter.hasNext():
        addr = addr_iter.next()
        refs = ref_mgr.getReferencesFrom(addr)
        for ref in refs:
            if ref.getReferenceType().isCall():
                target = ref.getToAddress()
                target_func = fm.getFunctionAt(target)
                if target_func is not None:
                    called.add(target_func)

    return called


def collect_call_tree(root_func, fm, max_depth=3):
    """Collect all functions in the call tree up to max_depth."""
    collected = {}  # name -> function
    to_process = [(root_func, 0)]
    processed = set()

    while to_process:
        func, depth = to_process.pop(0)
        if func is None:
            continue

        name = func.getName()
        if name in processed:
            continue
        processed.add(name)

        # Skip external/library functions
        if func.isExternal() or func.isThunk():
            continue

        collected[name] = func

        if depth < max_depth:
            called = get_called_functions(func, fm)
            for cf in called:
                if cf.getName() not in processed:
                    to_process.append((cf, depth + 1))

    return collected


def decompile_function(func, decomp):
    """Decompile a function and return the C code."""
    try:
        monitor = ConsoleTaskMonitor()
        result = decomp.decompileFunction(func, 60, monitor)

        if result.decompileCompleted():
            return result.getDecompiledFunction().getC()
        else:
            return "// Decompilation failed: %s" % result.getErrorMessage()
    except Exception as e:
        return "// Decompilation error: %s" % str(e)


def main():
    args = getScriptArgs()

    if len(args) < 2:
        println("Usage: ExportCallTree.py <output_file> <root_function> [max_depth]")
        println("")
        println("Example: ExportCallTree.py io_functions.c FLoadGame 3")
        return

    output_file = args[0]
    root_name = args[1]
    max_depth = int(args[2]) if len(args) > 2 else 3

    println("Output file: %s" % output_file)
    println("Root function: %s" % root_name)
    println("Max depth: %d" % max_depth)

    fm = currentProgram.getFunctionManager()

    # Find root function
    root_func = find_function_by_name(fm, root_name)
    if root_func is None:
        println("ERROR: Root function '%s' not found" % root_name)
        return

    println("Found root: %s @ %s" % (root_func.getName(), root_func.getEntryPoint()))

    # Collect call tree
    println("Collecting call tree...")
    functions = collect_call_tree(root_func, fm, max_depth)
    println("Found %d functions in call tree" % len(functions))

    # Sort by name for consistent output
    sorted_names = sorted(functions.keys())

    # Initialize decompiler
    decomp = DecompInterface()
    decomp.openProgram(currentProgram)

    try:
        with open(output_file, "w") as f:
            f.write("// Call tree decompilation from stars.exe (Stars! 2.60j RC3)\n")
            f.write("// Root function: %s\n" % root_name)
            f.write("// Max depth: %d\n" % max_depth)
            f.write("// Total functions: %d\n" % len(functions))
            f.write("// Generated by Ghidra\n")
            f.write("//\n\n")

            success_count = 0
            fail_count = 0

            for name in sorted_names:
                func = functions[name]
                println("Processing: %s @ %s" % (name, func.getEntryPoint()))

                f.write("// " + "=" * 70 + "\n")
                f.write("// Function: %s\n" % name)
                f.write("// Address: %s\n" % func.getEntryPoint())
                f.write("// " + "=" * 70 + "\n\n")

                code = decompile_function(func, decomp)
                if code and not code.startswith("// Decompilation"):
                    f.write(code)
                    f.write("\n\n")
                    println("  OK")
                    success_count += 1
                else:
                    f.write(code)
                    f.write("\n\n")
                    println("  FAILED")
                    fail_count += 1

            f.write("// " + "=" * 70 + "\n")
            f.write("// Summary: %d succeeded, %d failed\n" % (success_count, fail_count))
            f.write("// " + "=" * 70 + "\n")

        println("")
        println("Output written to: %s" % output_file)
        println("Success: %d, Failed: %d" % (success_count, fail_count))

    finally:
        decomp.dispose()


if __name__ == "__main__":
    main()
