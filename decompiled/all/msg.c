// Decompiled code from stars.exe
// Generated by Ghidra - ExportAllDecompiled.py
// Grouped by nb09_ghidra_globals.json segmap.segname
// 

// ======================================================================
// Function: MessageWndProc
// Address: 1030:5c92
// Segment: MEMORY_MSG
// ======================================================================


/* WARNING: Variable defined which should be unmapped: lpmsgplr */

long MessageWndProc(HWND hwnd,WMType message,ushort wParam,long lParam)

{
  byte bVar1;
  POINT pt_00;
  POINT pt_01;
  MSGPLR *pMVar2;
  THING *pTVar3;
  short sVar4;
  COLORREF CVar5;
  char *pcVar6;
  short sVar7;
  HWND HVar8;
  short sVar9;
  short sVar10;
  ushort uVar11;
  uint uVar12;
  int iVar13;
  MSGPLR *pMVar14;
  undefined2 unaff_SI;
  undefined2 unaff_DI;
  undefined2 unaff_SS;
  bool bVar15;
  ulong uVar16;
  DWORD DVar17;
  LRESULT LVar18;
  char *pcVar19;
  undefined2 uVar20;
  undefined2 uVar21;
  HDC HVar22;
  MSGPLR *lpmsgplr;
  UINT UVar23;
  short sVar24;
  short y;
  char szT [32];
  short iMode;
  short cch;
  short dx;
  RECT rcActual;
  undefined1 scan [8];
  undefined1 auStack_36 [2];
  COLORREF crFore;
  ushort hcs;
  POINT pt;
  PAINTSTRUCT ps;
  char *psz;
  short i;
  HDC hdc;
  
  if (message == WM_CREATE) {
    for (i = 0; i < 4; i = i + 1) {
      hwndMessage = hwnd;
      uVar20 = 0x1120;
      pcVar19 = (char *)s_BUTTON_1120_0b14;
      pcVar6 = PszGetCompressedString(i + idsPrev2);
      if (i == 3) {
        sVar7 = 0x32;
      }
      else {
        sVar7 = 0x2c;
      }
      HVar8 = CreateWindow((LPCSTR)CONCAT22(uVar20,pcVar19),(LPCSTR)CONCAT22(0x1120,pcVar6),
                           0x40000000,100,100,sVar7,(dyArial8 * 3 >> 1) + -1,hwnd,0,
                           hInst,(void *)0x0);
      ((ushort *)rghwndMsgBtn)[i] = HVar8;
      SendMessage(((ushort *)rghwndMsgBtn)[i],0x30,rghfontArial8[1],0);
    }
    hwndMsgDrop =
         CreateWindow(s_COMBOBOX_1120_0b21,(LPCSTR)0x11200b1b,0x40200003,100,100,200,0x50,hwnd,0,
                      hInst,(void *)0x0);
    SendMessage(hwndMsgDrop,0x30,rghfontArial8[1],0);
    hwndMsgEdit =
         CreateWindow((LPCSTR)0x11200b2a,(LPCSTR)0x0,0x40800044,100,100,200,0x32,hwnd,0,
                      hInst,(void *)0x0);
    SendMessage(hwndMsgEdit,0x415,0x3c8,0);
    SendMessage(hwndMsgEdit,0x30,rghfontArial8[1],0);
    hwndMsgScroll =
         CreateWindow((LPCSTR)0x11200b2f,(LPCSTR)0x0,0x40a00844,100,100,200,0x32,hwnd,0,
                      hInst,(void *)0x0);
    SetMsgTitle(hwnd);
    UVar23 = 0x403;
    HVar8 = hwndMsgDrop;
    pcVar6 = PszGetCompressedString(idsEverybody);
    SendMessage(HVar8,UVar23,0,(LPARAM)CONCAT22(0x1120,pcVar6));
    for (i = 0; i < game.cPlayer; i = i + 1) {
      psz = PszPlayerName(i,1,1,1,0,(PLAYER *)0x0);
      SendMessage(hwndMsgDrop,0x403,0,(LPARAM)CONCAT22(0x1120,psz));
    }
    SendMessage(hwndMsgDrop,0x40e,0,0);
    return 0;
  }
  if (message == WM_SIZE) {
    pt.x = (ushort)lParam;
    uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr);
    pt.y = (short)uVar16;
    for (i = 0; i < 3; i = i + 1) {
      stack0xffc8 = (MSGPLR *)CONCAT22(auStack_36,(MSGPLR *)(dyArial8 * 2));
      SetWindowPos(((ushort *)rghwndMsgBtn)[i],0,pt.x + -0x30,
                   (int)&((MSGPLR *)(dyArial8 * 2))->lpmsgplrNext +
                   ((dyArial8 * 3 >> 1) + 2) * i + 3,0,0,0x55);
    }
    SetRect(&rcMsgText,4,dyArial8 * 2 + 3,pt.x + -0x34,pt.y + -4);
    SetRect(&rcMsgTitle,4,4,pt.x + -4,dyArial8 * 2 + -4);
    stack0xffc8 = (MSGPLR *)CONCAT22(rcMsgText.left,scan._6_2_);
    crFore = CONCAT22(rcMsgText.right,rcMsgText.top);
    hcs = rcMsgText.bottom;
    ExpandRc((RECT *)auStack_36,-4,-4);
    SetWindowPos(hwndMsgDrop,0,(int)auStack_36 + 0x1e,(int)crFore,
                 (crFore._2_2_ - (int)auStack_36) + -0x54,hcs - (int)crFore,4);
    SetWindowPos(rghwndMsgBtn[3],0,crFore._2_2_ + -0x32,(int)crFore,0,0,5);
    iVar13 = (int)crFore + dyShipDD + 3;
    crFore = CONCAT22(crFore._2_2_,iVar13);
    SetWindowPos(hwndMsgEdit,0,(short)auStack_36,iVar13,crFore._2_2_ - (int)auStack_36,
                 hcs - iVar13,4);
    goto MSG_Default_9;
  }
  if (message != WM_PAINT) {
    if (message == WM_ERASEBKGND) {
      GetClientRect(hwnd,(RECT *)CONCAT22(unaff_SS,(RECT *)((int)&crFore + 2)));
      FillRect(wParam,(RECT *)CONCAT22(unaff_SS,(RECT *)((int)&crFore + 2)),hbrButtonFace);
      return 1;
    }
    if (message == WM_CTLCOLOR) {
      if ((ushort)lParam == hwndMsgScroll) {
        SetBkColor(wParam,CONCAT22(crButtonFace._2_2_,(undefined2)crButtonFace))
        ;
        return (ulong)hbrButtonFace;
      }
MSG_Default_9:
      LVar18 = DefWindowProc(hwnd,message,wParam,lParam);
      return LVar18;
    }
    if (message == WM_SETCURSOR) {
      hcs = 0;
      GetCursorPos((POINT *)CONCAT22(unaff_SS,&pt));
      ScreenToClient(hwnd,(POINT *)CONCAT22(unaff_SS,&pt));
      sVar7 = HtMsgBox(pt);
      if (sVar7 != 0) {
        setcursor(hcurHand);
        return 1;
      }
      goto MSG_Default_9;
    }
    if (message == WM_GETMINMAXINFO) {
      *(int *)((ushort)lParam + 0xc) = dxWinFrame * 2 + 0xc6;
      *(int *)((ushort)lParam + 0xe) = (dyArial8 * 0xd >> 1) + 0x16;
      goto MSG_Default_9;
    }
    if (message == WM_KEYDOWN) {
      if (wParam == 0x28) {
MSG_NextMsg:
        if (((uint)gd.grBits >> 8 & 1) == 0) {
          uVar12 = GetAsyncKeyState(0x10);
          if ((uVar12 & 0xfffe) == 0) {
            i = IMsgNext(0);
          }
          else {
            iMsgCur = cMsg + vcmsgplrIn;
            i = IMsgPrev(0);
          }
          if (i == -1) {
            return 0;
          }
          iMsgCur = i;
        }
        else {
          FFinishPlrMsgEntry(1);
        }
      }
      else {
        if (wParam != 0x26) {
          if (((uint)gd.grBits >> 8 & 1) != 0) goto MSG_Default_9;
          if (wParam == 0x24) {
            iMsgCur = -1;
            goto MSG_NextMsg;
          }
          if (wParam != 0x23) {
            return 0;
          }
          iMsgCur = cMsg + vcmsgplrIn;
        }
MSG_PrevMsg:
        if (((uint)gd.grBits >> 8 & 1) == 0) {
          uVar12 = GetAsyncKeyState(0x10);
          if ((uVar12 & 0xfffe) == 0) {
            i = IMsgPrev(0);
          }
          else {
            iMsgCur = -1;
            i = IMsgNext(0);
          }
          if (i == -1) {
            if (iMsgCur != cMsg + vcmsgplrIn) {
              return 0;
            }
            iMsgCur = iMsgCur + -1;
          }
          else {
            iMsgCur = i;
          }
        }
        else {
          FFinishPlrMsgEntry(-1);
        }
      }
MSG_SetupNewMsg:
      gd.grBits._0_2_ = (uint)gd.grBits & 0xefff;
      SetMsgTitle(hwnd);
      InvalidateRect(hwnd,&rcMsgText,1);
      if (((uint)gd.grBits >> 0xb & 1) == 0) {
        return 0;
      }
      tutor.wFlags = tutor.wFlags & 0xfffbU | 4;
      AdvanceTutor();
      return 0;
    }
    if (message == WM_CHAR) {
      if (wParam == 0xd) goto MSG_GotoMsg;
      if (wParam == 0x2b) {
MSG_CheckBox:
        if (iMsgCur < 0) {
          return 0;
        }
        sVar7 = IdmGetMessageN(iMsgCur);
        uVar12 = 1 << ((byte)sVar7 & 7);
        stack0xffc8 = (MSGPLR *)CONCAT22(uVar12,scan._6_2_);
        bVar15 = (((byte *)bitfMsgFiltered)[sVar7 >> 3] & uVar12) != 0;
        crFore = (COLORREF)CONCAT12(bVar15,sVar7);
        SetFilteringGroups(sVar7,(uint)!bVar15);
        DirtyGame(1);
        if (((uint)gd.grBits >> 0xb & 1) != 0) {
          AdvanceTutor();
        }
        InvalidateRect(hwndMessage,(RECT *)0x0,1);
        SetMsgTitle(hwnd);
        return 0;
      }
      if (wParam != 0x2d) {
        return 0;
      }
      pt = (POINT)((ulong)pt & 0xffff);
      while ((uint)pt.y < 0x31) {
        bVar1 = ((byte *)bitfMsgFiltered)[pt.y];
        pt.x = (uint)bVar1;
        if ((((byte *)bitfMsgSent)[pt.y] & bVar1) != 0) break;
        pt.y = pt.y + 1;
      }
      if (pt.y == 0x31) {
        return 0;
      }
    }
    else {
      if (message == WM_COMMAND) {
        uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr);
        if ((int)uVar16 == 0) {
          SetFocus(hwndFrame);
        }
        if (((ushort)lParam == rghwndMsgBtn[0]) &&
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 == 0)) goto MSG_PrevMsg;
        if (((ushort)lParam == rghwndMsgBtn[2]) &&
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 == 0)) goto MSG_NextMsg;
        if (((ushort)lParam == rghwndMsgBtn[3]) &&
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 == 0)) {
          FFinishPlrMsgEntry(1000);
          goto MSG_SetupNewMsg;
        }
        if (((ushort)lParam != rghwndMsgBtn[1]) ||
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 != 0)) goto MSG_Default_9;
MSG_GotoMsg:
        if ((((uint)gd.grBits >> 8 & 1) == 0) && (iMsgCur < cMsg)) {
          switch(mdMsgObj) {
          default:
            break;
          case 1:
            SelectAdjPlanet(0,idMsgObj);
            UpdateWindow(hwndScanner);
            SendMessage(hwndScanner,0x102,0x76,0);
            pt.y = IdmGetMessageN(iMsgCur);
            if (((pt.y == 0x3e) || (pt.y == 0x3f)) || ((0xae < pt.y && (pt.y < 0xb5)))) {
              if (((uint)gd.grBits >> 0xc & 1) == 0) {
                gd.grBits._0_2_ = (uint)gd.grBits & 0xefff | 0x1000;
                SetMsgTitle(hwnd);
              }
              else if ((sel.grobj == grobjPlanet) &&
                      (sel.id == idMsgObj)) {
                ChangeProduction(0);
              }
            }
            break;
          case 2:
            SelectAdjFleet(0,idMsgObj);
            UpdateWindow(hwndScanner);
            SendMessage(hwndScanner,0x102,0x76,0);
            break;
          case 3:
            PostMessage(hwndFrame,0x111,0x7e,0);
            break;
          case 4:
            vpartBrowser.hs.grhst = 1 << ((byte)((uint)idMsgObj >> 8) & 0xf);
            pt = (POINT)(CONCAT22(idMsgObj,pt.x) & 0xffffff);
            vpartBrowser.hs.wFlags_0x2 =
                 vpartBrowser.hs.wFlags_0x2 & 0xff00 | pt.y;
            FLookupPart((PART *)&vpartBrowser);
            if (hwndBrowser == 0) {
              fBrowserValid = 1;
              PostMessage(hwndFrame,0x111,0x100,0);
            }
            else {
              InvalidateRect(hwndBrowserChild,(RECT *)0x0,1);
            }
            break;
          case 5:
            PostMessage(hwndFrame,0x111,0x7d,0);
            break;
          case 6:
            SelectOursAtObject((POINT *)&vptMsg);
            if (((uint)gd.grBits >> 0xc & 1) == 0) {
              gd.grBits._0_2_ = (uint)gd.grBits & 0xefff | 0x1000;
              SetMsgTitle(hwnd);
            }
            else {
              BattleVCR(idMsgObj);
            }
            break;
          case 7:
            PostMessage(hwndFrame,0x111,0x7de,0);
            break;
          case 8:
            PostMessage(hwndFrame,0x111,0x5f,0);
            break;
          case 9:
            szWork[200] = '\x02';
            pt = (POINT)MakeProcInstance(MsgDlg,hInst);
            pcVar6 = (char *)hwndTitle;
            if (hwndTitle == 0) {
              pcVar6 = (char *)hwndFrame;
            }
            hcs = DialogBox(0,(LPCSTR)CONCAT22(0x56,pcVar6),pt.y,(char)pt.x);
            FreeProcInstance((FARPROC)pt);
            if (hcs != 0) {
              sVar7 = FValidSerialNo((char *)szWork,(long *)&crFore);
              if (sVar7 == 0) {
                if (((int)vSerialNumber == 0) && (vSerialNumber._2_2_ == 0)) {
                  _memcpy((byte *)vrgbMachineConfig,
                                  (byte_0_ *)&vrgbEnvCur,0xb);
                }
              }
              else {
                vSerialNumber._0_2_ = (int)crFore;
                vSerialNumber._2_2_ = crFore._2_2_;
                _memcpy((byte *)vrgbMachineConfig,(byte_0_ *)&vrgbEnvCur
                                ,0xb);
              }
            }
            break;
          case 10:
            pt = (POINT)LpthFromId(vptMsg.x);
            iVar13 = pt.y;
            pTVar3 = (THING *)pt.x;
            if ((pTVar3 != (THING *)0x0) || (iVar13 != 0)) {
              scan._0_2_ = (&pTVar3->pt)->x;
              scan._2_2_ = (pTVar3->pt).y;
              scan._4_2_ = grobjThing;
              ChangeScanSel((SCAN *)scan,0);
              pt_01.y = scan._2_2_;
              pt_01.x = scan._0_2_;
              CtrPointScan(pt_01,1);
            }
            break;
          case 0xb:
            if ((hwndReportDlg == 0) || (vprptCur != (RPT *)&vrptBattle)) {
              PostMessage(hwndFrame,0x111,0x901,0);
            }
          }
          if (((uint)gd.grBits >> 0xb & 1) == 0) {
            return 0;
          }
          tutor.wFlags = tutor.wFlags & 0xfffbU | 4;
          AdvanceTutor();
          return 0;
        }
MSG_ToggleMsgMode:
        if (((uint)gd.grBits >> 8 & 1) == 0) {
          if (iMsgCur < cMsg) {
            viInRe = 0;
          }
          else {
            stack0xffc8 = (MSGPLR *)CONCAT22(vlpmsgplrIn._2_2_,(MSGPLR *)vlpmsgplrIn);
            i = iMsgCur - cMsg;
            while( true ) {
              pMVar14 = (MSGPLR *)stack0xffc8;
              uVar20 = (undefined2)((ulong)stack0xffc8 >> 0x10);
              if (i == 0) break;
                    /* WARNING: Load size is inaccurate */
              stack0xffc8 = (MSGPLR *)
                            CONCAT22(*(undefined2 *)((int)&pMVar14->lpmsgplrNext + 2),
                                     stack0xffc8->lpmsgplrNext);
              i = i + -1;
            }
            crFore = CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
            iMsgSendCur = 0;
            while( true ) {
              if ((((int)crFore == 0) && (crFore._2_2_ == 0)) ||
                 ((*(int *)((int)crFore + 6) + -1 == pMVar14->iPlrFrom &&
                  (*(int *)((int)crFore + 8) == iMsgCur)))) break;
              crFore = CONCAT22(*(undefined2 *)((int)crFore + 2),*(undefined2 *)crFore);
              iMsgSendCur = iMsgSendCur + 1;
            }
            viInRe = pMVar14->iPlrFrom + 1;
            i = -1;
          }
        }
        else {
          FFinishPlrMsgEntry(0);
        }
        bVar15 = ((uint)gd.grBits >> 8 & 1) == 0;
        crFore = (COLORREF)CONCAT12(bVar15,(int)crFore);
        CVar5 = crFore;
        crFore._2_2_ = (uint)bVar15;
        gd.grBits._0_2_ = (uint)gd.grBits & 0xfeff | crFore._2_2_ << 8;
        crFore = CVar5;
        InvalidateRect(hwndMessage,(RECT *)0x0,1);
        SetMsgTitle(hwnd);
        SetFocus(hwndMsgEdit);
        return 0;
      }
      if ((message != WM_LBUTTONDOWN) && (message != WM_LBUTTONDBLCLK)) goto MSG_Default_9;
      pt.x = (ushort)lParam;
      uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr);
      pt.y = (short)uVar16;
      pt_00.y = (short)uVar16;
      pt_00.x = pt.x;
      hcs = HtMsgBox(pt_00);
      if (hcs == 1) goto MSG_CheckBox;
      if (hcs != 2) {
        if (hcs != 3) {
          return 0;
        }
        goto MSG_ToggleMsgMode;
      }
    }
    fViewFilteredMsg = (short)(fViewFilteredMsg == 0);
    if (-1 < iMsgCur) {
      sVar7 = IdmGetMessageN(iMsgCur);
      crFore = CONCAT22(1 << ((byte)sVar7 & 7),(int)crFore);
      sVar7 = IdmGetMessageN(iMsgCur);
      if ((uint)((((byte *)bitfMsgFiltered)[sVar7 >> 3] & crFore._2_2_) != 0) ==
          fViewFilteredMsg) goto LAB_1030_626c;
    }
    i = IMsgNext(fViewFilteredMsg);
    if (i == -1) {
      i = IMsgPrev(fViewFilteredMsg);
    }
    iMsgCur = i;
LAB_1030_626c:
    InvalidateRect(hwndMessage,(RECT *)0x0,1);
    SetMsgTitle(hwnd);
    return 0;
  }
  hdc = BeginPaint(hwnd,(PAINTSTRUCT *)CONCAT22(unaff_SS,&ps));
  _Draw3dFrame();
  crFore = SetTextColor(hdc,CONCAT22(crButtonText._2_2_,(undefined2)crButtonText
                                    ));
  scan._2_4_ = SetBkColor(hdc,CONCAT22(crButtonFace._2_2_,
                                       (undefined2)crButtonFace));
  cch = _strlen((char *)szMsgTitle);
  auStack_36 = (undefined1  [2])((rcMsgTitle.right - rcMsgTitle.left) + -0x30);
  for (; 0 < cch; cch = cch + -1) {
    DVar17 = GetTextExtent(hdc,szMsgTitle,cch);
    if ((int)DVar17 <= (int)auStack_36) break;
  }
  RcCtrTextOut(hdc,(RECT *)&rcMsgTitle,(char *)szMsgTitle,cch);
  DecorateMsgTitleBar(hdc,(RECT *)&rcMsgTitle);
  sVar4 = rcMsgText.bottom;
  sVar7 = rcMsgText.right;
  dx = rcMsgText.right - rcMsgText.left;
  scan._6_2_ = rcMsgText.bottom - rcMsgText.top;
  sVar24 = rcMsgText.left;
  y = rcMsgText.top;
  hcs = SelectObject(hdc,hbrButtonShadow);
  PatBlt(hdc,sVar24,y,dx,1,0xf00021);
  PatBlt(hdc,sVar24,y,1,scan._6_2_,0xf00021);
  SelectObject(hdc,hbrButtonHilite);
  PatBlt(hdc,sVar24,sVar4 + -1,dx,1,0xf00021);
  PatBlt(hdc,sVar7 + -1,y,1,scan._6_2_,0xf00021);
  SelectObject(hdc,hcs);
  ExpandRc((RECT *)&stack0xff8c,-4,-4);
  if (((uint)gd.grBits >> 8 & 1) != 0) {
    iMode = SetBkMode(hdc,1);
    SetTextColor(hdc,CONCAT22(crButtonText._2_2_,(undefined2)crButtonText));
    cch = CchGetString(idsTo3,szT);
    RightTextOut(hdc,sVar24 + 0x1a,y,szT,cch,0);
    SetBkMode(hdc,iMode);
    goto LAB_1030_6a4b;
  }
  if (iMsgCur < cMsg) {
    scan._0_2_ = IdmGetMessageN(iMsgCur);
    if ((iMsgCur < 0) && (0 < cMsg)) {
      pt.x = (short)PszGetCompressedString(idsMessagesHaveSentYearFilteredIfWant);
      pt.y = 0x1120;
    }
    else if ((iMsgCur < 0) ||
            ((((uint)((byte *)bitfMsgFiltered)[(int)scan._0_2_ >> 3] &
              1 << ((byte)scan._0_2_ & 7)) == 0 || (fViewFilteredMsg != 0)))) {
      pt.x = (short)PszGetMessageN(iMsgCur);
      pt.y = 0x1120;
    }
    else {
      pt.x = (short)PszGetCompressedString(idsMessageTypeHasFilteredWillShownDefault);
      pt.y = 0x1120;
    }
  }
  else {
    lpmsgplr._0_2_ = (MSGPLR *)vlpmsgplrIn;
    lpmsgplr._2_2_ = vlpmsgplrIn._2_2_;
    for (i = cMsg; i < iMsgCur; i = i + 1) {
      pMVar2 = (MSGPLR *)CONCAT22(lpmsgplr._2_2_,(MSGPLR *)lpmsgplr);
                    /* WARNING: Load size is inaccurate */
      lpmsgplr._2_2_ = *(undefined2 *)((int)&((MSGPLR *)lpmsgplr)->lpmsgplrNext + 2);
      lpmsgplr._0_2_ = pMVar2->lpmsgplrNext;
    }
    CchGetString(idsSCC,szT);
    uVar21 = 10;
    uVar20 = 0xd;
    pcVar6 = PszPlayerName(((MSGPLR *)lpmsgplr)->iPlrFrom,1,1,1,0,(PLAYER *)0x0);
    cch = _wsprintf((char *)CONCAT13((char)((uint)lpb2k._2_2_ >> 8),
                                     CONCAT12((char)lpb2k._2_2_,(byte *)lpb2k)),
                    (char *)CONCAT22(unaff_SS,szT),pcVar6,0x1120,uVar20,uVar21);
    CchGetString(idsSCC2,szT);
    uVar21 = 10;
    uVar20 = 0xd;
    if (((MSGPLR *)lpmsgplr)->iPlrTo == 0) {
      pcVar6 = PszGetCompressedString(idsEverybody);
    }
    else {
      pcVar6 = PszPlayerName(((MSGPLR *)lpmsgplr)->iPlrTo + -1,1,1,1,0,(PLAYER *)0x0);
    }
    sVar9 = _wsprintf((char *)CONCAT13((char)((uint)lpb2k._2_2_ >> 8),
                                       CONCAT12((char)lpb2k._2_2_,
                                                (byte *)lpb2k + cch)),
                      (char *)CONCAT22(unaff_SS,szT),pcVar6,0x1120,uVar20,uVar21);
    cch = cch + sVar9;
    if (((MSGPLR *)lpmsgplr)->cLen < 0) {
      __fstrcpy((char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k + cch),
                        (char *)CONCAT22(lpmsgplr._2_2_,(MSGPLR *)lpmsgplr + 1));
    }
    else {
      i = 1000;
      FDecompressUserString
                ((char *)CONCAT22(lpmsgplr._2_2_,(MSGPLR *)lpmsgplr + 1),((MSGPLR *)lpmsgplr)->cLen,
                 (char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k + cch),&i);
    }
    pt.y = lpb2k._2_2_;
    pt.x = (short)(byte *)lpb2k;
  }
  SetTextColor(hdc,0xffffff);
  iMode = SetBkMode(hdc,1);
  if ((iMsgCur < 0) && (0 < cMsg)) {
LAB_1030_68c6:
    cch = CchGetString(idsFiltered,(char *)szWork);
    DiaganolTextOut(hdc,(RECT *)&stack0xff8c,(char *)szWork,cch);
    pt.x = (short)PszGetMessageN(iMsgCur);
    pt.y = 0x1120;
  }
  else if ((-1 < iMsgCur) && (iMsgCur < cMsg)) {
    sVar9 = IdmGetMessageN(iMsgCur);
    sVar10 = IdmGetMessageN(iMsgCur);
    if (((uint)((byte *)bitfMsgFiltered)[sVar10 >> 3] & 1 << ((byte)sVar9 & 7)) != 0)
    goto LAB_1030_68c6;
  }
  SetTextColor(hdc,CONCAT22(crButtonText._2_2_,(undefined2)crButtonText));
  rcActual.right = sVar7;
  rcActual.bottom = sVar4;
  pcVar6 = (char *)pt.x;
  sVar9 = pt.y;
  HVar22 = hdc;
  rcActual.left = sVar24;
  rcActual.top = y;
  uVar11 = __fstrlen((char *)pt);
  DRAWTEXT(HVar22,(LPCSTR)CONCAT22(sVar9,pcVar6),uVar11,(RECT *)CONCAT22(unaff_SS,&rcActual),0xc10);
  if ((sVar4 < rcActual.bottom) || (sVar7 < rcActual.right)) {
    SetWindowText(hwndMsgScroll,(LPCSTR)pt);
    ExpandRc((RECT *)&stack0xff8c,4,4);
    SetWindowPos(hwndMsgScroll,0,sVar24,y,sVar7 - sVar24,sVar4 - y,0x44);
  }
  else {
    ShowWindow(hwndMsgScroll,0);
    pcVar6 = (char *)pt.x;
    sVar7 = pt.y;
    HVar22 = hdc;
    uVar11 = __fstrlen((char *)pt);
    DRAWTEXT(HVar22,(LPCSTR)CONCAT22(sVar7,pcVar6),uVar11,
             (RECT *)CONCAT22(unaff_SS,(RECT *)&stack0xff8c),0x810);
  }
  SetBkMode(hdc,iMode);
LAB_1030_6a4b:
  SetTextColor(hdc,crFore);
  SetBkColor(hdc,scan._2_4_);
  EndPaint(hwnd,(PAINTSTRUCT *)CONCAT22(unaff_SS,&ps));
  return 0;
}



// ======================================================================
// Function: SetMsgTitle
// Address: 1030:7218
// Segment: MEMORY_MSG
// ======================================================================


void SetMsgTitle(HWND hwnd)

{
  char *pcVar1;
  int iVar2;
  short sVar3;
  MSGPLR *pMVar4;
  undefined2 uVar5;
  undefined2 unaff_SS;
  FLEET *pFVar6;
  ushort uVar7;
  RECT rc;
  MSGPLR *lpmp;
  short sw;
  char szT [80];
  char ch;
  MSGBIG mb;
  short i;
  short cMsgTot;
  
  if (hwnd == 0) {
    return;
  }
  if (fAi != 0) {
    return;
  }
  if (game.fDirty == 0) {
    ch = ' ';
  }
  else {
    ch = '*';
  }
  if (((uint)gd.grBits >> 8 & 1) == 0) {
    sw = 0;
  }
  else {
    sw = 5;
  }
  ShowWindow(hwndMsgEdit,sw);
  ShowWindow(hwndMsgDrop,sw);
  ShowWindow(rghwndMsgBtn[3],sw);
  if (((uint)gd.grBits >> 8 & 1) != 0) {
    ShowWindow(hwndMsgScroll,0);
  }
  cMsgTot = cMsg + vcmsgplrIn;
  if (((uint)gd.grBits >> 8 & 1) == 0) {
    if (iMsgCur < cMsg) {
      if (((uint)gd.grBits >> 0xc & 1) == 0) {
        i = idsGoto3;
      }
      else {
        i = idsView;
      }
    }
    else {
      i = idsReply;
    }
  }
  else {
    i = idsDone;
  }
  uVar7 = rghwndMsgBtn[1];
  pcVar1 = PszGetCompressedString(i);
  SetWindowText(uVar7,(LPCSTR)CONCAT22(0x1120,pcVar1));
  if (((uint)gd.grBits >> 8 & 1) != 0) {
    iVar2 = iMsgSendCur + 1;
    sVar3 = vcmsgplrOut;
    pcVar1 = PszGetCompressedString(idsSendMessagesDD);
    _wsprintf(szWork,(char *)CONCAT22(0x1120,pcVar1),iVar2,sVar3);
    rc.left = rcMsgText.left;
    rc.top = rcMsgText.top;
    rc.right = rcMsgText.right;
    rc.bottom = rcMsgText.bottom;
    ExpandRc(&rc,-4,-4);
    SetWindowPos(hwndMsgDrop,0,rc.left + 0x1e,rc.top,(rc.right - rc.left) + -0x54,
                 rc.bottom - rc.top,0x44);
    SetWindowPos(rghwndMsgBtn[3],0,rc.right + -0x32,rc.top,0,0,0x45);
    rc.top = rc.top + dyShipDD + 3;
    SetWindowPos(hwndMsgEdit,0,rc.left,rc.top,rc.right - rc.left,rc.bottom - rc.top,0x44);
    EnableWindow(rghwndMsgBtn[0],(uint)(0 < iMsgSendCur));
    EnableWindow(rghwndMsgBtn[1],1);
    EnableWindow(rghwndMsgBtn[2],1);
    lpmp = (MSGPLR *)CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
    i = iMsgSendCur;
    while( true ) {
      iVar2 = i + -1;
      if (i < 1) break;
                    /* WARNING: Load size is inaccurate */
      lpmp = (MSGPLR *)
             CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
      i = iVar2;
    }
    if (((MSGPLR *)lpmp == (MSGPLR *)0x0) && (lpmp._2_2_ == 0)) {
      i = iVar2;
      SendMessage(hwndMsgDrop,0x40e,viInRe,0);
      SetWindowText(hwndMsgEdit,(LPCSTR)0x11200b34);
    }
    else {
      i = iVar2;
      SendMessage(hwndMsgDrop,0x40e,((MSGPLR *)lpmp)->iPlrTo,0);
      uVar5 = (undefined2)((ulong)lpmp >> 0x10);
      pMVar4 = (MSGPLR *)lpmp;
      if (pMVar4->cLen < 0) {
        SetWindowText(hwndMsgEdit,(LPCSTR)CONCAT22(uVar5,pMVar4 + 1));
      }
      else {
        i = 1000;
        FDecompressUserString
                  ((char *)CONCAT22(uVar5,pMVar4 + 1),pMVar4->cLen,
                   (char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k),&i);
        SetWindowText(hwndMsgEdit,
                      (LPCSTR)CONCAT22(lpb2k._2_2_,(byte *)lpb2k));
      }
    }
    goto MSG_FinishUp;
  }
  if (cMsgTot == 0) {
    CchGetString(idsYearDCMessagesNone,szT);
    _wsprintf(szWork,(char *)CONCAT22(unaff_SS,szT),game.turn + 0x960,(int)ch);
  }
  else {
    CchGetString(idsYearDCMessagesDD,szT);
    _wsprintf(szWork,(char *)CONCAT22(unaff_SS,szT),game.turn + 0x960,(int)ch,
              iMsgCur + 1,cMsgTot);
  }
  uVar7 = rghwndMsgBtn[0];
  sVar3 = IMsgPrev(0);
  EnableWindow(uVar7,(uint)(sVar3 != -1));
  uVar7 = rghwndMsgBtn[2];
  sVar3 = IMsgNext(0);
  EnableWindow(uVar7,(uint)(sVar3 != -1));
  if (cMsg <= iMsgCur) {
    EnableWindow(rghwndMsgBtn[1],1);
    goto MSG_FinishUp;
  }
  if (((cMsg != 0) && (iMsgCur < cMsg)) &&
     (sVar3 = FGetNMsgbig(iMsgCur,&mb), sVar3 != 0)) {
    if (mb.wGoto == 0xffff) {
      mdMsgObj = 0;
    }
    else {
      idMsgObj = mb.wGoto & 0x7fff;
      if (mb.wGoto == 0xfffe) {
        mdMsgObj = 3;
      }
      else if (mb.wGoto == 0xfffd) {
        mdMsgObj = 5;
      }
      else if (mb.wGoto == 0xfffc) {
        mdMsgObj = 8;
      }
      else if (mb.wGoto == 0xfffb) {
        mdMsgObj = 9;
      }
      else if (mb.wGoto == 0xfffa) {
        mdMsgObj = 10;
        vptMsg.x = mb.rgParam[0];
      }
      else if (mb.wGoto == 0xfff9) {
        mdMsgObj = 0xb;
      }
      else if ((mb.wGoto & 0xc000U) == 0xc000) {
        mdMsgObj = 4;
      }
      else if ((mb.wGoto & 0x4000U) == 0) {
        if (mb.wGoto < 0) {
          pFVar6 = LpflFromId(idMsgObj);
          if (pFVar6 == (FLEET *)0x0) {
            mdMsgObj = 0;
          }
          else {
            mdMsgObj = 2;
          }
        }
        else {
          mdMsgObj = 1;
        }
      }
      else {
        idMsgObj = mb.wGoto & 0x3fff;
        if (idMsgObj == 0x800) {
          mdMsgObj = 7;
        }
        else {
          mdMsgObj = 6;
          vptMsg.x = mb.rgParam[0];
          vptMsg.y = mb.rgParam[1];
        }
      }
    }
  }
  if (mdMsgObj != 0) {
    if (iMsgCur < 0) {
LAB_1030_77bb:
      mdMsgObj = 0;
    }
    else if (fViewFilteredMsg == 0) {
      sVar3 = IdmGetMessageN(iMsgCur);
      lpmp = (MSGPLR *)CONCAT22(1 << ((byte)sVar3 & 7),(MSGPLR *)lpmp);
      sVar3 = IdmGetMessageN(iMsgCur);
      if ((((byte *)bitfMsgFiltered)[sVar3 >> 3] & lpmp._2_2_) != 0) goto LAB_1030_77bb;
    }
  }
  EnableWindow(rghwndMsgBtn[1],(uint)(mdMsgObj != 0));
MSG_FinishUp:
  _strcpy((char *)szMsgTitle,(char *)szWork);
  InvalidateRect(hwndMessage,&rcMsgTitle,1);
  return;
}



// ======================================================================
// Function: IMsgNext
// Address: 1030:7808
// Segment: MEMORY_MSG
// ======================================================================


short IMsgNext(short fFilteredOnly)

{
  short sVar1;
  short idm;
  short i;
  
  i = iMsgCur;
  if ((fViewFilteredMsg == 0) || (fFilteredOnly != 0)) {
    do {
      i = i + 1;
      if (cMsg <= i) {
        if (i < cMsg + vcmsgplrIn) {
          return i;
        }
        return -1;
      }
      sVar1 = IdmGetMessageN(i);
    } while ((uint)(((uint)((byte *)bitfMsgFiltered)[sVar1 >> 3] & 1 << ((byte)sVar1 & 7))
                   == 0) == fFilteredOnly);
  }
  else if (iMsgCur < cMsg + vcmsgplrIn + -1) {
    i = iMsgCur + 1;
  }
  else {
    i = -1;
  }
  return i;
}



// ======================================================================
// Function: IMsgPrev
// Address: 1030:78d8
// Segment: MEMORY_MSG
// ======================================================================


short IMsgPrev(short fFilteredOnly)

{
  short sVar1;
  short idm;
  short i;
  
  i = iMsgCur;
  if ((fViewFilteredMsg == 0) || (fFilteredOnly != 0)) {
    if (cMsg < iMsgCur) {
      i = iMsgCur + -1;
    }
    else {
      do {
        i = i + -1;
        if (i < 0) {
          return -1;
        }
        sVar1 = IdmGetMessageN(i);
      } while ((uint)(((uint)((byte *)bitfMsgFiltered)[sVar1 >> 3] &
                      1 << ((byte)sVar1 & 7)) == 0) == fFilteredOnly);
    }
  }
  else if (iMsgCur < 1) {
    i = -1;
  }
  else {
    i = iMsgCur + -1;
  }
  return i;
}



// ======================================================================
// Function: DecorateMsgTitleBar
// Address: 1030:799c
// Segment: MEMORY_MSG
// ======================================================================


void DecorateMsgTitleBar(HDC hdc,RECT *prc)

{
  HDC HVar1;
  int iVar2;
  short sVar3;
  HGDIOBJ HVar4;
  int iVar5;
  COLORREF CVar6;
  COLORREF CVar7;
  undefined2 crTextSav;
  undefined2 local_22;
  undefined2 crBkSav;
  undefined2 local_1e;
  short xyStart;
  short dxSrc;
  short yDst;
  short ySrc;
  short idm;
  HDC hdcMem;
  short i;
  short dySrc;
  HBITMAP hbmpSav;
  HBRUSH hbrSav;
  short ySrcMask;
  short xDst;
  
  CVar7 = CONCAT22(local_1e,crBkSav);
  CVar6 = CONCAT22(local_22,crTextSav);
  HVar1 = CreateCompatibleDC(hdc);
  hbmpSav = SelectObject(HVar1,hbmpMono);
  if (((uint)gd.grBits >> 8 & 1) == 0) {
    iVar2 = ((prc->bottom - prc->top) + -0xb) / 2 + prc->top;
    if ((-1 < iMsgCur) && (iMsgCur < cMsg)) {
      sVar3 = IdmGetMessageN(iMsgCur);
      if (((uint)((byte *)bitfMsgFiltered)[sVar3 >> 3] & 1 << ((byte)sVar3 & 7)) == 0) {
        ySrc = 0;
        dxSrc = 0xf;
        dySrc = 0xe;
        ySrcMask = 0x1c;
        yDst = iVar2 + -3;
        xDst = iVar2;
      }
      else {
        ySrc = 0xe;
        dxSrc = 0xe;
        dySrc = 0xc;
        xDst = iVar2 + -1;
        ySrcMask = 0x2a;
        yDst = iVar2;
      }
      CVar6 = SetTextColor(hdc,0);
      CVar7 = SetBkColor(hdc,0xffffff);
      BitBlt(hdc,xDst,yDst,dxSrc,dySrc,HVar1,0,ySrcMask,0x8800c6);
      hbmpSav = SelectObject(HVar1,hbmpMsg);
      BitBlt(hdc,xDst,yDst,dxSrc,dySrc,HVar1,0,ySrc,0xee0086);
    }
    i = 0;
    while (((uint)i < 0x31 &&
           ((((byte *)bitfMsgSent)[i] & ((byte *)bitfMsgFiltered)[i]) == 0))) {
      i = i + 1;
    }
    if (i == 0x31) {
      fViewFilteredMsg = 0;
    }
    else {
      if (fViewFilteredMsg == 0) {
        ySrc = 0x29;
        ySrcMask = 0x45;
      }
      else {
        ySrc = 0x1a;
        ySrcMask = 0x36;
      }
      iVar2 = prc->right - (prc->bottom - prc->top);
      HVar4 = SelectObject(hdc,hbrButtonShadow);
      PatBlt(hdc,iVar2 + -1,prc->top,1,prc->bottom - prc->top,0xf00021);
      SelectObject(hdc,hbrButtonHilite);
      PatBlt(hdc,iVar2,prc->top,1,prc->bottom - prc->top,0xf00021);
      SelectObject(hdc,HVar4);
      iVar2 = ((prc->bottom - prc->top) + -0xf) / 2 + prc->top;
      iVar5 = prc->right - (prc->bottom - iVar2);
      SelectObject(HVar1,hbmpMono);
      BitBlt(hdc,iVar5,iVar2,0xf,0xf,HVar1,0,ySrcMask,0x8800c6);
      SelectObject(HVar1,hbmpMsg);
      BitBlt(hdc,iVar5,iVar2,0xf,0xf,HVar1,0,ySrc,0xee0086);
    }
  }
  SetTextColor(hdc,CVar6);
  SetBkColor(hdc,CVar7);
  if ((game.wCrap >> 2 & 1) == 0) {
    SelectObject(HVar1,hbmpMsg);
    iVar2 = prc->right;
    iVar5 = ((prc->bottom - prc->top) + -7) / 2 + prc->top;
    PatBlt(hdc,iVar2 + -0x2e,iVar5 + -1,0x11,0xb,0x42);
    BitBlt(hdc,iVar2 + -0x2d,iVar5,0xf,9,HVar1,0,0x38,0xcc0020);
  }
  SelectObject(HVar1,hbmpSav);
  DeleteDC(HVar1);
  return;
}



// ======================================================================
// Function: HtMsgBox
// Address: 1030:7d8c
// Segment: MEMORY_MSG
// ======================================================================


short HtMsgBox(POINT pt)

{
  BOOL BVar1;
  short i;
  
  BVar1 = PtInRect(&rcMsgTitle,pt);
  if (BVar1 != 0) {
    if ((((pt.x < (rcMsgTitle.bottom - rcMsgTitle.top) +
                  rcMsgTitle.left) && (-1 < iMsgCur)) &&
        (iMsgCur < cMsg)) && (((uint)gd.grBits >> 8 & 1) == 0)) {
      return 1;
    }
    if ((pt.x < rcMsgTitle.right -
                (rcMsgTitle.bottom - rcMsgTitle.top)) ||
       (((uint)gd.grBits >> 8 & 1) != 0)) {
      if (((game.wCrap >> 2 & 1) == 0) &&
         ((rcMsgTitle.right - (rcMsgTitle.bottom - rcMsgTitle.top)) +
          -0x18 <= pt.x)) {
        return 3;
      }
    }
    else {
      i = 0;
      while (((uint)i < 0x31 &&
             ((((byte *)bitfMsgSent)[i] & ((byte *)bitfMsgFiltered)[i]) == 0)))
      {
        i = i + 1;
      }
      if (i != 0x31) {
        return 2;
      }
    }
  }
  return 0;
}



// ======================================================================
// Function: FSendPlrMsg2
// Address: 1030:7eaa
// Segment: MEMORY_MSG
// ======================================================================


short FSendPlrMsg2(short iPlr,MessageId iMsg,short iObj,short p1,short p2)

{
  short sVar1;
  
  sVar1 = FSendPlrMsg(iPlr,iMsg,iObj,p1,p2,0,0,0,0,0);
  return sVar1;
}



// ======================================================================
// Function: FSendPlrMsg
// Address: 1030:7ee8
// Segment: MEMORY_MSG
// ======================================================================


short FSendPlrMsg(short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,short p5,
                short p6,short p7)

{
  ushort uVar1;
  uint uVar2;
  undefined2 unaff_SS;
  short cbMsg;
  byte rgbWork [42];
  
  uVar1 = PackageUpMsg(rgbWork,iPlr,iMsg,iObj,p1,p2,p3,p4,p5,p6,p7);
  if ((int)uVar1 < 1) {
    uVar2 = (uint)(uVar1 == 0);
  }
  else {
    __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                        (void *)((int)(short *)lpMsg + imemMsgCur)),
                       (byte *)CONCAT22(unaff_SS,rgbWork),uVar1);
    imemMsgCur = imemMsgCur + uVar1;
    cMsg = cMsg + 1;
    uVar2 = 1;
  }
  return uVar2;
}



// ======================================================================
// Function: FSendPrependedPlrMsg
// Address: 1030:7f80
// Segment: MEMORY_MSG
// ======================================================================


short FSendPrependedPlrMsg
          (short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,short p5,
          short p6,short p7)

{
  ushort uVar1;
  uint uVar2;
  undefined2 unaff_SS;
  short cbMsg;
  byte rgbWork [42];
  
  uVar1 = PackageUpMsg(rgbWork,iPlr,iMsg,iObj,p1,p2,p3,p4,p5,p6,p7);
  if ((int)uVar1 < 1) {
    uVar2 = (uint)(uVar1 == 0);
  }
  else {
    __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                        (void *)((int)(short *)lpMsg + uVar1)),
                       (short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),imemMsgCur
                      );
    __fmemmove((short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),
                       (byte *)CONCAT22(unaff_SS,rgbWork),uVar1);
    imemMsgCur = imemMsgCur + uVar1;
    cMsg = cMsg + 1;
    uVar2 = 1;
  }
  return uVar2;
}



// ======================================================================
// Function: PackageUpMsg
// Address: 1030:802a
// Segment: MEMORY_MSG
// ======================================================================


short PackageUpMsg(byte *pb,short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,
                 short p5,short p6,short p7)

{
  byte *pbVar1;
  uint uVar2;
  short sVar3;
  byte *lpb;
  MSGTURN *lpmt;
  ushort grbit;
  short i;
  short *pi;
  
  if (iPlr == -1) {
    sVar3 = 0;
  }
  else if (((((*(uint *)((int)&rgplr[0].wMdPlr + iPlr * 0xc0) >> 9 & 1) == 0) ||
            (*(uint *)((int)&rgplr[0].wMdPlr + iPlr * 0xc0) >> 0xd == 7)) ||
           (iMsg == idmHasBombedKillingOffEnemyColonists)) ||
          (((iMsg == idmHaveAttackedFirstRateStormTroopersThough ||
            (iMsg == idmColonistsHaveDiedOffLongerControlPlanet)) ||
           (iMsg == idmColonistsHaveJumpedShipLongerControlPlanet)))) {
    if (imemMsgCur + 0x14U < 0xffc9) {
      lpmt = (MSGTURN *)CONCAT22(0x1120,pb);
      lpmt->bFlags = lpmt->bFlags & 0xf0 | (byte)iPlr & 0xf;
      *(MessageId *)(pb + 1) =
           *(MessageId *)(pb + 1) &
           ~(idmDueExcessiveFleetManeuveringBattleAreaFleets|
            idmTipCanHideUnimportantMessagesClickingCheckmark) |
           iMsg & (idmDueExcessiveFleetManeuveringBattleAreaFleets|
                  idmTipCanHideUnimportantMessagesClickingCheckmark);
      *(uint *)(pb + 1) = *(uint *)(pb + 1) & 0x1ff;
      *(short *)(pb + 3) = iObj;
      lpb = (byte *)CONCAT22(0x1120,pb + 5);
      grbit = 1;
      pi = &p1;
      for (i = 0; i < *(char *)((int)rgplr[1].szNames + 0xc + iMsg); i = i + 1) {
        if ((*pi & 0xff00U) == 0) {
          *lpb = (byte)*pi;
          pbVar1 = (byte *)lpb + 1;
        }
        else {
          uVar2 = *(uint *)(pb + 1);
          *(uint *)(pb + 1) = *(uint *)(pb + 1) & 0x1ff;
          *(uint *)(pb + 1) = *(uint *)(pb + 1) | grbit << 9 | uVar2 & 0xfe00;
          *(short *)lpb = *pi;
          pbVar1 = (byte *)lpb + 2;
        }
        lpb = (byte *)CONCAT22(lpb._2_2_,pbVar1);
        pi = pi + 1;
        grbit = grbit << 1;
      }
      lpmt->bFlags = lpmt->bFlags & 0xf | ((char)lpb - (char)(pb + 5)) * '\x10';
      sVar3 = (int)(byte *)lpb - (int)pb;
    }
    else {
      sVar3 = -1;
    }
  }
  else {
    sVar3 = 0;
  }
  return sVar3;
}



// ======================================================================
// Function: FSendPlrMsg2XGen
// Address: 1030:823a
// Segment: MEMORY_MSG
// ======================================================================


short FSendPlrMsg2XGen(short fPrepend,MessageId iMsg,short iObj,short p1,short p2)

{
  short sVar1;
  ushort uVar2;
  undefined2 unaff_SS;
  MSGHDR *pmsghdr;
  ushort cSize;
  byte *pb;
  ushort grbit;
  short i;
  short *pi;
  MessageId rgb;
  short local_42;
  byte local_40 [62];
  
  if (imemMsgCur + 0x14U < 0xffc9) {
    rgb = iMsg & (idmDueExcessiveFleetManeuveringBattleAreaFleets|
                 idmTipCanHideUnimportantMessagesClickingCheckmark);
    ((byte *)bitfMsgSent)[(int)iMsg >> 3] =
         ((byte *)bitfMsgSent)[(int)iMsg >> 3] & ~(byte)(1 << ((byte)iMsg & 7)) |
         (byte)(1 << ((byte)iMsg & 7));
    local_42 = iObj;
    pb = local_40;
    grbit = 1;
    pi = &p1;
    for (i = 0; i < *(char *)((int)rgplr[1].szNames + 0xc + iMsg); i = i + 1) {
      if ((*pi & 0xff00U) == 0) {
        *pb = (byte)*pi;
        pb = pb + 1;
      }
      else {
        rgb = rgb & (idmDueExcessiveFleetManeuveringBattleAreaFleets|
                    idmTipCanHideUnimportantMessagesClickingCheckmark) |
              grbit << 9 |
              rgb & ~(idmDueExcessiveFleetManeuveringBattleAreaFleets|
                     idmTipCanHideUnimportantMessagesClickingCheckmark);
        *(short *)pb = *pi;
        pb = pb + 2;
      }
      pi = pi + 1;
      grbit = grbit << 1;
    }
    uVar2 = (int)pb - (int)&rgb;
    if (fPrepend == 0) {
      __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                          (void *)((int)(short *)lpMsg + imemMsgCur)),
                         (MessageId *)CONCAT22(unaff_SS,&rgb),uVar2);
    }
    else {
      __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                          (void *)((int)(short *)lpMsg + uVar2)),
                         (short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),
                         imemMsgCur);
      __fmemmove((short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),
                         (MessageId *)CONCAT22(unaff_SS,&rgb),uVar2);
    }
    imemMsgCur = imemMsgCur + uVar2;
    cMsg = cMsg + 1;
    iMsgCur = -1;
    iMsgCur = IMsgNext(0);
    sVar1 = 1;
  }
  else {
    sVar1 = 0;
  }
  return sVar1;
}



// ======================================================================
// Function: IdmGetMessageN
// Address: 1030:8412
// Segment: MEMORY_MSG
// ======================================================================


short IdmGetMessageN(short iMsg)

{
  short sVar1;
  MSGBIG mb;
  
  sVar1 = FGetNMsgbig(iMsg,&mb);
  if (sVar1 == 0) {
    mb.iMsg = -1;
  }
  return mb.iMsg;
}



// ======================================================================
// Function: FGetNMsgbig
// Address: 1030:8444
// Segment: MEMORY_MSG
// ======================================================================


short FGetNMsgbig(short iMsg,MSGBIG *pmb)

{
  char cVar1;
  bool bVar2;
  byte *pbVar3;
  byte *pbVar4;
  short sVar5;
  uint uVar6;
  byte *pbVar7;
  ushort u;
  byte *lpb;
  short i;
  MSGHDR *lpmh;
  short iMax;
  
  if ((iMsg < 0) || (cMsg <= iMsg)) {
    sVar5 = 0;
  }
  else {
    lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg);
    pbVar7 = (byte *)((int)(short *)lpMsg + imemMsgCur);
    do {
      pbVar4 = lpb;
      pbVar3 = (byte *)lpb;
      if (pbVar7 <= (byte *)lpb) break;
      u = *(uint *)lpb >> 9;
      lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + 4);
      if (iMsg == 0) {
        pmb->iMsg = *(uint *)pbVar4 & 0x1ff;
        pmb->wGoto = *(short *)(pbVar3 + 2);
      }
      cVar1 = *(char *)((int)rgplr[1].szNames + 0xc + (*(uint *)pbVar4 & 0x1ff));
      for (i = 0; i < cVar1; i = i + 1) {
        if (iMsg == 0) {
          if ((u & 1) == 0) {
            uVar6 = (uint)*lpb;
          }
          else {
            uVar6 = *(uint *)lpb;
          }
          pmb->rgParam[i] = uVar6;
        }
        lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + ((u & 1) == 1) + 1);
        u = u >> 1;
      }
      bVar2 = 0 < iMsg;
      iMsg = iMsg + -1;
    } while (bVar2);
    sVar5 = 1;
  }
  return sVar5;
}



// ======================================================================
// Function: PszGetMessageN
// Address: 1030:8580
// Segment: MEMORY_MSG
// ======================================================================


char * PszGetMessageN(short iMsg)

{
  short sVar1;
  char *pcVar2;
  undefined2 unaff_SS;
  char *psz;
  MSGBIG mb;
  
  sVar1 = FGetNMsgbig(iMsg,&mb);
  if (sVar1 == 0) {
    szMsgBuf[0] = '\0';
    pcVar2 = (char *)szMsgBuf;
  }
  else {
    pcVar2 = PszFormatMessage(mb.iMsg,(short *)CONCAT22(unaff_SS,mb.rgParam));
  }
  return pcVar2;
}



// ======================================================================
// Function: PszFormatString
// Address: 1030:85cc
// Segment: MEMORY_MSG
// ======================================================================


char * PszFormatString(char *pszFormat,short *pParamsReal)

{
  char cVar1;
  short sVar2;
  char *pcVar3;
  ushort uVar4;
  uint uVar5;
  undefined2 unaff_SI;
  undefined2 unaff_DI;
  bool bVar6;
  long lVar7;
  long lVar8;
  uint in_stack_0000fe00;
  PART part;
  char *pch;
  ushort w;
  char szBuf [480];
  char *pchT;
  short *pParams;
  short i;
  short c;
  short cOut;
  short iMineral;
  
  lVar8 = CONCAT22(unaff_SI,unaff_DI);
  iMineral = -1;
  pParams = pParamsReal;
  pch = (char *)szMsgBuf;
  do {
    if (*pszFormat == '\0') {
      *pch = '\0';
      return (char *)szMsgBuf;
    }
    if (*pszFormat != '\\') {
      *pch = *pszFormat;
      pch = pch + 1;
      goto LAB_1030_8f4d;
    }
    pszFormat = pszFormat + 1;
    uVar5 = (int)*pszFormat - 0x45;
    if (0x35 < uVar5) {
switchD_1030_8edc_caseD_3:
      *pch = *pszFormat;
      pch = pch + 1;
      goto LAB_1030_8f4d;
    }
    bVar6 = (int)uVar5 < 0;
    switch(uVar5) {
    case 0:
      pchT = PszCalcEnvVar((uint)*pParams >> 8,*pParams & 0xff);
      break;
    case 1:
      pchT = PszFleetNameFromWord(*pParams);
      break;
    case 2:
      w = *pParams;
      c = CchGetString(w + idsMineField,pch);
      pch = pch + c;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    default:
      goto switchD_1030_8edc_caseD_3;
    case 4:
      pchT = PszGetCompressedString(*pParams + idsDecreased);
      break;
    case 7:
    case 0x27:
      pchT = PszPlayerName(*pParams & 0xf,(uint)(*pszFormat == 'L'),
                                 (uint)((*pParams & 0x10U) != 0),(uint)((*pParams & 0x20U) != 0),
                                 (int)(*pParams & 0xc0U) >> 6,(PLAYER *)0x0);
      break;
    case 8:
      pchT = (char *)*(undefined2 *)(*pParams * 2 + 0x4f2);
      break;
    case 10:
      w = (uint)*pParams >> 9 & 0xf;
      pchT = PszPlayerName(w,0,0,0,0,(PLAYER *)0x0);
      break;
    case 0xb:
      part.hs.grhst = *pParams / 100;
      part.hs.wFlags_0x2 = (int)part.hs.grhst >> 0xf;
      __aFfcompp();
      if (bVar6) {
        c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)CONCAT22(0x1120,PCTDXPCTDPCTPCT),
                      *pParams / 100,*pParams + (*pParams / 100) * -100);
      }
      else {
        c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)CONCAT22(0x1120,PCTDPCTPCT),
                      *pParams / 100);
      }
      pch = pch + c;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    case 0xe:
      if (*pParams != idPlayer) {
        CchGetString(idsOf2,szBuf);
        pchT = PszPlayerName(*pParams,0,0,0,0,(PLAYER *)0x0);
        _strcat(szBuf,pchT);
        pcVar3 = PszGetCompressedString(idsOrigin);
        _strcat(szBuf,pcVar3);
        pchT = szBuf;
        break;
      }
      goto MSG_DoNothing;
    case 0x10:
    case 0x11:
    case 0x31:
      part.hs.grhst = *pParams;
      part.hs.wFlags_0x2 = 0;
      lVar7 = __aFlshl(lVar8,in_stack_0000fe00);
      part.u_PART_0x0004.parmor._0_2_ = (ARMOR *)((HullSlotType)lVar7 | part.hs.grhst);
      part.u_PART_0x0004._2_2_ = (uint)((ulong)lVar7 >> 0x10) | part.hs.wFlags_0x2;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 2);
      c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)CONCAT22(0x1120,PCTLD),
                    part.u_PART_0x0004.parmor._0_2_,part.u_PART_0x0004._2_2_);
      pch = pch + c;
      if (*pszFormat != 'v') {
        if (*pszFormat == 'V') {
          iMineral = *pParams;
        }
        pchT = (char *)*(undefined2 *)(iMineral * 2 + 0xb48);
        _strcpy(pch,pchT);
        uVar4 = _strlen(pchT);
        pch = pch + uVar4;
      }
      goto LAB_1030_8f4d;
    case 0x13:
      goto MSG_DoNothing;
    case 0x15:
      w = *pParams;
      if (w != 0) {
        if ((w - 1 & w) == 0) {
          c = 0;
          for (; (w & 1) == 0; w = w >> 1) {
            c = c + 1;
          }
          pchT = PszPlayerName(c,0,1,1,0,(PLAYER *)0x0);
          break;
        }
        cOut = 0;
        for (i = 0; i < game.cPlayer; i = i + 1) {
          if ((w & 1) != 0) {
            if (0 < cOut) {
              if ((w & 0xfffe) == 0) {
                sVar2 = CchGetString(idsAnd,pch);
                pch = pch + sVar2;
              }
              else {
                pcVar3 = pch + 1;
                *pch = ',';
                pch = pch + 2;
                *pcVar3 = ' ';
              }
            }
            pchT = PszPlayerName(i,0,1,1,0,(PLAYER *)0x0);
            _strcpy(pch,pchT);
            uVar4 = _strlen(pchT);
            pch = pch + uVar4;
            cOut = cOut + 1;
          }
          w = w >> 1;
        }
        goto MSG_DoNothing;
      }
      goto LAB_1030_8f4d;
    case 0x20:
      pchT = (char *)*(undefined2 *)(*pParams * 2 + 0x47e);
      break;
    case 0x21:
    case 0x23:
    case 0x2d:
    case 0x2f:
    case 0x34:
      _strcpy(pch,(char *)szBase);
      uVar4 = _strlen((char *)szBase);
      pch = pch + uVar4;
      cVar1 = *pszFormat;
      if (cVar1 == 'f') {
        if (idPlayer == -1) {
LAB_1030_86a2:
          if (idPlayer == -1) goto LAB_1030_86d0;
          c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)0x11200b59,idPlayer + 1);
        }
        else {
          c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)0x11200b54,idPlayer + 1);
        }
        goto MSG_DoInt;
      }
      if (cVar1 == 'h') {
LAB_1030_86d0:
        _strcat(pch,(char *)0xb5e);
        pch = pch + 4;
      }
      else {
        if (cVar1 == 'r') {
          c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)0x11200b63,idPlayer + 1);
          goto MSG_DoInt;
        }
        if (cVar1 == 't') goto LAB_1030_86a2;
        if (cVar1 == 'y') {
          _strcat(pch,(char *)0xb68);
          pch = pch + 3;
        }
      }
      goto LAB_1030_8f4d;
    case 0x22:
MSG_LThingName:
      pchT = PszGetThingName(*pParams);
      break;
    case 0x24:
      c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)CONCAT22(0x1120,PCTD),*pParams);
MSG_DoInt:
      pch = pch + c;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    case 0x25:
      pchT = PszGetCompressedString(*pParams + idsEnergy);
      break;
    case 0x26:
      part.hs.grhst = *pParams;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      in_stack_0000fe00 = *pParams;
      part.hs.wFlags_0x2 = part.hs.wFlags_0x2 & 0xff00 | in_stack_0000fe00 & 0xff;
      FLookupPart(&part);
      __fstrcpy((char *)CONCAT22(0x1120,pch),
                        (char *)CONCAT22(part.u_PART_0x0004._2_2_,
                                         (part.u_PART_0x0004.parmor._0_2_)->szName));
      uVar4 = __fstrlen((char *)CONCAT22(part.u_PART_0x0004._2_2_,
                                                 (part.u_PART_0x0004.parmor._0_2_)->szName));
      pch = pch + uVar4;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    case 0x28:
      iMineral = *pParams;
      pchT = (char *)*(undefined2 *)(iMineral * 2 + 0x4cc);
      break;
    case 0x29:
      if (*pParams == -2) {
        pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
        goto MSG_LThingName;
      }
      if (*pParams == -1) {
        pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
        goto switchD_1030_8edc_caseD_2a;
      }
      pchT = PszGetLocName(grobjNone,-1,*pParams,((short *)pParams)[1]);
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      break;
    case 0x2a:
switchD_1030_8edc_caseD_2a:
      if ((*pParams & 0x8000U) != 0) goto MSG_DoFleet;
    case 0x2b:
      pchT = PszGetPlanetName(*pParams);
      break;
    case 0x2e:
MSG_DoFleet:
      w = *pParams | 0x8000;
      pchT = PszGetFleetName(w);
      break;
    case 0x30:
      c = _wsprintf((char *)CONCAT22(0x1120,pch),(char *)0x11200b6c,*pParams);
      pch = pch + c;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    case 0x32:
      _strcpy(pch,(char *)szWork);
      uVar4 = _strlen((char *)szWork);
      pch = pch + uVar4;
      goto LAB_1030_8f4d;
    case 0x35:
      c = *pParams >> 5;
      w = *pParams & 0x1f;
      if (w < 0x10) {
        part.u_PART_0x0004._2_2_ = *(uint *)(c * 4 + 0x100);
        part.u_PART_0x0004.parmor._0_2_ = (ARMOR *)(*(int *)(c * 4 + 0xfe) + w * 0x93);
      }
      else {
        part.u_PART_0x0004._2_2_ = *(uint *)(c * 4 + 0x14e);
        part.u_PART_0x0004.parmor._0_2_ = (ARMOR *)(*(int *)(c * 4 + 0x14c) + (w - 0x10) * 0x93);
      }
      if (c == idPlayer) {
        __fstrcpy((char *)CONCAT22(0x1120,pch),
                          (char *)CONCAT22(part.u_PART_0x0004._2_2_,
                                           (part.u_PART_0x0004.parmor._0_2_)->szName));
      }
      else {
        pchT = PszPlayerName(c,0,0,1,0,(PLAYER *)0x0);
        _wsprintf((char *)CONCAT22(0x1120,pch),s__s__s_1120_0b6f,pchT,0x1120,
                  (part.u_PART_0x0004.parmor._0_2_)->szName,part.u_PART_0x0004._2_2_);
      }
      uVar4 = _strlen(pch);
      pch = pch + uVar4;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    }
    _strcpy(pch,pchT);
    uVar4 = _strlen(pchT);
    pch = pch + uVar4;
MSG_DoNothing:
    pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
LAB_1030_8f4d:
    pszFormat = pszFormat + 1;
  } while( true );
}



// ======================================================================
// Function: MsgDlg
// Address: 1030:8f68
// Segment: MEMORY_MSG
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

short MsgDlg(HWND hwnd,WMType message,ushort wParam,long lParam)

{
  HWND HVar1;
  short sVar2;
  char *sz;
  undefined2 unaff_SI;
  undefined2 unaff_DI;
  undefined2 unaff_SS;
  ulong uVar3;
  ushort in_stack_0000fec8;
  char szT [256];
  short cch;
  undefined1 rcEdit [8];
  HDC hdc;
  RECT rc;
  
  if (message == WM_PAINT) {
    hdc = BeginPaint(hwnd,(PAINTSTRUCT *)CONCAT22(unaff_SS,(PAINTSTRUCT *)&stack0xfec8));
    GetClientRect(hwnd,(RECT *)CONCAT22(unaff_SS,&rc));
    HVar1 = GetDlgItem(hwnd,0x10c);
    GetWindowRect(HVar1,(RECT *)CONCAT22(unaff_SS,(RECT *)rcEdit));
    ScreenToClient(hwnd,(POINT *)CONCAT22(unaff_SS,(POINT *)(rcEdit + 4)));
    rcEdit._0_2_ = 8;
    rcEdit._4_2_ = rc.right + -8;
    rcEdit._2_2_ = rcEdit._6_2_ + 8;
    rcEdit._6_2_ = rcEdit._6_2_ + 0x6c;
    SelectObject(hdc,rghfontArial8[1]);
    SetBkColor(hdc,CONCAT22(crButtonFace._2_2_,(undefined2)crButtonFace));
    SetTextColor(hdc,0);
    cch = CchGetString
                    ((int)szWork[200] + idsPleaseEnterUniqueEightCharacterSerialNumber,szT
                    );
    DRAWTEXT(hdc,(LPCSTR)CONCAT22(unaff_SS,szT),cch,(RECT *)CONCAT22(unaff_SS,(RECT *)rcEdit),0x810)
    ;
    EndPaint(hwnd,(PAINTSTRUCT *)CONCAT22(unaff_SS,(PAINTSTRUCT *)&stack0xfec8));
    return 1;
  }
  if (message != WM_ERASEBKGND) {
    if (message == WM_CTLCOLOR) {
      uVar3 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),in_stack_0000fec8);
      if ((int)uVar3 == 6) {
        SetBkColor(wParam,CONCAT22(crButtonFace._2_2_,(undefined2)crButtonFace))
        ;
        return hbrButtonFace;
      }
    }
    else {
      if (message == WM_INITDIALOG) {
        rcEdit._6_2_ = -1;
        hdc = 0xffff;
        szWork[0] = '\0';
        SendDlgItemMessage(hwnd,0x10c,0x415,8,0);
        HVar1 = GetDlgItem(hwnd,0x10c);
        SetWindowText(HVar1,szWork);
        StickyDlgPos(hwnd,(POINT *)(rcEdit + 6),1);
        return 1;
      }
      if (message == WM_COMMAND) {
        if ((wParam == 1) || (wParam == 2)) {
          if (wParam == 1) {
            GetDlgItemText(hwnd,0x10c,szWork,9);
            sVar2 = FValidSerialNo((char *)szWork,(long *)0x0);
            if (sVar2 == 0) {
              sVar2 = 0x10;
              sz = PszFormatIds(idsSerialNumberHaveEnteredValid,(short *)0x0);
              AlertSz(sz,sVar2);
              HVar1 = GetDlgItem(hwnd,0x10c);
              SetFocus(HVar1);
              return 0;
            }
          }
          EndDialog(hwnd,(uint)(wParam == 1));
          return 1;
        }
        if (wParam == 0x76) {
          WinHelp(hwnd,(LPCSTR)CONCAT22(0x1120,_szHelpFile),1,0xdbc);
          return 1;
        }
      }
    }
    return 0;
  }
  GetClientRect(hwnd,(RECT *)CONCAT22(unaff_SS,&rc));
  FillRect(wParam,(RECT *)CONCAT22(unaff_SS,&rc),hbrButtonFace);
  return 1;
}



// ======================================================================
// Function: PszFormatMessage
// Address: 1030:9220
// Segment: MEMORY_MSG
// ======================================================================


char * PszFormatMessage(short idm,short *pParams)

{
  char *pcVar1;
  
  pcVar1 = PszGetCompressedMessage(idm);
  pcVar1 = PszFormatString(pcVar1,pParams);
  return pcVar1;
}



// ======================================================================
// Function: PszFormatIds
// Address: 1030:924c
// Segment: MEMORY_MSG
// ======================================================================


char * PszFormatIds(StringId ids,short *pParams)

{
  char *pcVar1;
  
  pcVar1 = PszGetCompressedString(ids);
  pcVar1 = PszFormatString(pcVar1,pParams);
  return pcVar1;
}



// ======================================================================
// Function: FRemovePlayerMessage
// Address: 1030:9278
// Segment: MEMORY_MSG
// ======================================================================


short FRemovePlayerMessage(short iPlr,MessageId iMsg,short iObj)

{
  byte *pbVar1;
  short cDel;
  byte *lpb;
  
  cDel = 0;
  pbVar1 = (byte *)((int)(short *)lpMsg + imemMsgCur);
  for (lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg); (byte *)lpb < pbVar1;
      lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5)) {
    if ((((*lpb & 0xf) == iPlr) &&
        ((*(MessageId *)((byte *)lpb + 1) &
         (idmDueExcessiveFleetManeuveringBattleAreaFleets|
         idmTipCanHideUnimportantMessagesClickingCheckmark)) == iMsg)) &&
       (*(int *)((byte *)lpb + 3) == iObj)) {
      cDel = cDel + 1;
      *(uint *)((byte *)lpb + 1) = *(uint *)((byte *)lpb + 1) & 0xfe00 | 0x1ff;
    }
  }
  return cDel;
}



// ======================================================================
// Function: FFindPlayerMessage
// Address: 1030:932a
// Segment: MEMORY_MSG
// ======================================================================


short FFindPlayerMessage(short iPlr,MessageId iMsg,short iObj)

{
  byte *lpb;
  
  lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg);
  while( true ) {
    if ((byte *)((int)(short *)lpMsg + imemMsgCur) <= (byte *)lpb) {
      return 0;
    }
    if ((((*lpb & 0xf) == iPlr) &&
        ((*(MessageId *)((byte *)lpb + 1) &
         (idmDueExcessiveFleetManeuveringBattleAreaFleets|
         idmTipCanHideUnimportantMessagesClickingCheckmark)) == iMsg)) &&
       (*(int *)((byte *)lpb + 3) == iObj)) break;
    lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5);
  }
  return 1;
}



// ======================================================================
// Function: MarkPlanetsPlayerLost
// Address: 1030:93c6
// Segment: MEMORY_MSG
// ======================================================================


void MarkPlanetsPlayerLost(short iPlayer)

{
  uint uVar1;
  byte *pbVar2;
  undefined2 uVar3;
  PLANET *lppl;
  byte *lpb;
  ushort w;
  byte *lpbT;
  
  lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg);
  pbVar2 = (byte *)((int)(short *)lpMsg + imemMsgCur);
  do {
    if (pbVar2 <= (byte *)lpb) {
      return;
    }
    uVar3 = (undefined2)((ulong)lpb >> 0x10);
    if ((*lpb & 0xf) == iPlayer) {
      uVar1 = *(uint *)((byte *)lpb + 1) & 0x1ff;
      if (((uVar1 == 7) || (uVar1 == 0x23)) || (uVar1 == 0x40)) {
        w = *(ushort *)((byte *)lpb + 3);
      }
      else {
        if (uVar1 != 0x8f) goto LAB_1030_95d5;
        lpbT = (byte *)CONCAT22(uVar3,(byte *)lpb + ((*(uint *)((byte *)lpb + 1) >> 9 & 1) == 1) + 6
                               );
        if ((*(uint *)((byte *)lpb + 1) >> 9 & 2) == 0) {
          w = (ushort)*lpbT;
        }
        else {
          w = *(ushort *)lpbT;
        }
      }
      lppl = LpplFromId(w);
      if (lppl != (PLANET *)0x0) {
        MarkPlanet(lppl,iPlayer,3);
      }
    }
LAB_1030_95d5:
    lpb = (byte *)CONCAT22(uVar3,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5);
  } while( true );
}



// ======================================================================
// Function: MarkPlayersThatSentMsgs
// Address: 1030:9604
// Segment: MEMORY_MSG
// ======================================================================


void MarkPlayersThatSentMsgs(short iPlayer)

{
  MSGPLR *lpmp;
  
  if (iPlayer != -1) {
    lpmp = (MSGPLR *)CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
    while( true ) {
      if (((MSGPLR *)lpmp == (MSGPLR *)0x0) && (lpmp._2_2_ == 0)) break;
      if (((((MSGPLR *)lpmp)->iPlrTo == 0) && (((MSGPLR *)lpmp)->iPlrFrom != iPlayer)) ||
         ((((MSGPLR *)lpmp)->iPlrTo + -1 == iPlayer &&
          ((*(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) >> 8 & 1)
           == 0)))) {
        *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) =
             *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) & 0xfeff
             | 0x100;
        *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) =
             *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) & 0xfff8
             | 3;
      }
                    /* WARNING: Load size is inaccurate */
      lpmp = (MSGPLR *)
             CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
    }
  }
  return;
}



// ======================================================================
// Function: WritePlayerMessages
// Address: 1030:9702
// Segment: MEMORY_MSG
// ======================================================================


void WritePlayerMessages(short iPlayer)

{
  short sVar1;
  undefined2 uVar2;
  undefined2 unaff_SS;
  MSGPLR *pMVar3;
  int iVar4;
  byte *lpb;
  MSGPLR *lpmp;
  short cbMsg;
  undefined1 rgb [1024];
  byte *lpbMax;
  undefined2 local_6;
  
  cbMsg = 0;
  if (iPlayer != -1) {
    lpbMax = (byte *)((int)(short *)lpMsg + imemMsgCur);
    local_6 = lpMsg._2_2_;
    for (lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg); (byte *)lpb < lpbMax;
        lpb = (byte *)CONCAT22(uVar2,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5)) {
      if (0x3ff < cbMsg + 0x14) {
        WriteRt(0xc,cbMsg,(undefined1 *)CONCAT22(unaff_SS,rgb));
        cbMsg = 0;
      }
      uVar2 = (undefined2)((ulong)lpb >> 0x10);
      if (((*lpb & 0xf) == iPlayer) && ((*(uint *)((byte *)lpb + 1) & 0x1ff) != 0x1ff)) {
        __fmemmove((undefined1 *)CONCAT22(unaff_SS,rgb + cbMsg),
                           (byte *)CONCAT22(uVar2,(byte *)lpb + 1),((int)(uint)*lpb >> 4) + 4);
        cbMsg = cbMsg + ((int)(uint)*lpb >> 4) + 4;
      }
    }
    if (cbMsg != 0) {
      WriteRt(0xc,cbMsg,(undefined1 *)CONCAT22(unaff_SS,rgb));
    }
    lpmp = (MSGPLR *)CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
    while( true ) {
      if (((MSGPLR *)lpmp == (MSGPLR *)0x0) && (lpmp._2_2_ == 0)) break;
      if (((((MSGPLR *)lpmp)->iPlrTo == 0) && (((MSGPLR *)lpmp)->iPlrFrom != iPlayer)) ||
         (((MSGPLR *)lpmp)->iPlrTo + -1 == iPlayer)) {
        pMVar3 = (MSGPLR *)lpmp;
        iVar4 = lpmp._2_2_;
        sVar1 = _abs(((MSGPLR *)lpmp)->cLen);
        WriteRt(0x28,sVar1 + 0xc,(MSGPLR *)CONCAT22(iVar4,pMVar3));
      }
                    /* WARNING: Load size is inaccurate */
      lpmp = (MSGPLR *)
             CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
    }
  }
  return;
}



// ======================================================================
// Function: ResetMessages
// Address: 1030:98d6
// Segment: MEMORY_MSG
// ======================================================================


void ResetMessages(void)

{
  imemMsgCur = 0;
  iMsgCur = -1;
  cMsg = 0;
  iMsgSendCur = 0;
  _memset((byte *)bitfMsgSent,0,0x31);
  _memset((byte *)bitfMsgFiltered,0,0x31);
  vlpmsgplrIn._0_2_ = (MSGPLR *)0x0;
  vlpmsgplrIn._2_2_ = 0;
  vlpmsgplrOut._0_2_ = (MSGPLR *)0x0;
  vlpmsgplrOut._2_2_ = 0;
  vcmsgplrIn = 0;
  vcmsgplrOut = 0;
  return;
}



// ======================================================================
// Function: ReadPlayerMessages
// Address: 1030:994a
// Segment: MEMORY_MSG
// ======================================================================


void ReadPlayerMessages(void)

{
  MSGPLR *pMVar1;
  short sVar2;
  undefined2 uVar3;
  void *pvVar4;
  ushort u;
  MSGHDR *lpb;
  MSGPLR *lpmp;
  short env [9];
  short i;
  ushort imemMsgT;
  MSGHDR *lpmh;
  short (*penvMemSav) [9];
  short fOOM;
  short iMax;
  MSGHDR *lpbMax;
  undefined2 local_6;
  
  uVar3 = lpMsg._2_2_;
  imemMsgT = 0;
  fOOM = 0;
  lpb = (MSGHDR *)((int)(short *)lpMsg + imemMsgCur);
  while (hdrCur.wFlags >> 10 == 0xc) {
    if (((hdrCur.wFlags & 0x3ff) != 0) &&
       (imemMsgCur + imemMsgT < -(hdrCur.wFlags & 0x3ff) - 0x38)) {
      __fmemmove((void *)CONCAT22(uVar3,(void *)((int)&lpb->wFlags + imemMsgT)),
                         rgbCur,hdrCur.wFlags & 0x3ff);
      imemMsgT = imemMsgT + (hdrCur.wFlags & 0x3ff);
    }
    ReadRt();
  }
  imemMsgCur = imemMsgCur + imemMsgT;
  lpbMax = (MSGHDR *)((int)&lpb->wFlags + imemMsgT);
  local_6 = uVar3;
  while (lpb < lpbMax) {
    lpmh = (MSGHDR *)CONCAT22(uVar3,lpb);
    ((byte *)bitfMsgSent)[(lpmh->wFlags & 0x1ff) >> 3] =
         ((byte *)bitfMsgSent)[(lpmh->wFlags & 0x1ff) >> 3] &
         ~(byte)(1 << ((byte)lpmh->wFlags & 7)) | (byte)(1 << ((byte)lpmh->wFlags & 7));
    cMsg = cMsg + 1;
    u = lpmh->wFlags >> 9;
    lpb = lpb + 1;
    iMax = (short)*(char *)((int)rgplr[1].szNames + 0xc + (lpmh->wFlags & 0x1ff));
    for (i = 0; i < iMax; i = i + 1) {
      lpb = (MSGHDR *)((int)&lpb->wFlags + ((u & 1) == 1) + 1);
      u = u >> 1;
    }
  }
  lpmp = (MSGPLR *)&vlpmsgplrIn;
  while( true ) {
    uVar3 = (undefined2)((ulong)lpmp >> 0x10);
    if ((*(int *)&lpmp->lpmsgplrNext == 0) &&
       (*(int *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2) == 0)) break;
                    /* WARNING: Load size is inaccurate */
    lpmp = (MSGPLR *)
           CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
  }
  penvMemSav = penvMem;
  penvMem = &env;
  sVar2 = __setjmp(env);
  if (sVar2 == 0) goto LAB_1030_9b3a;
  penvMem = penvMemSav;
  fOOM = 1;
  while( true ) {
    ReadRt();
LAB_1030_9b3a:
    if (hdrCur.wFlags >> 10 != 0x28) break;
    if (fOOM == 0) {
      pvVar4 = LpAlloc(hdrCur.wFlags & 0x3ff,htPlrMsg);
      uVar3 = (undefined2)((ulong)lpmp >> 0x10);
      *(void **)&lpmp->lpmsgplrNext = (void *)pvVar4;
      *(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2) = (int)((ulong)pvVar4 >> 0x10);
                    /* WARNING: Load size is inaccurate */
      pMVar1 = lpmp->lpmsgplrNext;
      uVar3 = *(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2);
      lpmp = (MSGPLR *)CONCAT22(uVar3,pMVar1);
      __fmemcpy((MSGPLR *)CONCAT22(uVar3,pMVar1),rgbCur,
                        hdrCur.wFlags & 0x3ff);
      *(undefined2 *)&lpmp->lpmsgplrNext = 0;
      *(undefined2 *)((int)&pMVar1->lpmsgplrNext + 2) = 0;
      vcmsgplrIn = vcmsgplrIn + 1;
    }
  }
  iMsgCur = -1;
  iMsgCur = IMsgNext(0);
  return;
}



// ======================================================================
// Function: FFinishPlrMsgEntry
// Address: 1030:9bd6
// Segment: MEMORY_MSG
// ======================================================================


short FFinishPlrMsgEntry(short dInc)

{
  int iVar1;
  MSGPLR *pMVar2;
  int iVar3;
  short sVar4;
  ushort uVar5;
  undefined2 uVar6;
  MSGPLR *pMVar7;
  undefined2 uVar8;
  LRESULT LVar9;
  short cb;
  MSGPLR *lpmpPrev;
  MSGPLR *lpmpCur;
  short iPlrTo;
  short cbNew;
  short i;
  byte *lpbMsg;
  undefined2 local_6;
  
  lpmpPrev = (MSGPLR *)&vlpmsgplrOut;
  i = iMsgSendCur;
  while( true ) {
    iVar1 = i + -1;
    pMVar7 = (MSGPLR *)lpmpPrev;
    uVar8 = (undefined2)((ulong)lpmpPrev >> 0x10);
    if (i < 1) break;
                    /* WARNING: Load size is inaccurate */
    lpmpPrev = (MSGPLR *)
               CONCAT22(*(undefined2 *)((int)&pMVar7->lpmsgplrNext + 2),lpmpPrev->lpmsgplrNext);
    i = iVar1;
  }
                    /* WARNING: Load size is inaccurate */
  pMVar2 = lpmpPrev->lpmsgplrNext;
  iVar3 = *(int *)((int)&pMVar7->lpmsgplrNext + 2);
  lpmpCur = (MSGPLR *)CONCAT22(iVar3,pMVar2);
  if (dInc == 1000) {
    cb = 0;
    dInc = 0;
    i = iVar1;
  }
  else {
    i = iVar1;
    cb = GetWindowText(hwndMsgEdit,
                       (LPSTR)CONCAT22(lpb2k._2_2_,(byte *)lpb2k),1000);
  }
  if (cb == 0) {
    if ((pMVar2 != (MSGPLR *)0x0) || (iVar3 != 0)) {
      DirtyGame(1);
      uVar6 = *(undefined2 *)((int)&pMVar2->lpmsgplrNext + 2);
      *(undefined2 *)&lpmpPrev->lpmsgplrNext = *(undefined2 *)&lpmpCur->lpmsgplrNext;
      *(undefined2 *)((int)&pMVar7->lpmsgplrNext + 2) = uVar6;
      FreeLp((MSGPLR *)CONCAT22(iVar3,pMVar2),htPlrMsg);
      vcmsgplrOut = vcmsgplrOut + -1;
      if (0 < iMsgSendCur) {
        iMsgSendCur = iMsgSendCur + -1;
      }
    }
    if ((dInc == -1) && (0 < iMsgSendCur)) {
      iMsgSendCur = iMsgSendCur + -1;
    }
    else if ((dInc == 1) && (iMsgSendCur < vcmsgplrOut)) {
      iMsgSendCur = iMsgSendCur + 1;
    }
    sVar4 = 0;
  }
  else {
    cbNew = cb;
    sVar4 = FCompressUserString
                      ((char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k),
                       (char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k + 0x400),
                       &cbNew);
    if (sVar4 == 0) {
      cb = -1 - cb;
      lpbMsg = (byte *)lpb2k;
    }
    else {
      cb = cbNew;
      lpbMsg = (byte *)lpb2k + 0x400;
    }
    local_6 = lpb2k._2_2_;
    sVar4 = _abs(cb);
    cbNew = sVar4 + 0xc;
    LVar9 = SendMessage(hwndMsgDrop,0x407,0,0);
    if ((pMVar2 == (MSGPLR *)0x0) && (iVar3 == 0)) {
      DirtyGame(1);
      lpmpCur = LpAlloc(cbNew,htPlrMsg);
      uVar6 = (undefined2)((ulong)lpmpCur >> 0x10);
      *(undefined2 *)&lpmpCur->lpmsgplrNext = 0;
      *(undefined2 *)((int)&((MSGPLR *)lpmpCur)->lpmsgplrNext + 2) = 0;
      vcmsgplrOut = vcmsgplrOut + 1;
      ((MSGPLR *)lpmpCur)->iInRe = iMsgCur;
    }
    else {
      if (((cb != pMVar2->cLen) || (pMVar2->iPlrTo != (int)LVar9)) ||
         (sVar4 = __fmemcmp((MSGPLR *)CONCAT22(iVar3,pMVar2 + 1),
                                    (byte *)CONCAT22(local_6,lpbMsg),cb), sVar4 != 0)) {
        DirtyGame(1);
      }
      lpmpCur = LpReAlloc((MSGPLR *)CONCAT22(iVar3,pMVar2),cbNew,htPlrMsg);
    }
    *(MSGPLR **)&lpmpPrev->lpmsgplrNext = (MSGPLR *)lpmpCur;
    *(undefined2 *)((int)&pMVar7->lpmsgplrNext + 2) = lpmpCur._2_2_;
    ((MSGPLR *)lpmpCur)->iPlrFrom = idPlayer;
    ((MSGPLR *)lpmpCur)->iPlrTo = (int)LVar9;
    ((MSGPLR *)lpmpCur)->cLen = cb;
    uVar5 = _abs(cb);
    __fmemmove((MSGPLR *)CONCAT22(lpmpCur._2_2_,(MSGPLR *)lpmpCur + 1),
                       (byte *)CONCAT22(local_6,lpbMsg),uVar5);
    iMsgSendCur = iMsgSendCur + dInc;
    if (iMsgSendCur < 0) {
      iMsgSendCur = 0;
    }
    sVar4 = 1;
  }
  return sVar4;
}



// ======================================================================
// Function: PszGetCompressedMessage
// Address: 1030:9eb8
// Segment: MEMORY_MSG
// ======================================================================


char * PszGetCompressedMessage(MessageId idm)

{
  int iVar1;
  byte *pbVar2;
  bool bVar3;
  short iChunk;
  byte *pch;
  short fHigh;
  char *pszOut;
  short iOffset;
  byte *pchLen;
  short iLen;
  short i;
  short iNibble;
  short iBuild;
  
  iNibble = 0;
  if (idm != (int)iLastMsgGet) {
    pchLen = (byte *)CONCAT22(0x1030,(byte *)((int)&rgrcBuildSpin[1].bottom +
                                             ((int)idm >> 6) * 0x40));
    for (i = 0; i < (int)(idm & idmProductionQueueEmpty); i = i + 1) {
      iNibble = iNibble + (uint)*pchLen;
      pchLen = (byte *)CONCAT22(pchLen._2_2_,(byte *)pchLen + 1);
    }
    pch = (byte *)CONCAT22(0x1030,(byte *)(*(int *)((int)&rgplr[1].zpq1 +
                                                   ((int)idm >> 6) * 2) + (iNibble >> 1)));
    bVar3 = (iNibble & 1U) == 0;
    pszOut = (char *)szLastMsgGet;
    iBuild = 0;
    iLen = (uint)*pchLen;
    while (pbVar2 = pch, iVar1 = iLen + -1, iLen != 0) {
      if (bVar3) {
        i = (int)(uint)*pch >> 4;
      }
      else {
        pch = (byte *)CONCAT22(pch._2_2_,(byte *)pch + 1);
        i = *pbVar2 & 0xf;
      }
      bVar3 = !bVar3;
      iBuild = iBuild + i;
      iLen = iVar1;
      if (i != 0xf) {
        *pszOut = *(char *)((int)&rgplr[1].zpq1 + 0xe + iBuild);
        pszOut = pszOut + 1;
        iBuild = 0;
      }
    }
    *pszOut = '\0';
  }
  return (char *)szLastMsgGet;
}



// ======================================================================
// Function: SetFilteringGroups
// Address: 1030:a018
// Segment: MEMORY_MSG
// ======================================================================


void SetFilteringGroups(short idm,short fSet)

{
  byte bVar1;
  bool bVar2;
  short i;
  
  bVar2 = fSet != 0;
  bVar1 = (byte)idm;
  ((byte *)bitfMsgFiltered)[idm >> 3] =
       ((byte *)bitfMsgFiltered)[idm >> 3] & ~(byte)(1 << (bVar1 & 7)) |
       bVar2 << (bVar1 & 7);
  if ((idm == 0x35) || (idm == 0x36)) {
    ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] =
         ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] & ~(byte)(1 << ((bVar1 ^ 3) & 7))
         | bVar2 << ((bVar1 ^ 3) & 7);
  }
  else if ((idm == 0x37) || (idm == 0x38)) {
    ((byte *)bitfMsgFiltered)[(int)(idm ^ 0xfU) >> 3] =
         ((byte *)bitfMsgFiltered)[(int)(idm ^ 0xfU) >> 3] &
         ~(byte)(1 << ((bVar1 ^ 0x37) & 7)) | bVar2 << ((bVar1 ^ 0x37) & 7);
  }
  else if ((idm == 0x39) || (idm == 0x3a)) {
    ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] =
         ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] & ~(byte)(1 << ((bVar1 ^ 3) & 7))
         | bVar2 << ((bVar1 ^ 3) & 7);
  }
  else if ((idm < 0x2b) || (0x2e < idm)) {
    if ((idm == 0x2f) || (idm == 0x30)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 0x1fU) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 0x1fU) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 0x2f) & 7)) | bVar2 << ((bVar1 ^ 0x2f) & 7);
    }
    else if ((idm == 0x42) || (idm == 0x43)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x44) || (idm == 0x45)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x46) || (idm == 0x47)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x48) || (idm == 0x49)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 0x49) & 7)) | bVar2 << ((bVar1 ^ 0x49) & 7);
    }
    else if ((idm == 0x4a) || (idm == 0x4b)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x4c) || (idm == 0x4d)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm < 0x60) || (100 < idm)) {
      if ((idm < 0x6a) || (0x6e < idm)) {
        if ((idm == 0x79) || (idm == 0x7a)) {
          ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] =
               ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] &
               ~(byte)(1 << ((bVar1 ^ 3) & 7)) | bVar2 << ((bVar1 ^ 3) & 7);
        }
        else if ((0x90 < idm) && (idm < 0xa9)) {
          for (i = 0x91; i < 0xa9; i = i + 1) {
            ((byte *)bitfMsgFiltered)[i >> 3] =
                 ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
                 bVar2 << ((byte)i & 7);
          }
        }
      }
      else {
        for (i = 0x6a; i < 0x6f; i = i + 1) {
          ((byte *)bitfMsgFiltered)[i >> 3] =
               ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
               bVar2 << ((byte)i & 7);
        }
      }
    }
    else {
      for (i = 0x60; i < 0x65; i = i + 1) {
        ((byte *)bitfMsgFiltered)[i >> 3] =
             ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
             bVar2 << ((byte)i & 7);
      }
    }
  }
  else {
    for (i = 0x2b; i < 0x2f; i = i + 1) {
      ((byte *)bitfMsgFiltered)[i >> 3] =
           ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
           bVar2 << ((byte)i & 7);
    }
  }
  return;
}



