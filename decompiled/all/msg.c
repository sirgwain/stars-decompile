// Decompiled code from stars.exe
// Generated by Ghidra - ExportAllDecompiled.py
// Grouped by nb09_ghidra_globals.json segmap.segname
// 

// ======================================================================
// Function: MessageWndProc
// Address: 1030:5c92
// Segment: MEMORY_MSG
// ======================================================================


/* WARNING: Variable defined which should be unmapped: lpmsgplr */
/* WARNING: Variable defined which should be unmapped: rc_3 */

long MessageWndProc(HWND hwnd,WMType message,ushort wParam,long lParam)

{
  byte bVar1;
  POINT pt;
  POINT pt_00;
  MSGPLR *pMVar2;
  THING *pTVar3;
  long lVar4;
  char *pcVar5;
  short sVar6;
  HWND HVar7;
  int iVar8;
  int iVar9;
  short sVar10;
  ushort uVar11;
  short sVar12;
  uint uVar13;
  MSGPLR *pMVar14;
  undefined2 unaff_SI;
  undefined2 unaff_DI;
  char *unaff_SS;
  bool bVar15;
  ulong uVar16;
  DWORD DVar17;
  LRESULT LVar18;
  char *pcVar19;
  undefined1 *puVar20;
  undefined2 uVar21;
  HDC HVar22;
  MSGPLR *lpmsgplr;
  RECT rc_3;
  char szT [32];
  short iMode;
  short cch;
  short dx_2;
  RECT rcActual;
  undefined1 auStack_3e [8];
  int iStack_36;
  long lSerial;
  short fRet;
  void *lpProc;
  undefined2 auStack_2a [16];
  char *psz;
  short i;
  HDC hdc;
  
  if (message == WM_CREATE) {
    for (i = 0; i < 4; i = i + 1) {
      hwndMessage = hwnd;
      puVar20 = (undefined1 *)&DAT_1120_1120;
      pcVar19 = (char *)s_BUTTON_1120_0b14;
      pcVar5 = PszGetCompressedString(i + idsPrev2);
      if (i == 3) {
        sVar6 = 0x32;
      }
      else {
        sVar6 = 0x2c;
      }
      HVar7 = CreateWindow((LPCSTR)CONCAT22(puVar20,pcVar19),
                           (LPCSTR)CONCAT22((undefined1 *)&DAT_1120_1120,pcVar5),0x40000000,100,100,
                           sVar6,(dyArial8 * 3 >> 1) + -1,hwnd,0,hInst,
                           (void *)0x0);
      ((ushort *)rghwndMsgBtn)[i] = HVar7;
      SendMessage(((ushort *)rghwndMsgBtn)[i],0x30,rghfontArial8[1],0);
    }
    hwndMsgDrop =
         CreateWindow(s_COMBOBOX_1120_0b21,(LPCSTR)0x11200b1b,0x40200003,100,100,200,0x50,hwnd,0,
                      hInst,(void *)0x0);
    SendMessage(hwndMsgDrop,0x30,rghfontArial8[1],0);
    hwndMsgEdit =
         CreateWindow((LPCSTR)0x11200b2a,(LPCSTR)0x0,0x40800044,100,100,200,0x32,hwnd,0,
                      hInst,(void *)0x0);
    SendMessage(hwndMsgEdit,0x415,0x3c8,0);
    SendMessage(hwndMsgEdit,0x30,rghfontArial8[1],0);
    hwndMsgScroll =
         CreateWindow((LPCSTR)0x11200b2f,(LPCSTR)0x0,0x40a00844,100,100,200,0x32,hwnd,0,
                      hInst,(void *)0x0);
    rc_3.top = hwnd;
    rc_3.left = 0x14f8;
    SetMsgTitle(hwnd);
    rc_3.top = hwndMsgDrop;
    rc_3.left = 0x403;
    pcVar5 = PszGetCompressedString(idsEverybody);
    SendMessage(rc_3.top,rc_3.left,0,(LPARAM)CONCAT22((undefined1 *)&DAT_1120_1120,pcVar5));
    for (i = 0; i < game.cPlayer; i = i + 1) {
      rc_3.top = 0;
      rc_3.left = 0;
      psz = PszPlayerName(i,1,1,1,0,(PLAYER *)0x0);
      rc_3.top = hwndMsgDrop;
      rc_3.left = 0x403;
      SendMessage(hwndMsgDrop,0x403,0,(LPARAM)CONCAT22((undefined1 *)&DAT_1120_1120,psz));
    }
    rc_3.top = hwndMsgDrop;
    rc_3.left = 0x40e;
    SendMessage(hwndMsgDrop,0x40e,0,0);
    return 0;
  }
  if (message == WM_SIZE) {
    lpProc = (void *)CONCAT22(lpProc._2_2_,(void *)lParam);
    uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr);
    lpProc = (void *)CONCAT22((int)uVar16,(void *)lpProc);
    for (i = 0; i < 3; i = i + 1) {
      stack0xffc8 = (MSGPLR *)CONCAT22(iStack_36,(MSGPLR *)(dyArial8 * 2));
      SetWindowPos(((ushort *)rghwndMsgBtn)[i],0,(int)(void *)lpProc + -0x30,
                   (int)&((MSGPLR *)(dyArial8 * 2))->lpmsgplrNext +
                   ((dyArial8 * 3 >> 1) + 2) * i + 3,0,0,0x55);
    }
    SetRect(&rcMsgText.left,4,dyArial8 * 2 + 3,(int)(void *)lpProc + -0x34,
            lpProc._2_2_ + -4);
    SetRect(&rcMsgTitle.left,4,4,(int)(void *)lpProc + -4,dyArial8 * 2 + -4);
    stack0xffc8 = (MSGPLR *)CONCAT22(rcMsgText.left,auStack_3e._6_2_);
    lSerial = CONCAT22(rcMsgText.right,rcMsgText.top);
    fRet = rcMsgText.bottom;
    ExpandRc((RECT *)&stack0xffca,-4,-4);
    SetWindowPos(hwndMsgDrop,0,iStack_36 + 0x1e,(int)lSerial,
                 (lSerial._2_2_ - iStack_36) + -0x54,fRet - (int)lSerial,4);
    SetWindowPos(rghwndMsgBtn[3],0,lSerial._2_2_ + -0x32,(int)lSerial,0,0,5);
    iVar8 = (int)lSerial + dyShipDD + 3;
    lSerial = CONCAT22(lSerial._2_2_,iVar8);
    SetWindowPos(hwndMsgEdit,0,iStack_36,iVar8,lSerial._2_2_ - iStack_36,fRet - iVar8,4);
    goto MSG_Default_9;
  }
  if (message != WM_PAINT) {
    if (message == WM_ERASEBKGND) {
      GetClientRect(hwnd,(undefined2 *)CONCAT22(unaff_SS,(undefined2 *)((int)&lSerial + 2)));
      FillRect(wParam,(undefined2 *)CONCAT22(unaff_SS,(undefined2 *)((int)&lSerial + 2)),
               hbrButtonFace);
      return 1;
    }
    if (message == WM_CTLCOLOR) {
      if ((void *)lParam == (void *)hwndMsgScroll) {
        SetBkColor(wParam,CONCAT22(crButtonFace._2_2_,(undefined2)crButtonFace))
        ;
        return (ulong)hbrButtonFace;
      }
MSG_Default_9:
      LVar18 = DefWindowProc(hwnd,message,wParam,lParam);
      return LVar18;
    }
    if (message == WM_SETCURSOR) {
      fRet = 0;
      GetCursorPos((undefined2 *)CONCAT22(unaff_SS,&lpProc));
      ScreenToClient(hwnd,(undefined2 *)CONCAT22(unaff_SS,&lpProc));
      sVar6 = HtMsgBox((POINT)lpProc);
      if (sVar6 != 0) {
        setcursor(hcurHand);
        return 1;
      }
      goto MSG_Default_9;
    }
    if (message == WM_GETMINMAXINFO) {
      *(int *)((int)(void *)lParam + 0xc) = dxWinFrame * 2 + 0xc6;
      *(int *)((int)(void *)lParam + 0xe) = (dyArial8 * 0xd >> 1) + 0x16;
      goto MSG_Default_9;
    }
    if (message == WM_KEYDOWN) {
      if (wParam == 0x28) {
MSG_NextMsg:
        if (((uint)gd._0_2_ >> 8 & 1) == 0) {
          uVar13 = GetAsyncKeyState(0x10);
          if ((uVar13 & 0xfffe) == 0) {
            i = IMsgNext(0);
          }
          else {
            iMsgCur = cMsg + vcmsgplrIn;
            i = IMsgPrev(0);
          }
          if (i == -1) {
            return 0;
          }
          iMsgCur = i;
        }
        else {
          FFinishPlrMsgEntry(1);
        }
      }
      else {
        if (wParam != 0x26) {
          if (((uint)gd._0_2_ >> 8 & 1) != 0) goto MSG_Default_9;
          if (wParam == 0x24) {
            iMsgCur = -1;
            goto MSG_NextMsg;
          }
          if (wParam != 0x23) {
            return 0;
          }
          iMsgCur = cMsg + vcmsgplrIn;
        }
MSG_PrevMsg:
        if (((uint)gd._0_2_ >> 8 & 1) == 0) {
          uVar13 = GetAsyncKeyState(0x10);
          if ((uVar13 & 0xfffe) == 0) {
            i = IMsgPrev(0);
          }
          else {
            iMsgCur = -1;
            i = IMsgNext(0);
          }
          if (i == -1) {
            if (iMsgCur != cMsg + vcmsgplrIn) {
              return 0;
            }
            iMsgCur = iMsgCur + -1;
          }
          else {
            iMsgCur = i;
          }
        }
        else {
          FFinishPlrMsgEntry(-1);
        }
      }
MSG_SetupNewMsg:
      gd._0_2_ = gd._0_2_ & 0xefff;
      SetMsgTitle(hwnd);
      InvalidateRect(hwnd,&rcMsgText.left,1);
      if (((uint)gd._0_2_ >> 0xb & 1) == 0) {
        return 0;
      }
      tutor.wFlags = tutor.wFlags & 0xfffbU | 4;
      AdvanceTutor();
      return 0;
    }
    if (message == WM_CHAR) {
      if (wParam == 0xd) goto MSG_GotoMsg;
      if (wParam == 0x2b) {
MSG_CheckBox:
        if (iMsgCur < 0) {
          return 0;
        }
        sVar6 = IdmGetMessageN(iMsgCur);
        uVar13 = 1 << ((byte)sVar6 & 7);
        stack0xffc8 = (MSGPLR *)CONCAT22(uVar13,auStack_3e._6_2_);
        bVar15 = (((byte *)bitfMsgFiltered)[sVar6 >> 3] & uVar13) != 0;
        lSerial = (long)CONCAT12(bVar15,sVar6);
        SetFilteringGroups(sVar6,(uint)!bVar15);
        DirtyGame(1);
        if (((uint)gd._0_2_ >> 0xb & 1) != 0) {
          AdvanceTutor();
        }
        InvalidateRect(hwndMessage,(undefined2 *)0x0,1);
        SetMsgTitle(hwnd);
        return 0;
      }
      if (wParam != 0x2d) {
        return 0;
      }
      lpProc = (void *)((ulong)lpProc & 0xffff);
      while (lpProc._2_2_ < 0x31) {
        bVar1 = ((byte *)bitfMsgFiltered)[lpProc._2_2_];
        lpProc = (void *)CONCAT22(lpProc._2_2_,(void *)(uint)bVar1);
        if ((((byte *)bitfMsgSent)[lpProc._2_2_] & bVar1) != 0) break;
        lpProc = (void *)CONCAT22(lpProc._2_2_ + 1,(void *)(uint)bVar1);
      }
      if (lpProc._2_2_ == 0x31) {
        return 0;
      }
    }
    else {
      if (message == WM_COMMAND) {
        uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr);
        if ((int)uVar16 == 0) {
          SetFocus(hwndFrame);
        }
        if (((void *)lParam == (void *)rghwndMsgBtn[0]) &&
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 == 0)) goto MSG_PrevMsg;
        if (((void *)lParam == (void *)rghwndMsgBtn[2]) &&
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 == 0)) goto MSG_NextMsg;
        if (((void *)lParam == (void *)rghwndMsgBtn[3]) &&
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 == 0)) {
          FFinishPlrMsgEntry(1000);
          goto MSG_SetupNewMsg;
        }
        if (((void *)lParam != (void *)rghwndMsgBtn[1]) ||
           (uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr),
           (int)uVar16 != 0)) goto MSG_Default_9;
MSG_GotoMsg:
        if ((((uint)gd._0_2_ >> 8 & 1) == 0) && (iMsgCur < cMsg)) {
          switch(mdMsgObj) {
          default:
            break;
          case 1:
            SelectAdjPlanet(0,idMsgObj);
            UpdateWindow(hwndScanner);
            SendMessage(hwndScanner,0x102,0x76,0);
            sVar6 = IdmGetMessageN(iMsgCur);
            lpProc = (void *)CONCAT22(sVar6,(void *)lpProc);
            if (((sVar6 == 0x3e) || (sVar6 == 0x3f)) || ((0xae < sVar6 && (sVar6 < 0xb5)))) {
              if (((uint)gd._0_2_ >> 0xc & 1) == 0) {
                gd._0_2_ = gd._0_2_ & 0xefff | 0x1000;
                SetMsgTitle(hwnd);
              }
              else if ((sel.grobj == grobjPlanet) &&
                      (sel.id == idMsgObj)) {
                ChangeProduction(0);
              }
            }
            break;
          case 2:
            SelectAdjFleet(0,idMsgObj);
            UpdateWindow(hwndScanner);
            SendMessage(hwndScanner,0x102,0x76,0);
            break;
          case 3:
            PostMessage(hwndFrame,0x111,0x7e,0);
            break;
          case 4:
            vpartBrowser.hs.grhst = 1 << ((byte)((uint)idMsgObj >> 8) & 0xf);
            lpProc = (void *)((ulong)CONCAT22(idMsgObj,(void *)lpProc) & 0xffffff);
            vpartBrowser.hs.wFlags =
                 vpartBrowser.hs.wFlags & 0xff00U | lpProc._2_2_;
            FLookupPart((PART *)&vpartBrowser);
            if (hwndBrowser == 0) {
              fBrowserValid = 1;
              PostMessage(hwndFrame,0x111,0x100,0);
            }
            else {
              InvalidateRect(hwndBrowserChild,(undefined2 *)0x0,1);
            }
            break;
          case 5:
            PostMessage(hwndFrame,0x111,0x7d,0);
            break;
          case 6:
            SelectOursAtObject((POINT *)&vptMsg);
            if (((uint)gd._0_2_ >> 0xc & 1) == 0) {
              gd._0_2_ = gd._0_2_ & 0xefff | 0x1000;
              SetMsgTitle(hwnd);
            }
            else {
              BattleVCR(idMsgObj);
            }
            break;
          case 7:
            PostMessage(hwndFrame,0x111,0x7de,0);
            break;
          case 8:
            PostMessage(hwndFrame,0x111,0x5f,0);
            break;
          case 9:
            szWork[200] = '\x02';
            lpProc = MakeProcInstance(MsgDlg,hInst);
            pcVar5 = (char *)hwndTitle;
            if (hwndTitle == 0) {
              pcVar5 = (char *)hwndFrame;
            }
            fRet = DialogBox(0,(LPCSTR)CONCAT22(0x56,pcVar5),(HWND)((ulong)lpProc >> 0x10),
                             (void *)lpProc);
            FreeProcInstance(lpProc);
            if (fRet != 0) {
              sVar6 = FValidSerialNo((char *)szWork,&lSerial);
              if (sVar6 == 0) {
                if (((int)vSerialNumber == 0) && (vSerialNumber._2_2_ == 0)) {
                  _memcpy((byte *)vrgbMachineConfig,
                                  (undefined *)&vrgbEnvCur,0xb);
                }
              }
              else {
                vSerialNumber._0_2_ = (int)lSerial;
                vSerialNumber._2_2_ = lSerial._2_2_;
                _memcpy((byte *)vrgbMachineConfig,
                                (undefined *)&vrgbEnvCur,0xb);
              }
            }
            break;
          case 10:
            lpProc = LpthFromId(vptMsg.x);
            iVar8 = (int)((ulong)lpProc >> 0x10);
            pTVar3 = (THING *)lpProc;
            if ((pTVar3 != (THING *)0x0) || (iVar8 != 0)) {
              auStack_3e._0_2_ = (&pTVar3->pt)->x;
              auStack_3e._2_2_ = (pTVar3->pt).y;
              auStack_3e._4_2_ = grobjThing;
              ChangeScanSel((SCAN *)auStack_3e,0);
              pt.y = auStack_3e._2_2_;
              pt.x = auStack_3e._0_2_;
              CtrPointScan(pt,1);
            }
            break;
          case 0xb:
            if ((hwndReportDlg == 0) || (vprptCur != (RPT *)&vrptBattle)) {
              PostMessage(hwndFrame,0x111,0x901,0);
            }
          }
          if (((uint)gd._0_2_ >> 0xb & 1) == 0) {
            return 0;
          }
          tutor.wFlags = tutor.wFlags & 0xfffbU | 4;
          AdvanceTutor();
          return 0;
        }
MSG_ToggleMsgMode:
        if (((uint)gd._0_2_ >> 8 & 1) == 0) {
          if (iMsgCur < cMsg) {
            viInRe = 0;
          }
          else {
            stack0xffc8 = (MSGPLR *)CONCAT22(vlpmsgplrIn._2_2_,(MSGPLR *)vlpmsgplrIn);
            i = iMsgCur - cMsg;
            while( true ) {
              pMVar14 = (MSGPLR *)stack0xffc8;
              uVar21 = (undefined2)((ulong)stack0xffc8 >> 0x10);
              if (i == 0) break;
                    /* WARNING: Load size is inaccurate */
              stack0xffc8 = (MSGPLR *)
                            CONCAT22(*(undefined2 *)((int)&pMVar14->lpmsgplrNext + 2),
                                     stack0xffc8->lpmsgplrNext);
              i = i + -1;
            }
            lSerial = CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
            iMsgSendCur = 0;
            while( true ) {
              if ((((int)lSerial == 0) && (lSerial._2_2_ == 0)) ||
                 ((*(int *)((int)lSerial + 6) + -1 == pMVar14->iPlrFrom &&
                  (*(int *)((int)lSerial + 8) == iMsgCur)))) break;
              lSerial = CONCAT22(*(undefined2 *)((int)lSerial + 2),*(undefined2 *)lSerial);
              iMsgSendCur = iMsgSendCur + 1;
            }
            viInRe = pMVar14->iPlrFrom + 1;
            i = -1;
          }
        }
        else {
          FFinishPlrMsgEntry(0);
        }
        bVar15 = ((uint)gd._0_2_ >> 8 & 1) == 0;
        lSerial = (long)CONCAT12(bVar15,(int)lSerial);
        lVar4 = lSerial;
        lSerial._2_2_ = (uint)bVar15;
        gd._0_2_ = gd._0_2_ & 0xfeff | lSerial._2_2_ << 8;
        lSerial = lVar4;
        InvalidateRect(hwndMessage,(undefined2 *)0x0,1);
        SetMsgTitle(hwnd);
        SetFocus(hwndMsgEdit);
        return 0;
      }
      if ((message != WM_LBUTTONDOWN) && (message != WM_LBUTTONDBLCLK)) goto MSG_Default_9;
      lpProc = (void *)CONCAT22(lpProc._2_2_,(void *)lParam);
      uVar16 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),(ushort)(MSGPLR *)lpmsgplr);
      lpProc = (void *)CONCAT22((short)uVar16,(void *)lpProc);
      pt_00.y = (short)uVar16;
      pt_00.x = (short)(void *)lpProc;
      fRet = HtMsgBox(pt_00);
      if (fRet == 1) goto MSG_CheckBox;
      if (fRet != 2) {
        if (fRet != 3) {
          return 0;
        }
        goto MSG_ToggleMsgMode;
      }
    }
    fViewFilteredMsg = (short)(fViewFilteredMsg == 0);
    if (-1 < iMsgCur) {
      sVar6 = IdmGetMessageN(iMsgCur);
      lSerial = CONCAT22(1 << ((byte)sVar6 & 7),(int)lSerial);
      sVar6 = IdmGetMessageN(iMsgCur);
      if ((uint)((((byte *)bitfMsgFiltered)[sVar6 >> 3] & lSerial._2_2_) != 0) ==
          fViewFilteredMsg) goto LAB_1030_626c;
    }
    i = IMsgNext(fViewFilteredMsg);
    if (i == -1) {
      i = IMsgPrev(fViewFilteredMsg);
    }
    iMsgCur = i;
LAB_1030_626c:
    InvalidateRect(hwndMessage,(undefined2 *)0x0,1);
    SetMsgTitle(hwnd);
    return 0;
  }
  hdc = BeginPaint(hwnd,(undefined2 *)CONCAT22(unaff_SS,auStack_2a));
  _Draw3dFrame();
  lSerial = SetTextColor(hdc,CONCAT22(crButtonText._2_2_,
                                      (undefined2)crButtonText));
  auStack_3e._2_4_ =
       SetBkColor(hdc,CONCAT22(crButtonFace._2_2_,(undefined2)crButtonFace));
  cch = _strlen((char *)szMsgTitle);
  iStack_36 = (rcMsgTitle.right - rcMsgTitle.left) + -0x30;
  for (; 0 < cch; cch = cch + -1) {
    DVar17 = GetTextExtent(hdc,szMsgTitle,cch);
    if ((int)DVar17 <= iStack_36) break;
  }
  RcCtrTextOut(hdc,(RECT *)&rcMsgTitle,(char *)szMsgTitle,cch);
  DecorateMsgTitleBar(hdc,(RECT *)&rcMsgTitle);
  rc_3.left = rcMsgText.left;
  rc_3.top = rcMsgText.top;
  rc_3.right = rcMsgText.right;
  rc_3.bottom = rcMsgText.bottom;
  iVar8 = rcMsgText.right - rcMsgText.left;
  auStack_3e._6_2_ = rcMsgText.bottom - rcMsgText.top;
  fRet = SelectObject(hdc,hbrButtonShadow);
  PatBlt(hdc,rc_3.left,rc_3.top,iVar8,1,0xf00021);
  PatBlt(hdc,rc_3.left,rc_3.top,1,auStack_3e._6_2_,0xf00021);
  SelectObject(hdc,hbrButtonHilite);
  PatBlt(hdc,rc_3.left,rc_3.bottom + -1,iVar8,1,0xf00021);
  PatBlt(hdc,rc_3.right + -1,rc_3.top,1,auStack_3e._6_2_,0xf00021);
  SelectObject(hdc,fRet);
  ExpandRc(&rc_3,-4,-4);
  if (((uint)gd._0_2_ >> 8 & 1) != 0) {
    sVar6 = SetBkMode(hdc,1);
    SetTextColor(hdc,CONCAT22(crButtonText._2_2_,(undefined2)crButtonText));
    sVar12 = CchGetString(idsTo3,szT);
    RightTextOut(hdc,rc_3.left + 0x1a,rc_3.top,szT,sVar12,0);
    SetBkMode(hdc,sVar6);
    goto LAB_1030_6a4b;
  }
  if (iMsgCur < cMsg) {
    auStack_3e._0_2_ = IdmGetMessageN(iMsgCur);
    if ((iMsgCur < 0) && (0 < cMsg)) {
      pcVar5 = PszGetCompressedString(idsMessagesHaveSentYearFilteredIfWant);
      lpProc = (void *)CONCAT22((undefined1 *)&DAT_1120_1120,pcVar5);
    }
    else if ((iMsgCur < 0) ||
            ((((uint)((byte *)bitfMsgFiltered)[(int)auStack_3e._0_2_ >> 3] &
              1 << ((byte)auStack_3e._0_2_ & 7)) == 0 || (fViewFilteredMsg != 0)))) {
      pcVar5 = PszGetMessageN(iMsgCur);
      lpProc = (void *)CONCAT22((undefined1 *)&DAT_1120_1120,pcVar5);
    }
    else {
      pcVar5 = PszGetCompressedString(idsMessageTypeHasFilteredWillShownDefault);
      lpProc = (void *)CONCAT22((undefined1 *)&DAT_1120_1120,pcVar5);
    }
  }
  else {
    lpmsgplr._0_2_ = (MSGPLR *)vlpmsgplrIn;
    lpmsgplr._2_2_ = vlpmsgplrIn._2_2_;
    for (i = cMsg; i < iMsgCur; i = i + 1) {
      pMVar2 = (MSGPLR *)CONCAT22(lpmsgplr._2_2_,(MSGPLR *)lpmsgplr);
                    /* WARNING: Load size is inaccurate */
      lpmsgplr._2_2_ = *(undefined2 *)((int)&((MSGPLR *)lpmsgplr)->lpmsgplrNext + 2);
      lpmsgplr._0_2_ = pMVar2->lpmsgplrNext;
    }
    CchGetString(idsSCC,szT);
    pcVar5 = PszPlayerName(((MSGPLR *)lpmsgplr)->iPlrFrom,1,1,1,0,(PLAYER *)0x0);
    iVar8 = _WSPRINTF((LPSTR)CONCAT22(pcVar5,unaff_SS),(LPCSTR)CONCAT22(szT,lpb2k._2_2_),
                      (byte *)lpb2k);
    CchGetString(idsSCC2,szT);
    if (((MSGPLR *)lpmsgplr)->iPlrTo == 0) {
      pcVar5 = PszGetCompressedString(idsEverybody);
    }
    else {
      pcVar5 = PszPlayerName(((MSGPLR *)lpmsgplr)->iPlrTo + -1,1,1,1,0,(PLAYER *)0x0);
    }
    iVar9 = _WSPRINTF((LPSTR)CONCAT22(pcVar5,unaff_SS),(LPCSTR)CONCAT22(szT,lpb2k._2_2_),
                      (byte *)lpb2k + iVar8);
    if (((MSGPLR *)lpmsgplr)->cLen < 0) {
      __fstrcpy((char *)CONCAT22(lpb2k._2_2_,
                                         (byte *)lpb2k + iVar8 + iVar9),
                        (char *)CONCAT22(lpmsgplr._2_2_,(MSGPLR *)lpmsgplr + 1));
    }
    else {
      i = 1000;
      FDecompressUserString
                ((char *)CONCAT22(lpmsgplr._2_2_,(MSGPLR *)lpmsgplr + 1),((MSGPLR *)lpmsgplr)->cLen,
                 (char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k + iVar8 + iVar9),&i)
      ;
    }
    lpProc = (void *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k);
  }
  SetTextColor(hdc,0xffffff);
  sVar6 = SetBkMode(hdc,1);
  if ((iMsgCur < 0) && (0 < cMsg)) {
LAB_1030_68c6:
    sVar12 = CchGetString(idsFiltered,(char *)szWork);
    DiaganolTextOut(hdc,&rc_3,(char *)szWork,sVar12);
    pcVar5 = PszGetMessageN(iMsgCur);
    lpProc = (void *)CONCAT22((undefined1 *)&DAT_1120_1120,pcVar5);
  }
  else if ((-1 < iMsgCur) && (iMsgCur < cMsg)) {
    sVar12 = IdmGetMessageN(iMsgCur);
    sVar10 = IdmGetMessageN(iMsgCur);
    if (((uint)((byte *)bitfMsgFiltered)[sVar10 >> 3] & 1 << ((byte)sVar12 & 7)) != 0)
    goto LAB_1030_68c6;
  }
  SetTextColor(hdc,CONCAT22(crButtonText._2_2_,(undefined2)crButtonText));
  rcActual.left = rc_3.left;
  rcActual.top = rc_3.top;
  rcActual.right = rc_3.right;
  rcActual.bottom = rc_3.bottom;
  pcVar5 = (void *)lpProc;
  uVar21 = lpProc._2_2_;
  HVar22 = hdc;
  uVar11 = __fstrlen(lpProc);
  DRAWTEXT(HVar22,(LPCSTR)CONCAT22(uVar21,pcVar5),uVar11,(undefined2 *)CONCAT22(unaff_SS,&rcActual),
           0xc10);
  if ((rc_3.bottom < rcActual.bottom) || (rc_3.right < rcActual.right)) {
    SetWindowText(hwndMsgScroll,lpProc);
    ExpandRc(&rc_3,4,4);
    SetWindowPos(hwndMsgScroll,0,rc_3.left,rc_3.top,rc_3.right - rc_3.left,
                 rc_3.bottom - rc_3.top,0x44);
  }
  else {
    ShowWindow(hwndMsgScroll,0);
    pcVar5 = (void *)lpProc;
    uVar21 = lpProc._2_2_;
    HVar22 = hdc;
    uVar11 = __fstrlen(lpProc);
    DRAWTEXT(HVar22,(LPCSTR)CONCAT22(uVar21,pcVar5),uVar11,(undefined2 *)CONCAT22(unaff_SS,&rc_3),
             0x810);
  }
  SetBkMode(hdc,sVar6);
LAB_1030_6a4b:
  SetTextColor(hdc,lSerial);
  SetBkColor(hdc,auStack_3e._2_4_);
  EndPaint(hwnd,(undefined2 *)CONCAT22(unaff_SS,auStack_2a));
  return 0;
}



// ======================================================================
// Function: SetMsgTitle
// Address: 1030:7218
// Segment: MEMORY_MSG
// ======================================================================


void SetMsgTitle(HWND hwnd)

{
  short sVar1;
  char *pcVar2;
  int iVar3;
  short sVar4;
  char *unaff_SS;
  FLEET *pFVar5;
  ushort uVar6;
  RECT rc;
  MSGPLR *lpmp;
  short sw;
  char szT [80];
  char ch;
  MSGBIG mb;
  short i;
  short cMsgTot;
  
  if (hwnd == 0) {
    return;
  }
  if (fAi != 0) {
    return;
  }
  if (((uint)gd._0_2_ >> 8 & 1) == 0) {
    sVar1 = 0;
  }
  else {
    sVar1 = 5;
  }
  ShowWindow(hwndMsgEdit,sVar1);
  ShowWindow(hwndMsgDrop,sVar1);
  ShowWindow(rghwndMsgBtn[3],sVar1);
  if (((uint)gd._0_2_ >> 8 & 1) != 0) {
    ShowWindow(hwndMsgScroll,0);
  }
  cMsgTot = cMsg + vcmsgplrIn;
  if (((uint)gd._0_2_ >> 8 & 1) == 0) {
    if (iMsgCur < cMsg) {
      if (((uint)gd._0_2_ >> 0xc & 1) == 0) {
        i = idsGoto3;
      }
      else {
        i = idsView;
      }
    }
    else {
      i = idsReply;
    }
  }
  else {
    i = idsDone;
  }
  uVar6 = rghwndMsgBtn[1];
  pcVar2 = PszGetCompressedString(i);
  SetWindowText(uVar6,(LPCSTR)CONCAT22((undefined1 *)&DAT_1120_1120,pcVar2));
  if (((uint)gd._0_2_ >> 8 & 1) != 0) {
    iVar3 = iMsgSendCur + 1;
    pcVar2 = PszGetCompressedString(idsSendMessagesDD);
    _WSPRINTF((LPSTR)CONCAT22(iVar3,(char *)&DAT_1120_1120),
              (LPCSTR)CONCAT22(pcVar2,(char *)&DAT_1120_1120),(char *)szWork);
    rc.left = rcMsgText.left;
    rc.top = rcMsgText.top;
    rc.right = rcMsgText.right;
    rc.bottom = rcMsgText.bottom;
    ExpandRc(&rc,-4,-4);
    SetWindowPos(hwndMsgDrop,0,rc.left + 0x1e,rc.top,(rc.right - rc.left) + -0x54,
                 rc.bottom - rc.top,0x44);
    SetWindowPos(rghwndMsgBtn[3],0,rc.right + -0x32,rc.top,0,0,0x45);
    rc.top = rc.top + dyShipDD + 3;
    SetWindowPos(hwndMsgEdit,0,rc.left,rc.top,rc.right - rc.left,rc.bottom - rc.top,0x44);
    EnableWindow(rghwndMsgBtn[0],(uint)(0 < iMsgSendCur));
    EnableWindow(rghwndMsgBtn[1],1);
    EnableWindow(rghwndMsgBtn[2],1);
    lpmp = (MSGPLR *)CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
    i = iMsgSendCur;
    while( true ) {
      iVar3 = i + -1;
      if (i < 1) break;
                    /* WARNING: Load size is inaccurate */
      lpmp = (MSGPLR *)
             CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
      i = iVar3;
    }
    if (((MSGPLR *)lpmp == (MSGPLR *)0x0) && (lpmp._2_2_ == 0)) {
      i = iVar3;
      SendMessage(hwndMsgDrop,0x40e,viInRe,0);
      SetWindowText(hwndMsgEdit,(LPCSTR)0x11200b34);
    }
    else {
      i = iVar3;
      SendMessage(hwndMsgDrop,0x40e,((MSGPLR *)lpmp)->iPlrTo,0);
      if (((MSGPLR *)lpmp)->cLen < 0) {
        SetWindowText(hwndMsgEdit,(LPCSTR)CONCAT22(lpmp._2_2_,(MSGPLR *)lpmp + 1));
      }
      else {
        i = 1000;
        FDecompressUserString
                  ((char *)CONCAT22(lpmp._2_2_,(MSGPLR *)lpmp + 1),((MSGPLR *)lpmp)->cLen,
                   (char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k),&i);
        SetWindowText(hwndMsgEdit,
                      (LPCSTR)CONCAT22(lpb2k._2_2_,(byte *)lpb2k));
      }
    }
    goto MSG_FinishUp;
  }
  if (cMsgTot == 0) {
    CchGetString(idsYearDCMessagesNone,szT);
    _WSPRINTF((LPSTR)CONCAT22(game.turn + 0x960,unaff_SS),
              (LPCSTR)CONCAT22(szT,(char *)&DAT_1120_1120),(char *)szWork);
  }
  else {
    CchGetString(idsYearDCMessagesDD,szT);
    _WSPRINTF((LPSTR)CONCAT22(game.turn + 0x960,unaff_SS),
              (LPCSTR)CONCAT22(szT,(char *)&DAT_1120_1120),(char *)szWork);
  }
  uVar6 = rghwndMsgBtn[0];
  sVar1 = IMsgPrev(0);
  EnableWindow(uVar6,(uint)(sVar1 != -1));
  uVar6 = rghwndMsgBtn[2];
  sVar1 = IMsgNext(0);
  EnableWindow(uVar6,(uint)(sVar1 != -1));
  if (cMsg <= iMsgCur) {
    EnableWindow(rghwndMsgBtn[1],1);
    goto MSG_FinishUp;
  }
  if (((cMsg != 0) && (iMsgCur < cMsg)) &&
     (sVar1 = FGetNMsgbig(iMsgCur,&mb), sVar1 != 0)) {
    if (mb.wGoto == -1) {
      mdMsgObj = 0;
    }
    else {
      idMsgObj = mb.wGoto & 0x7fff;
      if (mb.wGoto == -2) {
        mdMsgObj = 3;
      }
      else if (mb.wGoto == -3) {
        mdMsgObj = 5;
      }
      else if (mb.wGoto == -4) {
        mdMsgObj = 8;
      }
      else if (mb.wGoto == -5) {
        mdMsgObj = 9;
      }
      else if (mb.wGoto == -6) {
        mdMsgObj = 10;
        vptMsg.x = mb.rgParam[0];
      }
      else if (mb.wGoto == -7) {
        mdMsgObj = 0xb;
      }
      else if ((mb.wGoto & 0xc000U) == 0xc000) {
        mdMsgObj = 4;
      }
      else if ((mb.wGoto & 0x4000U) == 0) {
        if (mb.wGoto < 0) {
          pFVar5 = LpflFromId(idMsgObj);
          if (pFVar5 == (FLEET *)0x0) {
            mdMsgObj = 0;
          }
          else {
            mdMsgObj = 2;
          }
        }
        else {
          mdMsgObj = 1;
        }
      }
      else {
        idMsgObj = mb.wGoto & 0x3fff;
        if (idMsgObj == 0x800) {
          mdMsgObj = 7;
        }
        else {
          mdMsgObj = 6;
          vptMsg.x = mb.rgParam[0];
          vptMsg.y = mb.rgParam[1];
        }
      }
    }
  }
  if (mdMsgObj != 0) {
    if (iMsgCur < 0) {
LAB_1030_77bb:
      mdMsgObj = 0;
    }
    else if (fViewFilteredMsg == 0) {
      sVar1 = IdmGetMessageN(iMsgCur);
      sVar4 = IdmGetMessageN(iMsgCur);
      if (((uint)((byte *)bitfMsgFiltered)[sVar4 >> 3] & 1 << ((byte)sVar1 & 7)) != 0)
      goto LAB_1030_77bb;
    }
  }
  EnableWindow(rghwndMsgBtn[1],(uint)(mdMsgObj != 0));
MSG_FinishUp:
  _strcpy((char *)szMsgTitle,(char *)szWork);
  InvalidateRect(hwndMessage,&rcMsgTitle.left,1);
  return;
}



// ======================================================================
// Function: IMsgNext
// Address: 1030:7808
// Segment: MEMORY_MSG
// ======================================================================


short IMsgNext(short fFilteredOnly)

{
  short sVar1;
  short idm;
  short i;
  
  i = iMsgCur;
  if ((fViewFilteredMsg == 0) || (fFilteredOnly != 0)) {
    do {
      i = i + 1;
      if (cMsg <= i) {
        if (i < cMsg + vcmsgplrIn) {
          return i;
        }
        return -1;
      }
      sVar1 = IdmGetMessageN(i);
    } while ((uint)(((uint)((byte *)bitfMsgFiltered)[sVar1 >> 3] & 1 << ((byte)sVar1 & 7))
                   == 0) == fFilteredOnly);
  }
  else if (iMsgCur < cMsg + vcmsgplrIn + -1) {
    i = iMsgCur + 1;
  }
  else {
    i = -1;
  }
  return i;
}



// ======================================================================
// Function: IMsgPrev
// Address: 1030:78d8
// Segment: MEMORY_MSG
// ======================================================================


short IMsgPrev(short fFilteredOnly)

{
  short sVar1;
  short idm;
  short i;
  
  i = iMsgCur;
  if ((fViewFilteredMsg == 0) || (fFilteredOnly != 0)) {
    if (cMsg < iMsgCur) {
      i = iMsgCur + -1;
    }
    else {
      do {
        i = i + -1;
        if (i < 0) {
          return -1;
        }
        sVar1 = IdmGetMessageN(i);
      } while ((uint)(((uint)((byte *)bitfMsgFiltered)[sVar1 >> 3] &
                      1 << ((byte)sVar1 & 7)) == 0) == fFilteredOnly);
    }
  }
  else if (iMsgCur < 1) {
    i = -1;
  }
  else {
    i = iMsgCur + -1;
  }
  return i;
}



// ======================================================================
// Function: DecorateMsgTitleBar
// Address: 1030:799c
// Segment: MEMORY_MSG
// ======================================================================


void DecorateMsgTitleBar(HDC hdc,RECT *prc)

{
  HDC HVar1;
  int iVar2;
  short sVar3;
  HGDIOBJ HVar4;
  int iVar5;
  COLORREF CVar6;
  COLORREF CVar7;
  COLORREF crTextSav;
  COLORREF crBkSav;
  short xyStart;
  short dxSrc;
  short yDst;
  short ySrc;
  short idm;
  HDC hdcMem;
  short i;
  short dySrc;
  HBITMAP hbmpSav;
  HBRUSH hbrSav;
  short ySrcMask;
  short xDst;
  
  CVar7 = CONCAT22(crBkSav._2_2_,(undefined2)crBkSav);
  CVar6 = CONCAT22(crTextSav._2_2_,(undefined2)crTextSav);
  HVar1 = CreateCompatibleDC(hdc);
  hbmpSav = SelectObject(HVar1,hbmpMono);
  if (((uint)gd._0_2_ >> 8 & 1) == 0) {
    iVar2 = ((prc->bottom - prc->top) + -0xb) / 2 + prc->top;
    if ((-1 < iMsgCur) && (iMsgCur < cMsg)) {
      sVar3 = IdmGetMessageN(iMsgCur);
      if (((uint)((byte *)bitfMsgFiltered)[sVar3 >> 3] & 1 << ((byte)sVar3 & 7)) == 0) {
        ySrc = 0;
        dxSrc = 0xf;
        dySrc = 0xe;
        ySrcMask = 0x1c;
        yDst = iVar2 + -3;
        xDst = iVar2;
      }
      else {
        ySrc = 0xe;
        dxSrc = 0xe;
        dySrc = 0xc;
        xDst = iVar2 + -1;
        ySrcMask = 0x2a;
        yDst = iVar2;
      }
      CVar6 = SetTextColor(hdc,0);
      CVar7 = SetBkColor(hdc,0xffffff);
      BitBlt(hdc,xDst,yDst,dxSrc,dySrc,HVar1,0,ySrcMask,0x8800c6);
      hbmpSav = SelectObject(HVar1,hbmpMsg);
      BitBlt(hdc,xDst,yDst,dxSrc,dySrc,HVar1,0,ySrc,0xee0086);
    }
    i = 0;
    while (((uint)i < 0x31 &&
           ((((byte *)bitfMsgSent)[i] & ((byte *)bitfMsgFiltered)[i]) == 0))) {
      i = i + 1;
    }
    if (i == 0x31) {
      fViewFilteredMsg = 0;
    }
    else {
      if (fViewFilteredMsg == 0) {
        ySrc = 0x29;
        ySrcMask = 0x45;
      }
      else {
        ySrc = 0x1a;
        ySrcMask = 0x36;
      }
      iVar2 = prc->right - (prc->bottom - prc->top);
      HVar4 = SelectObject(hdc,hbrButtonShadow);
      PatBlt(hdc,iVar2 + -1,prc->top,1,prc->bottom - prc->top,0xf00021);
      SelectObject(hdc,hbrButtonHilite);
      PatBlt(hdc,iVar2,prc->top,1,prc->bottom - prc->top,0xf00021);
      SelectObject(hdc,HVar4);
      iVar2 = ((prc->bottom - prc->top) + -0xf) / 2 + prc->top;
      iVar5 = prc->right - (prc->bottom - iVar2);
      SelectObject(HVar1,hbmpMono);
      BitBlt(hdc,iVar5,iVar2,0xf,0xf,HVar1,0,ySrcMask,0x8800c6);
      SelectObject(HVar1,hbmpMsg);
      BitBlt(hdc,iVar5,iVar2,0xf,0xf,HVar1,0,ySrc,0xee0086);
    }
  }
  SetTextColor(hdc,CVar6);
  SetBkColor(hdc,CVar7);
  if (((uint)game.wCrap >> 2 & 1) == 0) {
    SelectObject(HVar1,hbmpMsg);
    iVar2 = prc->right;
    iVar5 = ((prc->bottom - prc->top) + -7) / 2 + prc->top;
    PatBlt(hdc,iVar2 + -0x2e,iVar5 + -1,0x11,0xb,0x42);
    BitBlt(hdc,iVar2 + -0x2d,iVar5,0xf,9,HVar1,0,0x38,0xcc0020);
  }
  SelectObject(HVar1,hbmpSav);
  DeleteDC(HVar1);
  return;
}



// ======================================================================
// Function: HtMsgBox
// Address: 1030:7d8c
// Segment: MEMORY_MSG
// ======================================================================


short HtMsgBox(POINT pt)

{
  BOOL BVar1;
  short i;
  
  BVar1 = PtInRect((undefined2 *)CONCAT22((RECT *)&rcMsgTitle,pt.y),pt.x);
  if (BVar1 != 0) {
    if ((((pt.x < (rcMsgTitle.bottom - rcMsgTitle.top) +
                  rcMsgTitle.left) && (-1 < iMsgCur)) &&
        (iMsgCur < cMsg)) && (((uint)gd._0_2_ >> 8 & 1) == 0)) {
      return 1;
    }
    if ((pt.x < rcMsgTitle.right -
                (rcMsgTitle.bottom - rcMsgTitle.top)) ||
       (((uint)gd._0_2_ >> 8 & 1) != 0)) {
      if ((((uint)game.wCrap >> 2 & 1) == 0) &&
         ((rcMsgTitle.right - (rcMsgTitle.bottom - rcMsgTitle.top)) +
          -0x18 <= pt.x)) {
        return 3;
      }
    }
    else {
      i = 0;
      while (((uint)i < 0x31 &&
             ((((byte *)bitfMsgSent)[i] & ((byte *)bitfMsgFiltered)[i]) == 0)))
      {
        i = i + 1;
      }
      if (i != 0x31) {
        return 2;
      }
    }
  }
  return 0;
}



// ======================================================================
// Function: FSendPlrMsg2
// Address: 1030:7eaa
// Segment: MEMORY_MSG
// ======================================================================


short FSendPlrMsg2(short iPlr,MessageId iMsg,short iObj,short p1,short p2)

{
  short sVar1;
  
  sVar1 = FSendPlrMsg(iPlr,iMsg,iObj,p1,p2,0,0,0,0,0);
  return sVar1;
}



// ======================================================================
// Function: FSendPlrMsg
// Address: 1030:7ee8
// Segment: MEMORY_MSG
// ======================================================================


short FSendPlrMsg(short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,short p5,
                short p6,short p7)

{
  ushort uVar1;
  uint uVar2;
  undefined2 unaff_SS;
  byte *lpb;
  short cbMsg;
  byte rgbWork [40];
  
  uVar1 = PackageUpMsg(rgbWork,iPlr,iMsg,iObj,p1,p2,p3,p4,p5,p6,p7);
  if ((int)uVar1 < 1) {
    uVar2 = (uint)(uVar1 == 0);
  }
  else {
    __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                        (void *)((int)(short *)lpMsg + imemMsgCur)),
                       (byte *)CONCAT22(unaff_SS,rgbWork),uVar1);
    imemMsgCur = imemMsgCur + uVar1;
    cMsg = cMsg + 1;
    uVar2 = 1;
  }
  return uVar2;
}



// ======================================================================
// Function: FSendPrependedPlrMsg
// Address: 1030:7f80
// Segment: MEMORY_MSG
// ======================================================================


short FSendPrependedPlrMsg
          (short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,short p5,
          short p6,short p7)

{
  ushort uVar1;
  uint uVar2;
  undefined2 unaff_SS;
  short cbMsg;
  byte rgbWork [40];
  
  uVar1 = PackageUpMsg(rgbWork,iPlr,iMsg,iObj,p1,p2,p3,p4,p5,p6,p7);
  if ((int)uVar1 < 1) {
    uVar2 = (uint)(uVar1 == 0);
  }
  else {
    __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                        (void *)((int)(short *)lpMsg + uVar1)),
                       (short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),imemMsgCur
                      );
    __fmemmove((short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),
                       (byte *)CONCAT22(unaff_SS,rgbWork),uVar1);
    imemMsgCur = imemMsgCur + uVar1;
    cMsg = cMsg + 1;
    uVar2 = 1;
  }
  return uVar2;
}



// ======================================================================
// Function: PackageUpMsg
// Address: 1030:802a
// Segment: MEMORY_MSG
// ======================================================================


short PackageUpMsg(byte *pb,short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,
                 short p5,short p6,short p7)

{
  byte *pbVar1;
  uint uVar2;
  short sVar3;
  byte *lpbBase;
  byte *lpb;
  MSGTURN *lpmt;
  ushort grbit;
  short i;
  short *pi;
  
  if (iPlr == -1) {
    sVar3 = 0;
  }
  else if (((((*(uint *)((int)&rgplr[0].wMdPlr + iPlr * 0xc0) >> 9 & 1) == 0) ||
            (*(uint *)((int)&rgplr[0].wMdPlr + iPlr * 0xc0) >> 0xd == 7)) ||
           (iMsg == idmHasBombedKillingOffEnemyColonists)) ||
          (((iMsg == idmHaveAttackedFirstRateStormTroopersThough ||
            (iMsg == idmColonistsHaveDiedOffLongerControlPlanet)) ||
           (iMsg == idmColonistsHaveJumpedShipLongerControlPlanet)))) {
    if (imemMsgCur + 0x14U < 0xffc9) {
      lpmt = (MSGTURN *)CONCAT22((undefined1 *)&DAT_1120_1120,pb);
      lpmt->field0_0x0 = lpmt->field0_0x0 & 0xf0 | (byte)iPlr & 0xf;
      *(MessageId *)(pb + 1) =
           *(MessageId *)(pb + 1) &
           ~(idmDueExcessiveFleetManeuveringBattleAreaFleets|
            idmTipCanHideUnimportantMessagesClickingCheckmark) |
           iMsg & (idmDueExcessiveFleetManeuveringBattleAreaFleets|
                  idmTipCanHideUnimportantMessagesClickingCheckmark);
      *(uint *)(pb + 1) = *(uint *)(pb + 1) & 0x1ff;
      *(short *)(pb + 3) = iObj;
      lpb = (byte *)CONCAT22((undefined1 *)&DAT_1120_1120,pb + 5);
      grbit = 1;
      pi = &p1;
      for (i = 0; i < ((char *)rgcMsgArgs)[iMsg]; i = i + 1) {
        if ((*pi & 0xff00U) == 0) {
          *lpb = (byte)*pi;
          pbVar1 = (byte *)lpb + 1;
        }
        else {
          uVar2 = *(uint *)(pb + 1);
          *(uint *)(pb + 1) = *(uint *)(pb + 1) & 0x1ff;
          *(uint *)(pb + 1) = *(uint *)(pb + 1) | grbit << 9 | uVar2 & 0xfe00;
          *(short *)lpb = *pi;
          pbVar1 = (byte *)lpb + 2;
        }
        lpb = (byte *)CONCAT22(lpb._2_2_,pbVar1);
        pi = pi + 1;
        grbit = grbit << 1;
      }
      lpmt->field0_0x0 = lpmt->field0_0x0 & 0xf | ((char)lpb - (char)(pb + 5)) * '\x10';
      sVar3 = (int)(byte *)lpb - (int)pb;
    }
    else {
      sVar3 = -1;
    }
  }
  else {
    sVar3 = 0;
  }
  return sVar3;
}



// ======================================================================
// Function: FSendPlrMsg2XGen
// Address: 1030:823a
// Segment: MEMORY_MSG
// ======================================================================


short FSendPlrMsg2XGen(short fPrepend,MessageId iMsg,short iObj,short p1,short p2)

{
  short sVar1;
  ushort uVar2;
  undefined2 unaff_SS;
  MSGHDR *pmsghdr;
  ushort cSize;
  byte *pb;
  ushort grbit;
  short i;
  short *pi;
  byte rgb [64];
  
  if (imemMsgCur + 0x14U < 0xffc9) {
    rgb._0_2_ = iMsg & (idmDueExcessiveFleetManeuveringBattleAreaFleets|
                       idmTipCanHideUnimportantMessagesClickingCheckmark);
    ((byte *)bitfMsgSent)[(int)iMsg >> 3] =
         ((byte *)bitfMsgSent)[(int)iMsg >> 3] & ~(byte)(1 << ((byte)iMsg & 7)) |
         (byte)(1 << ((byte)iMsg & 7));
    rgb._2_2_ = iObj;
    pb = rgb + 4;
    grbit = 1;
    pi = &p1;
    for (i = 0; i < ((char *)rgcMsgArgs)[iMsg]; i = i + 1) {
      if ((*pi & 0xff00U) == 0) {
        *pb = (byte)*pi;
        pb = pb + 1;
      }
      else {
        rgb._0_2_ = rgb._0_2_ & 0x1ff | grbit << 9 | rgb._0_2_ & 0xfe00;
        *(short *)pb = *pi;
        pb = pb + 2;
      }
      pi = pi + 1;
      grbit = grbit << 1;
    }
    uVar2 = (int)pb - (int)rgb;
    if (fPrepend == 0) {
      __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                          (void *)((int)(short *)lpMsg + imemMsgCur)),
                         (byte *)CONCAT22(unaff_SS,rgb),uVar2);
    }
    else {
      __fmemmove((void *)CONCAT22(lpMsg._2_2_,
                                          (void *)((int)(short *)lpMsg + uVar2)),
                         (short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),
                         imemMsgCur);
      __fmemmove((short *)CONCAT22(lpMsg._2_2_,(short *)lpMsg),
                         (byte *)CONCAT22(unaff_SS,rgb),uVar2);
    }
    imemMsgCur = imemMsgCur + uVar2;
    cMsg = cMsg + 1;
    iMsgCur = -1;
    iMsgCur = IMsgNext(0);
    sVar1 = 1;
  }
  else {
    sVar1 = 0;
  }
  return sVar1;
}



// ======================================================================
// Function: IdmGetMessageN
// Address: 1030:8412
// Segment: MEMORY_MSG
// ======================================================================


short IdmGetMessageN(short iMsg)

{
  short sVar1;
  MSGBIG mb;
  
  sVar1 = FGetNMsgbig(iMsg,&mb);
  if (sVar1 == 0) {
    mb.iMsg = -1;
  }
  return mb.iMsg;
}



// ======================================================================
// Function: FGetNMsgbig
// Address: 1030:8444
// Segment: MEMORY_MSG
// ======================================================================


short FGetNMsgbig(short iMsg,MSGBIG *pmb)

{
  char cVar1;
  bool bVar2;
  byte *pbVar3;
  byte *pbVar4;
  short sVar5;
  uint uVar6;
  byte *pbVar7;
  ushort u;
  byte *lpb;
  short i;
  MSGHDR *lpmh;
  short iMax;
  byte *lpbMax;
  
  if ((iMsg < 0) || (cMsg <= iMsg)) {
    sVar5 = 0;
  }
  else {
    lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg);
    pbVar7 = (byte *)((int)(short *)lpMsg + imemMsgCur);
    do {
      pbVar4 = lpb;
      pbVar3 = (byte *)lpb;
      if (pbVar7 <= (byte *)lpb) break;
      u = *(uint *)lpb >> 9;
      lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + 4);
      if (iMsg == 0) {
        pmb->iMsg = *(uint *)pbVar4 & 0x1ff;
        pmb->wGoto = *(short *)(pbVar3 + 2);
      }
      cVar1 = ((char *)rgcMsgArgs)[*(uint *)pbVar4 & 0x1ff];
      for (i = 0; i < cVar1; i = i + 1) {
        if (iMsg == 0) {
          if ((u & 1) == 0) {
            uVar6 = (uint)*lpb;
          }
          else {
            uVar6 = *(uint *)lpb;
          }
          pmb->rgParam[i] = uVar6;
        }
        lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + ((u & 1) == 1) + 1);
        u = u >> 1;
      }
      bVar2 = 0 < iMsg;
      iMsg = iMsg + -1;
    } while (bVar2);
    sVar5 = 1;
  }
  return sVar5;
}



// ======================================================================
// Function: PszGetMessageN
// Address: 1030:8580
// Segment: MEMORY_MSG
// ======================================================================


char * PszGetMessageN(short iMsg)

{
  short sVar1;
  char *pcVar2;
  undefined2 unaff_SS;
  char *psz;
  MSGBIG mb;
  
  sVar1 = FGetNMsgbig(iMsg,&mb);
  if (sVar1 == 0) {
    szMsgBuf[0] = '\0';
    pcVar2 = (char *)szMsgBuf;
  }
  else {
    pcVar2 = PszFormatMessage(mb.iMsg,(short *)CONCAT22(unaff_SS,mb.rgParam));
  }
  return pcVar2;
}



// ======================================================================
// Function: PszFormatString
// Address: 1030:85cc
// Segment: MEMORY_MSG
// ======================================================================


char * PszFormatString(char *pszFormat,short *pParamsReal)

{
  char cVar1;
  short *psVar2;
  short sVar3;
  int iVar4;
  char *pcVar5;
  ushort uVar6;
  uint uVar7;
  undefined2 unaff_SI;
  undefined2 unaff_DI;
  bool bVar8;
  long lVar9;
  long lVar10;
  uint in_stack_0000fe00;
  HullSlotType HStack_1fe;
  uint uStack_1fc;
  SHDEF *lpshdef;
  char *pch;
  ushort w;
  char szBuf [480];
  char *pchT;
  short *pParams;
  short i;
  short c;
  short cOut;
  short iMineral;
  
  lVar10 = CONCAT22(unaff_SI,unaff_DI);
  iMineral = -1;
  pParams = pParamsReal;
  pch = (char *)szMsgBuf;
  do {
    if (*pszFormat == '\0') {
      *pch = '\0';
      return (char *)szMsgBuf;
    }
    if (*pszFormat != '\\') {
      *pch = *pszFormat;
      pch = pch + 1;
      goto LAB_1030_8f4d;
    }
    pszFormat = pszFormat + 1;
    uVar7 = (int)*pszFormat - 0x45;
    if (0x35 < uVar7) {
switchD_1030_8edc_caseD_3:
      *pch = *pszFormat;
      pch = pch + 1;
      goto LAB_1030_8f4d;
    }
    bVar8 = (int)uVar7 < 0;
    psVar2 = (short *)pParams;
    switch(uVar7) {
    case 0:
      pchT = PszCalcEnvVar((uint)*pParams >> 8,*pParams & 0xff);
      break;
    case 1:
      pchT = PszFleetNameFromWord(*pParams);
      break;
    case 2:
      w = *pParams;
      sVar3 = CchGetString(w + idsMineField,pch);
      pch = pch + sVar3;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    default:
      goto switchD_1030_8edc_caseD_3;
    case 4:
      pchT = PszGetCompressedString(*pParams + idsDecreased);
      break;
    case 7:
    case 0x27:
      pchT = PszPlayerName(*pParams & 0xf,(uint)(*pszFormat == 'L'),
                                 (uint)((*pParams & 0x10U) != 0),(uint)((*pParams & 0x20U) != 0),
                                 (int)(*pParams & 0xc0U) >> 6,(PLAYER *)0x0);
      break;
    case 8:
      pchT = (char *)*(undefined2 *)(*pParams * 2 + 0x4f2);
      break;
    case 10:
      w = (uint)*pParams >> 9 & 0xf;
      pchT = PszPlayerName(w,0,0,0,0,(PLAYER *)0x0);
      break;
    case 0xb:
      HStack_1fe = *pParams / 100;
      uStack_1fc = (int)HStack_1fe >> 0xf;
      __aFfcompp();
      if (bVar8) {
        c = _WSPRINTF((LPSTR)CONCAT22(*pParams / 100,(char *)&DAT_1120_1120),
                      (LPCSTR)CONCAT22(PCTDXPCTDPCTPCT,(char *)&DAT_1120_1120),pch);
      }
      else {
        c = _WSPRINTF((LPSTR)CONCAT22(*pParams / 100,(char *)&DAT_1120_1120),
                      (LPCSTR)CONCAT22(PCTDPCTPCT,(char *)&DAT_1120_1120),pch);
      }
      pch = pch + c;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    case 0xe:
      if (*pParams != idPlayer) {
        CchGetString(idsOf2,szBuf);
        pcVar5 = PszPlayerName(*pParams,0,0,0,0,(PLAYER *)0x0);
        _strcat(szBuf,pcVar5);
        pcVar5 = PszGetCompressedString(idsOrigin);
        _strcat(szBuf,pcVar5);
        pchT = szBuf;
        break;
      }
      goto MSG_DoNothing;
    case 0x10:
    case 0x11:
    case 0x31:
      HStack_1fe = *pParams;
      uStack_1fc = 0;
      lVar9 = __aFlshl(lVar10,in_stack_0000fe00);
      lpshdef._0_2_ = (SHDEF *)((HullSlotType)lVar9 | HStack_1fe);
      lpshdef._2_2_ = (uint)((ulong)lVar9 >> 0x10) | uStack_1fc;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 2);
      iVar4 = _WSPRINTF((LPSTR)CONCAT22((SHDEF *)lpshdef,(char *)&DAT_1120_1120),
                        (LPCSTR)CONCAT22(PCTLD,(char *)&DAT_1120_1120),pch);
      pch = pch + iVar4;
      if (*pszFormat != 'v') {
        if (*pszFormat == 'V') {
          iMineral = *pParams;
        }
        pcVar5 = (char *)*(undefined2 *)(iMineral * 2 + 0xb48);
        _strcpy(pch,pcVar5);
        uVar6 = _strlen(pcVar5);
        pch = pch + uVar6;
      }
      goto LAB_1030_8f4d;
    case 0x13:
      goto MSG_DoNothing;
    case 0x15:
      w = *pParams;
      if (w != 0) {
        if ((w - 1 & w) == 0) {
          c = 0;
          for (; (w & 1) == 0; w = w >> 1) {
            c = c + 1;
          }
          pchT = PszPlayerName(c,0,1,1,0,(PLAYER *)0x0);
          break;
        }
        cOut = 0;
        for (i = 0; i < game.cPlayer; i = i + 1) {
          if ((w & 1) != 0) {
            if (0 < cOut) {
              if ((w & 0xfffe) == 0) {
                sVar3 = CchGetString(idsAnd,pch);
                pch = pch + sVar3;
              }
              else {
                pcVar5 = pch + 1;
                *pch = ',';
                pch = pch + 2;
                *pcVar5 = ' ';
              }
            }
            pcVar5 = PszPlayerName(i,0,1,1,0,(PLAYER *)0x0);
            _strcpy(pch,pcVar5);
            uVar6 = _strlen(pcVar5);
            pch = pch + uVar6;
            cOut = cOut + 1;
          }
          w = w >> 1;
        }
        goto MSG_DoNothing;
      }
      goto LAB_1030_8f4d;
    case 0x20:
      pchT = (char *)*(undefined2 *)(*pParams * 2 + 0x47e);
      break;
    case 0x21:
    case 0x23:
    case 0x2d:
    case 0x2f:
    case 0x34:
      _strcpy(pch,(char *)szBase);
      uVar6 = _strlen((char *)szBase);
      pch = pch + uVar6;
      cVar1 = *pszFormat;
      if (cVar1 == 'f') {
        if (idPlayer == -1) {
LAB_1030_86a2:
          if (idPlayer == -1) goto LAB_1030_86d0;
          c = _WSPRINTF((LPSTR)CONCAT22(idPlayer + 1,(char *)&DAT_1120_1120),
                        (LPCSTR)0xb591120,pch);
        }
        else {
          c = _WSPRINTF((LPSTR)CONCAT22(idPlayer + 1,(char *)&DAT_1120_1120),
                        (LPCSTR)0xb541120,pch);
        }
        goto MSG_DoInt;
      }
      if (cVar1 == 'h') {
LAB_1030_86d0:
        _strcat(pch,(char *)0xb5e);
        pch = pch + 4;
      }
      else {
        if (cVar1 == 'r') {
          c = _WSPRINTF((LPSTR)CONCAT22(idPlayer + 1,(char *)&DAT_1120_1120),
                        (LPCSTR)0xb631120,pch);
          goto MSG_DoInt;
        }
        if (cVar1 == 't') goto LAB_1030_86a2;
        if (cVar1 == 'y') {
          _strcat(pch,(char *)0xb68);
          pch = pch + 3;
        }
      }
      goto LAB_1030_8f4d;
    case 0x22:
MSG_LThingName:
      pchT = PszGetThingName(*pParams);
      break;
    case 0x24:
      c = _WSPRINTF((LPSTR)CONCAT22(*pParams,(char *)&DAT_1120_1120),
                    (LPCSTR)CONCAT22(PCTD,(char *)&DAT_1120_1120),pch);
MSG_DoInt:
      pch = pch + c;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    case 0x25:
      pchT = PszGetCompressedString(*pParams + idsEnergy);
      break;
    case 0x26:
      HStack_1fe = *pParams;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      in_stack_0000fe00 = *pParams;
      uStack_1fc = uStack_1fc & 0xff00 | in_stack_0000fe00 & 0xff;
      FLookupPart((PART *)&stack0xfe02);
      __fstrcpy((char *)CONCAT22((undefined1 *)&DAT_1120_1120,pch),
                        (char *)CONCAT22(lpshdef._2_2_,(((SHDEF *)lpshdef)->hul).szClass));
      uVar6 = __fstrlen((char *)CONCAT22(lpshdef._2_2_,(((SHDEF *)lpshdef)->hul).szClass));
      pch = pch + uVar6;
      pParams = (short *)CONCAT22(pParams._2_2_,psVar2 + 2);
      goto LAB_1030_8f4d;
    case 0x28:
      iMineral = *pParams;
      pchT = (char *)*(undefined2 *)(iMineral * 2 + 0x4cc);
      break;
    case 0x29:
      if (*pParams == -2) {
        pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
        goto MSG_LThingName;
      }
      if (*pParams == -1) {
        pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
        goto switchD_1030_8edc_caseD_2a;
      }
      pchT = PszGetLocName(grobjNone,-1,*pParams,((short *)pParams)[1]);
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      break;
    case 0x2a:
switchD_1030_8edc_caseD_2a:
      if ((*pParams & 0x8000U) != 0) goto MSG_DoFleet;
    case 0x2b:
      pchT = PszGetPlanetName(*pParams);
      break;
    case 0x2e:
MSG_DoFleet:
      w = *pParams | 0x8000;
      pchT = PszGetFleetName(w);
      break;
    case 0x30:
      iVar4 = _WSPRINTF((LPSTR)CONCAT22(*pParams,(char *)&DAT_1120_1120),(LPCSTR)0xb6c1120,pch);
      pch = pch + iVar4;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    case 0x32:
      _strcpy(pch,(char *)szWork);
      uVar6 = _strlen((char *)szWork);
      pch = pch + uVar6;
      goto LAB_1030_8f4d;
    case 0x35:
      iVar4 = *pParams >> 5;
      w = *pParams & 0x1f;
      if (w < 0x10) {
        lpshdef._2_2_ = *(uint *)(iVar4 * 4 + 0x100);
        lpshdef._0_2_ = (SHDEF *)(*(int *)(iVar4 * 4 + 0xfe) + w * 0x93);
      }
      else {
        lpshdef._2_2_ = *(uint *)(iVar4 * 4 + 0x14e);
        lpshdef._0_2_ = (SHDEF *)(*(int *)(iVar4 * 4 + 0x14c) + (w - 0x10) * 0x93);
      }
      if (iVar4 == idPlayer) {
        __fstrcpy((char *)CONCAT22((undefined1 *)&DAT_1120_1120,pch),
                          (char *)CONCAT22(lpshdef._2_2_,(((SHDEF *)lpshdef)->hul).szClass));
      }
      else {
        pcVar5 = PszPlayerName(iVar4,0,0,1,0,(PLAYER *)0x0);
        _WSPRINTF((LPSTR)CONCAT22(pcVar5,(char *)&DAT_1120_1120),(LPCSTR)0xb6f1120,pch);
      }
      uVar6 = _strlen(pch);
      pch = pch + uVar6;
      pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
      goto LAB_1030_8f4d;
    }
    _strcpy(pch,pchT);
    uVar6 = _strlen(pchT);
    pch = pch + uVar6;
MSG_DoNothing:
    pParams = (short *)CONCAT22(pParams._2_2_,(short *)pParams + 1);
LAB_1030_8f4d:
    pszFormat = pszFormat + 1;
  } while( true );
}



// ======================================================================
// Function: MsgDlg
// Address: 1030:8f68
// Segment: MEMORY_MSG
// ======================================================================


/* WARNING: Variable defined which should be unmapped: ps */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

short MsgDlg(HWND hwnd,WMType message,ushort wParam,long lParam)

{
  HDC HVar1;
  HWND HVar2;
  short sVar3;
  char *sz;
  undefined2 unaff_SI;
  undefined2 unaff_DI;
  undefined2 unaff_SS;
  ulong uVar4;
  PAINTSTRUCT ps;
  char szT [256];
  short cch;
  RECT rcEdit;
  HDC hdc;
  RECT rc;
  
  if (message == WM_PAINT) {
    HVar1 = BeginPaint(hwnd,(undefined2 *)CONCAT22(unaff_SS,&ps));
    GetClientRect(hwnd,(undefined2 *)CONCAT22(unaff_SS,&rc));
    HVar2 = GetDlgItem(hwnd,0x10c);
    GetWindowRect(HVar2,(undefined2 *)CONCAT22(unaff_SS,&rcEdit));
    ScreenToClient(hwnd,(short *)CONCAT22(unaff_SS,&rcEdit.right));
    rcEdit.left = 8;
    rcEdit.right = rc.right + -8;
    rcEdit.top = rcEdit.bottom + 8;
    rcEdit.bottom = rcEdit.bottom + 0x6c;
    SelectObject(HVar1,rghfontArial8[1]);
    SetBkColor(HVar1,CONCAT22(crButtonFace._2_2_,(undefined2)crButtonFace));
    SetTextColor(HVar1,0);
    sVar3 = CchGetString
                      ((int)szWork[200] + idsPleaseEnterUniqueEightCharacterSerialNumber,
                       szT);
    DRAWTEXT(HVar1,(LPCSTR)CONCAT22(unaff_SS,szT),sVar3,(undefined2 *)CONCAT22(unaff_SS,&rcEdit),
             0x810);
    EndPaint(hwnd,(undefined2 *)CONCAT22(unaff_SS,&ps));
    return 1;
  }
  if (message != WM_ERASEBKGND) {
    if (message == WM_CTLCOLOR) {
      uVar4 = __aFulshr(CONCAT22(unaff_SI,unaff_DI),ps.hdc);
      if ((int)uVar4 == 6) {
        SetBkColor(wParam,CONCAT22(crButtonFace._2_2_,(undefined2)crButtonFace))
        ;
        return hbrButtonFace;
      }
    }
    else {
      if (message == WM_INITDIALOG) {
        rcEdit.bottom = -1;
        szWork[0] = '\0';
        SendDlgItemMessage(hwnd,0x10c,0x415,8,0);
        HVar2 = GetDlgItem(hwnd,0x10c);
        SetWindowText(HVar2,szWork);
        StickyDlgPos(hwnd,(POINT *)&rcEdit.bottom,1);
        return 1;
      }
      if (message == WM_COMMAND) {
        if ((wParam == 1) || (wParam == 2)) {
          if (wParam == 1) {
            GetDlgItemText(hwnd,0x10c,szWork,9);
            sVar3 = FValidSerialNo((char *)szWork,(long *)0x0);
            if (sVar3 == 0) {
              sVar3 = 0x10;
              sz = PszFormatIds(idsSerialNumberHaveEnteredValid,(short *)0x0);
              AlertSz(sz,sVar3);
              HVar2 = GetDlgItem(hwnd,0x10c);
              SetFocus(HVar2);
              return 0;
            }
          }
          EndDialog(hwnd,(uint)(wParam == 1));
          return 1;
        }
        if (wParam == 0x76) {
          WinHelp(hwnd,(LPCSTR)CONCAT22((undefined1 *)&DAT_1120_1120,_szHelpFile),1,0xdbc);
          return 1;
        }
      }
    }
    return 0;
  }
  GetClientRect(hwnd,(undefined2 *)CONCAT22(unaff_SS,&rc));
  FillRect(wParam,(undefined2 *)CONCAT22(unaff_SS,&rc),hbrButtonFace);
  return 1;
}



// ======================================================================
// Function: PszFormatMessage
// Address: 1030:9220
// Segment: MEMORY_MSG
// ======================================================================


char * PszFormatMessage(short idm,short *pParams)

{
  char *pcVar1;
  
  pcVar1 = PszGetCompressedMessage(idm);
  pcVar1 = PszFormatString(pcVar1,pParams);
  return pcVar1;
}



// ======================================================================
// Function: PszFormatIds
// Address: 1030:924c
// Segment: MEMORY_MSG
// ======================================================================


char * PszFormatIds(StringId ids,short *pParams)

{
  char *pcVar1;
  
  pcVar1 = PszGetCompressedString(ids);
  pcVar1 = PszFormatString(pcVar1,pParams);
  return pcVar1;
}



// ======================================================================
// Function: FRemovePlayerMessage
// Address: 1030:9278
// Segment: MEMORY_MSG
// ======================================================================


short FRemovePlayerMessage(short iPlr,MessageId iMsg,short iObj)

{
  byte *pbVar1;
  short cDel;
  byte *lpb;
  byte *lpbMax;
  
  cDel = 0;
  pbVar1 = (byte *)((int)(short *)lpMsg + imemMsgCur);
  for (lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg); (byte *)lpb < pbVar1;
      lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5)) {
    if ((((*lpb & 0xf) == iPlr) &&
        ((*(MessageId *)((byte *)lpb + 1) &
         (idmDueExcessiveFleetManeuveringBattleAreaFleets|
         idmTipCanHideUnimportantMessagesClickingCheckmark)) == iMsg)) &&
       (*(int *)((byte *)lpb + 3) == iObj)) {
      cDel = cDel + 1;
      *(uint *)((byte *)lpb + 1) = *(uint *)((byte *)lpb + 1) & 0xfe00 | 0x1ff;
    }
  }
  return cDel;
}



// ======================================================================
// Function: FFindPlayerMessage
// Address: 1030:932a
// Segment: MEMORY_MSG
// ======================================================================


short FFindPlayerMessage(short iPlr,MessageId iMsg,short iObj)

{
  byte *lpb;
  byte *lpbMax;
  
  lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg);
  while( true ) {
    if ((byte *)((int)(short *)lpMsg + imemMsgCur) <= (byte *)lpb) {
      return 0;
    }
    if ((((*lpb & 0xf) == iPlr) &&
        ((*(MessageId *)((byte *)lpb + 1) &
         (idmDueExcessiveFleetManeuveringBattleAreaFleets|
         idmTipCanHideUnimportantMessagesClickingCheckmark)) == iMsg)) &&
       (*(int *)((byte *)lpb + 3) == iObj)) break;
    lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5);
  }
  return 1;
}



// ======================================================================
// Function: MarkPlanetsPlayerLost
// Address: 1030:93c6
// Segment: MEMORY_MSG
// ======================================================================


void MarkPlanetsPlayerLost(short iPlayer)

{
  uint uVar1;
  byte *pbVar2;
  undefined2 uVar3;
  PLANET *lppl_00;
  byte *lpb;
  ushort w;
  byte *lpbT;
  PLANET *lppl;
  byte *lpbMax;
  
  lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg);
  pbVar2 = (byte *)((int)(short *)lpMsg + imemMsgCur);
  do {
    if (pbVar2 <= (byte *)lpb) {
      return;
    }
    uVar3 = (undefined2)((ulong)lpb >> 0x10);
    if ((*lpb & 0xf) == iPlayer) {
      uVar1 = *(uint *)((byte *)lpb + 1) & 0x1ff;
      if (((uVar1 == 7) || (uVar1 == 0x23)) || (uVar1 == 0x40)) {
        w = *(ushort *)((byte *)lpb + 3);
      }
      else {
        if (uVar1 != 0x8f) goto LAB_1030_95d5;
        lpbT = (byte *)CONCAT22(uVar3,(byte *)lpb + ((*(uint *)((byte *)lpb + 1) >> 9 & 1) == 1) + 6
                               );
        if ((*(uint *)((byte *)lpb + 1) >> 9 & 2) == 0) {
          w = (ushort)*lpbT;
        }
        else {
          w = *(ushort *)lpbT;
        }
      }
      lppl_00 = LpplFromId(w);
      if (lppl_00 != (PLANET *)0x0) {
        MarkPlanet(lppl_00,iPlayer,3);
      }
    }
LAB_1030_95d5:
    lpb = (byte *)CONCAT22(uVar3,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5);
  } while( true );
}



// ======================================================================
// Function: MarkPlayersThatSentMsgs
// Address: 1030:9604
// Segment: MEMORY_MSG
// ======================================================================


void MarkPlayersThatSentMsgs(short iPlayer)

{
  MSGPLR *lpmp;
  
  if (iPlayer != -1) {
    lpmp = (MSGPLR *)CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
    while( true ) {
      if (((MSGPLR *)lpmp == (MSGPLR *)0x0) && (lpmp._2_2_ == 0)) break;
      if (((((MSGPLR *)lpmp)->iPlrTo == 0) && (((MSGPLR *)lpmp)->iPlrFrom != iPlayer)) ||
         ((((MSGPLR *)lpmp)->iPlrTo + -1 == iPlayer &&
          ((*(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) >> 8 & 1)
           == 0)))) {
        *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) =
             *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) & 0xfeff
             | 0x100;
        *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) =
             *(uint *)((int)&rgplr[0].wMdPlr + ((MSGPLR *)lpmp)->iPlrFrom * 0xc0) & 0xfff8
             | 3;
      }
                    /* WARNING: Load size is inaccurate */
      lpmp = (MSGPLR *)
             CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
    }
  }
  return;
}



// ======================================================================
// Function: WritePlayerMessages
// Address: 1030:9702
// Segment: MEMORY_MSG
// ======================================================================


void WritePlayerMessages(short iPlayer)

{
  short sVar1;
  byte *pbVar2;
  undefined2 uVar3;
  undefined2 unaff_SS;
  MSGPLR *pMVar4;
  int iVar5;
  byte *lpb;
  MSGPLR *lpmp;
  short cbMsg;
  byte rgb [1024];
  byte *lpbMax;
  
  cbMsg = 0;
  if (iPlayer != -1) {
    pbVar2 = (byte *)((int)(short *)lpMsg + imemMsgCur);
    for (lpb = (byte *)CONCAT22(lpMsg._2_2_,(short *)lpMsg); (byte *)lpb < pbVar2;
        lpb = (byte *)CONCAT22(uVar3,(byte *)lpb + ((int)(uint)*lpb >> 4) + 5)) {
      if (0x3ff < cbMsg + 0x14) {
        WriteRt(0xc,cbMsg,(byte *)CONCAT22(unaff_SS,rgb));
        cbMsg = 0;
      }
      uVar3 = (undefined2)((ulong)lpb >> 0x10);
      if (((*lpb & 0xf) == iPlayer) && ((*(uint *)((byte *)lpb + 1) & 0x1ff) != 0x1ff)) {
        __fmemmove((byte *)CONCAT22(unaff_SS,rgb + cbMsg),
                           (byte *)CONCAT22(uVar3,(byte *)lpb + 1),((int)(uint)*lpb >> 4) + 4);
        cbMsg = cbMsg + ((int)(uint)*lpb >> 4) + 4;
      }
    }
    if (cbMsg != 0) {
      WriteRt(0xc,cbMsg,(byte *)CONCAT22(unaff_SS,rgb));
    }
    lpmp = (MSGPLR *)CONCAT22(vlpmsgplrOut._2_2_,(MSGPLR *)vlpmsgplrOut);
    while( true ) {
      if (((MSGPLR *)lpmp == (MSGPLR *)0x0) && (lpmp._2_2_ == 0)) break;
      if (((((MSGPLR *)lpmp)->iPlrTo == 0) && (((MSGPLR *)lpmp)->iPlrFrom != iPlayer)) ||
         (((MSGPLR *)lpmp)->iPlrTo + -1 == iPlayer)) {
        pMVar4 = (MSGPLR *)lpmp;
        iVar5 = lpmp._2_2_;
        sVar1 = _abs(((MSGPLR *)lpmp)->cLen);
        WriteRt(0x28,sVar1 + 0xc,(MSGPLR *)CONCAT22(iVar5,pMVar4));
      }
                    /* WARNING: Load size is inaccurate */
      lpmp = (MSGPLR *)
             CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
    }
  }
  return;
}



// ======================================================================
// Function: ResetMessages
// Address: 1030:98d6
// Segment: MEMORY_MSG
// ======================================================================


void ResetMessages(void)

{
  imemMsgCur = 0;
  iMsgCur = -1;
  cMsg = 0;
  iMsgSendCur = 0;
  _memset((byte *)bitfMsgSent,0,0x31);
  _memset((byte *)bitfMsgFiltered,0,0x31);
  vlpmsgplrIn._0_2_ = (MSGPLR *)0x0;
  vlpmsgplrIn._2_2_ = 0;
  vlpmsgplrOut._0_2_ = (MSGPLR *)0x0;
  vlpmsgplrOut._2_2_ = 0;
  vcmsgplrIn = 0;
  vcmsgplrOut = 0;
  return;
}



// ======================================================================
// Function: ReadPlayerMessages
// Address: 1030:994a
// Segment: MEMORY_MSG
// ======================================================================


void ReadPlayerMessages(void)

{
  MSGPLR *pMVar1;
  bool bVar2;
  short *psVar3;
  short sVar4;
  byte *pbVar5;
  undefined2 uVar6;
  void *pvVar7;
  ushort u;
  byte *lpb;
  MSGPLR *lpmp;
  short env [9];
  short i;
  ushort imemMsgT;
  MSGHDR *lpmh;
  short (*penvMemSav) [9];
  short fOOM;
  short iMax;
  byte *lpbMax;
  
  uVar6 = lpMsg._2_2_;
  imemMsgT = 0;
  bVar2 = false;
  lpb._0_2_ = (byte *)((int)(short *)lpMsg + imemMsgCur);
  while ((uint)hdrCur.wFlags >> 10 == 0xc) {
    if (((hdrCur.wFlags & 0x3ffU) != 0) &&
       (imemMsgCur + imemMsgT < -(hdrCur.wFlags & 0x3ffU) - 0x38)) {
      __fmemmove((byte *)CONCAT22(uVar6,(byte *)lpb + imemMsgT),rgbCur,
                         hdrCur.wFlags & 0x3ff);
      imemMsgT = imemMsgT + (hdrCur.wFlags & 0x3ffU);
    }
    ReadRt();
  }
  imemMsgCur = imemMsgCur + imemMsgT;
  pbVar5 = (byte *)lpb + imemMsgT;
  while (psVar3 = penvMem, (byte *)lpb < pbVar5) {
    lpmh = (MSGHDR *)CONCAT22(uVar6,(byte *)lpb);
    ((byte *)bitfMsgSent)[(lpmh->wFlags & 0x1ffU) >> 3] =
         ((byte *)bitfMsgSent)[(lpmh->wFlags & 0x1ffU) >> 3] &
         ~(byte)(1 << ((byte)lpmh->wFlags & 7)) | (byte)(1 << ((byte)lpmh->wFlags & 7));
    cMsg = cMsg + 1;
    u = (uint)lpmh->wFlags >> 9;
    lpb._0_2_ = (byte *)lpb + 4;
    for (i = 0; i < ((char *)rgcMsgArgs)[lpmh->wFlags & 0x1ff]; i = i + 1) {
      lpb._0_2_ = (byte *)lpb + ((u & 1) == 1) + 1;
      u = u >> 1;
    }
  }
  lpmp = (MSGPLR *)&vlpmsgplrIn;
  while( true ) {
    uVar6 = (undefined2)((ulong)lpmp >> 0x10);
    if ((*(int *)&lpmp->lpmsgplrNext == 0) &&
       (*(int *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2) == 0)) break;
                    /* WARNING: Load size is inaccurate */
    lpmp = (MSGPLR *)
           CONCAT22(*(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2),lpmp->lpmsgplrNext);
  }
  penvMem = env;
  sVar4 = __setjmp(env);
  if (sVar4 == 0) goto LAB_1030_9b3a;
  bVar2 = true;
  penvMem = psVar3;
  while( true ) {
    ReadRt();
LAB_1030_9b3a:
    if ((uint)hdrCur.wFlags >> 10 != 0x28) break;
    if (!bVar2) {
      pvVar7 = LpAlloc(hdrCur.wFlags & 0x3ff,htPlrMsg);
      uVar6 = (undefined2)((ulong)lpmp >> 0x10);
      *(void **)&lpmp->lpmsgplrNext = (void *)pvVar7;
      *(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2) = (int)((ulong)pvVar7 >> 0x10);
                    /* WARNING: Load size is inaccurate */
      pMVar1 = lpmp->lpmsgplrNext;
      uVar6 = *(undefined2 *)((int)&((MSGPLR *)lpmp)->lpmsgplrNext + 2);
      lpmp = (MSGPLR *)CONCAT22(uVar6,pMVar1);
      __fmemcpy((MSGPLR *)CONCAT22(uVar6,pMVar1),rgbCur,
                        hdrCur.wFlags & 0x3ff);
      *(undefined2 *)&lpmp->lpmsgplrNext = 0;
      *(undefined2 *)((int)&pMVar1->lpmsgplrNext + 2) = 0;
      vcmsgplrIn = vcmsgplrIn + 1;
    }
  }
  iMsgCur = -1;
  iMsgCur = IMsgNext(0);
  return;
}



// ======================================================================
// Function: FFinishPlrMsgEntry
// Address: 1030:9bd6
// Segment: MEMORY_MSG
// ======================================================================


short FFinishPlrMsgEntry(short dInc)

{
  int iVar1;
  MSGPLR *pMVar2;
  int iVar3;
  short sVar4;
  ushort uVar5;
  undefined2 uVar6;
  MSGPLR *pMVar7;
  undefined2 uVar8;
  LRESULT LVar9;
  short cb;
  MSGPLR *lpmpPrev;
  MSGPLR *lpmpCur;
  short iPlrTo;
  short cbNew;
  short i;
  byte *lpbMsg;
  
  lpmpPrev = (MSGPLR *)&vlpmsgplrOut;
  i = iMsgSendCur;
  while( true ) {
    iVar1 = i + -1;
    pMVar7 = (MSGPLR *)lpmpPrev;
    uVar8 = (undefined2)((ulong)lpmpPrev >> 0x10);
    if (i < 1) break;
                    /* WARNING: Load size is inaccurate */
    lpmpPrev = (MSGPLR *)
               CONCAT22(*(undefined2 *)((int)&pMVar7->lpmsgplrNext + 2),lpmpPrev->lpmsgplrNext);
    i = iVar1;
  }
                    /* WARNING: Load size is inaccurate */
  pMVar2 = lpmpPrev->lpmsgplrNext;
  iVar3 = *(int *)((int)&pMVar7->lpmsgplrNext + 2);
  lpmpCur = (MSGPLR *)CONCAT22(iVar3,pMVar2);
  if (dInc == 1000) {
    cb = 0;
    dInc = 0;
    i = iVar1;
  }
  else {
    i = iVar1;
    cb = GetWindowText(hwndMsgEdit,
                       (LPSTR)CONCAT22(lpb2k._2_2_,(byte *)lpb2k),1000);
  }
  if (cb == 0) {
    if ((pMVar2 != (MSGPLR *)0x0) || (iVar3 != 0)) {
      DirtyGame(1);
      uVar6 = *(undefined2 *)((int)&pMVar2->lpmsgplrNext + 2);
      *(undefined2 *)&lpmpPrev->lpmsgplrNext = *(undefined2 *)&lpmpCur->lpmsgplrNext;
      *(undefined2 *)((int)&pMVar7->lpmsgplrNext + 2) = uVar6;
      FreeLp((MSGPLR *)CONCAT22(iVar3,pMVar2),htPlrMsg);
      vcmsgplrOut = vcmsgplrOut + -1;
      if (0 < iMsgSendCur) {
        iMsgSendCur = iMsgSendCur + -1;
      }
    }
    if ((dInc == -1) && (0 < iMsgSendCur)) {
      iMsgSendCur = iMsgSendCur + -1;
    }
    else if ((dInc == 1) && (iMsgSendCur < vcmsgplrOut)) {
      iMsgSendCur = iMsgSendCur + 1;
    }
    sVar4 = 0;
  }
  else {
    cbNew = cb;
    sVar4 = FCompressUserString
                      ((char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k),
                       (char *)CONCAT22(lpb2k._2_2_,(byte *)lpb2k + 0x400),
                       &cbNew);
    if (sVar4 == 0) {
      cb = -1 - cb;
      lpbMsg._0_2_ = (byte *)lpb2k;
    }
    else {
      cb = cbNew;
      lpbMsg._0_2_ = (byte *)lpb2k + 0x400;
    }
    lpbMsg._2_2_ = lpb2k._2_2_;
    sVar4 = _abs(cb);
    cbNew = sVar4 + 0xc;
    LVar9 = SendMessage(hwndMsgDrop,0x407,0,0);
    if ((pMVar2 == (MSGPLR *)0x0) && (iVar3 == 0)) {
      DirtyGame(1);
      lpmpCur = LpAlloc(cbNew,htPlrMsg);
      uVar6 = (undefined2)((ulong)lpmpCur >> 0x10);
      *(undefined2 *)&lpmpCur->lpmsgplrNext = 0;
      *(undefined2 *)((int)&((MSGPLR *)lpmpCur)->lpmsgplrNext + 2) = 0;
      vcmsgplrOut = vcmsgplrOut + 1;
      ((MSGPLR *)lpmpCur)->iInRe = iMsgCur;
    }
    else {
      if (((cb != pMVar2->cLen) || (pMVar2->iPlrTo != (int)LVar9)) ||
         (sVar4 = __fmemcmp((MSGPLR *)CONCAT22(iVar3,pMVar2 + 1),
                                    (byte *)CONCAT22(lpbMsg._2_2_,(byte *)lpbMsg),cb), sVar4 != 0))
      {
        DirtyGame(1);
      }
      lpmpCur = LpReAlloc((MSGPLR *)CONCAT22(iVar3,pMVar2),cbNew,htPlrMsg);
    }
    *(MSGPLR **)&lpmpPrev->lpmsgplrNext = (MSGPLR *)lpmpCur;
    *(undefined2 *)((int)&pMVar7->lpmsgplrNext + 2) = lpmpCur._2_2_;
    ((MSGPLR *)lpmpCur)->iPlrFrom = idPlayer;
    ((MSGPLR *)lpmpCur)->iPlrTo = (int)LVar9;
    ((MSGPLR *)lpmpCur)->cLen = cb;
    uVar5 = _abs(cb);
    __fmemmove((MSGPLR *)CONCAT22(lpmpCur._2_2_,(MSGPLR *)lpmpCur + 1),
                       (byte *)CONCAT22(lpbMsg._2_2_,(byte *)lpbMsg),uVar5);
    iMsgSendCur = iMsgSendCur + dInc;
    if (iMsgSendCur < 0) {
      iMsgSendCur = 0;
    }
    sVar4 = 1;
  }
  return sVar4;
}



// ======================================================================
// Function: PszGetCompressedMessage
// Address: 1030:9eb8
// Segment: MEMORY_MSG
// ======================================================================


char * PszGetCompressedMessage(MessageId idm)

{
  int iVar1;
  byte *pbVar2;
  bool bVar3;
  short iChunk;
  byte *pch;
  short fHigh;
  char *pszOut;
  short iOffset;
  byte *pchLen;
  short iLen;
  short i;
  short iNibble;
  short iBuild;
  
  iNibble = 0;
  if (idm != (int)iLastMsgGet) {
    pchLen = (byte *)CONCAT22((undefined *)&DAT_1120_1030,(byte *)acMSG + ((int)idm >> 6) * 0x40);
    for (i = 0; i < (int)(idm & idmProductionQueueEmpty); i = i + 1) {
      iNibble = iNibble + (uint)*pchLen;
      pchLen = (byte *)CONCAT22(pchLen._2_2_,(byte *)pchLen + 1);
    }
    pch = (byte *)CONCAT22((undefined *)&DAT_1120_1030,
                           (byte *)(((short *)aiMSGChunkOffset)[(int)idm >> 6] + (iNibble >> 1)));
    bVar3 = (iNibble & 1U) == 0;
    pszOut = (char *)szLastMsgGet;
    iBuild = 0;
    iLen = (uint)*pchLen;
    while (pbVar2 = pch, iVar1 = iLen + -1, iLen != 0) {
      if (bVar3) {
        i = (int)(uint)*pch >> 4;
      }
      else {
        pch = (byte *)CONCAT22(pch._2_2_,(byte *)pch + 1);
        i = *pbVar2 & 0xf;
      }
      bVar3 = !bVar3;
      iBuild = iBuild + i;
      iLen = iVar1;
      if (i != 0xf) {
        *pszOut = ((char *)rgMSGLookupTable)[iBuild];
        pszOut = pszOut + 1;
        iBuild = 0;
      }
    }
    *pszOut = '\0';
  }
  return (char *)szLastMsgGet;
}



// ======================================================================
// Function: SetFilteringGroups
// Address: 1030:a018
// Segment: MEMORY_MSG
// ======================================================================


void SetFilteringGroups(short idm,short fSet)

{
  byte bVar1;
  bool bVar2;
  short i;
  
  bVar2 = fSet != 0;
  bVar1 = (byte)idm;
  ((byte *)bitfMsgFiltered)[idm >> 3] =
       ((byte *)bitfMsgFiltered)[idm >> 3] & ~(byte)(1 << (bVar1 & 7)) |
       bVar2 << (bVar1 & 7);
  if ((idm == 0x35) || (idm == 0x36)) {
    ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] =
         ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] & ~(byte)(1 << ((bVar1 ^ 3) & 7))
         | bVar2 << ((bVar1 ^ 3) & 7);
  }
  else if ((idm == 0x37) || (idm == 0x38)) {
    ((byte *)bitfMsgFiltered)[(int)(idm ^ 0xfU) >> 3] =
         ((byte *)bitfMsgFiltered)[(int)(idm ^ 0xfU) >> 3] &
         ~(byte)(1 << ((bVar1 ^ 0x37) & 7)) | bVar2 << ((bVar1 ^ 0x37) & 7);
  }
  else if ((idm == 0x39) || (idm == 0x3a)) {
    ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] =
         ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] & ~(byte)(1 << ((bVar1 ^ 3) & 7))
         | bVar2 << ((bVar1 ^ 3) & 7);
  }
  else if ((idm < 0x2b) || (0x2e < idm)) {
    if ((idm == 0x2f) || (idm == 0x30)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 0x1fU) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 0x1fU) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 0x2f) & 7)) | bVar2 << ((bVar1 ^ 0x2f) & 7);
    }
    else if ((idm == 0x42) || (idm == 0x43)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x44) || (idm == 0x45)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x46) || (idm == 0x47)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x48) || (idm == 0x49)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 0x49) & 7)) | bVar2 << ((bVar1 ^ 0x49) & 7);
    }
    else if ((idm == 0x4a) || (idm == 0x4b)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm == 0x4c) || (idm == 0x4d)) {
      ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] =
           ((byte *)bitfMsgFiltered)[(int)(idm ^ 1U) >> 3] &
           ~(byte)(1 << ((bVar1 ^ 1) & 7)) | bVar2 << ((bVar1 ^ 1) & 7);
    }
    else if ((idm < 0x60) || (100 < idm)) {
      if ((idm < 0x6a) || (0x6e < idm)) {
        if ((idm == 0x79) || (idm == 0x7a)) {
          ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] =
               ((byte *)bitfMsgFiltered)[(int)(idm ^ 3U) >> 3] &
               ~(byte)(1 << ((bVar1 ^ 3) & 7)) | bVar2 << ((bVar1 ^ 3) & 7);
        }
        else if ((0x90 < idm) && (idm < 0xa9)) {
          for (i = 0x91; i < 0xa9; i = i + 1) {
            ((byte *)bitfMsgFiltered)[i >> 3] =
                 ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
                 bVar2 << ((byte)i & 7);
          }
        }
      }
      else {
        for (i = 0x6a; i < 0x6f; i = i + 1) {
          ((byte *)bitfMsgFiltered)[i >> 3] =
               ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
               bVar2 << ((byte)i & 7);
        }
      }
    }
    else {
      for (i = 0x60; i < 0x65; i = i + 1) {
        ((byte *)bitfMsgFiltered)[i >> 3] =
             ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
             bVar2 << ((byte)i & 7);
      }
    }
  }
  else {
    for (i = 0x2b; i < 0x2f; i = i + 1) {
      ((byte *)bitfMsgFiltered)[i >> 3] =
           ((byte *)bitfMsgFiltered)[i >> 3] & ~(byte)(1 << ((byte)i & 7)) |
           bVar2 << ((byte)i & 7);
    }
  }
  return;
}



