// Decompiled code from stars.exe
// Generated by Ghidra - ExportAllDecompiled.py
// Grouped by nb09_ghidra_globals.json segmap.segname
//

// ======================================================================
// Function: PushRandom
// Address: 1040:1440
// Segment: MEMORY_UTILGEN
// ======================================================================

void PushRandom(long lNew1, long lNew2)

{
    int iVar1;

    iVar1 = cRandStack * 8;
    **((long (*)[2])rglRandStack + cRandStack) = (undefined2)lRandSeed1;
    *(undefined2 *)((int)rglRandStack[0] + 2 + iVar1) = lRandSeed1._2_2_;
    iVar1 = cRandStack * 8;
    *(undefined2 *)((int)rglRandStack[0] + 4 + iVar1) = (undefined2)lRandSeed2;
    *(undefined2 *)((int)rglRandStack[0] + 6 + iVar1) = lRandSeed2._2_2_;
    cRandStack = cRandStack + 1;
    lRandSeed1 = lNew1;
    lRandSeed2 = lNew2;
    return;
}

// ======================================================================
// Function: PopRandom
// Address: 1040:14a2
// Segment: MEMORY_UTILGEN
// ======================================================================

void PopRandom(void)

{
    cRandStack = cRandStack + -1;
    lRandSeed1._0_2_ = (int)(*((long (*)[2])rglRandStack + cRandStack))[0];
    lRandSeed1._2_2_ = *(undefined2 *)((int)rglRandStack[0] + 2 + cRandStack * 8);
    lRandSeed2._0_2_ = *(undefined2 *)((int)rglRandStack[0] + 4 + cRandStack * 8);
    lRandSeed2._2_2_ = *(undefined2 *)((int)rglRandStack[0] + 6 + cRandStack * 8);
    return;
}

// ======================================================================
// Function: Randomize
// Address: 1040:15ea
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Variable defined which should be unmapped: b */

void Randomize(ulong dw)

{
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    ulong      uVar1;
    short      b;
    short      a;

    uVar1 = __aFulshr(CONCAT22(unaff_SI, unaff_DI), b);
    b = (uint)uVar1 & 0x3f;
    if (((uint)dw & 0x3f) == b) {
        b = b + 1U & 0x3f;
    }
    lRandSeed1._0_2_ = ((short *)rgPrimes)[(uint)dw & 0x3f];
    lRandSeed1._2_2_ = ((short *)rgPrimes)[(uint)dw & 0x3f] >> 0xf;
    lRandSeed2._0_2_ = ((short *)rgPrimes)[b];
    lRandSeed2._2_2_ = ((short *)rgPrimes)[b] >> 0xf;
    return;
}

// ======================================================================
// Function: Randomize2
// Address: 1040:165a
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Variable defined which should be unmapped: b */

void Randomize2(ulong dw)

{
    uint       uVar1;
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    ulong      uVar2;
    short      b;
    short      a;

    uVar2 = __aFulshr(CONCAT22(unaff_SI, unaff_DI), b);
    uVar1 = (uint)dw & 0x7f ^ 0x35;
    b = (uint)uVar2 & 0x7f ^ 0x5c;
    if (uVar1 == b) {
        b = b + 1U & 0x7f;
    }
    lRandSeed1._0_2_ = ((short *)rgPrimes)[uVar1];
    lRandSeed1._2_2_ = ((short *)rgPrimes)[uVar1] >> 0xf;
    lRandSeed2._0_2_ = ((short *)rgPrimes)[b];
    lRandSeed2._2_2_ = ((short *)rgPrimes)[b] >> 0xf;
    return;
}

// ======================================================================
// Function: Random
// Address: 1040:16d2
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x10401832) */

short Random(short c)

{
    long  lVar1;
    long  lVar2;
    uint  uVar3;
    int   iVar4;
    uint  uVar5;
    int   iVar6;
    short sVar7;
    ulong uVar8;
    ulong uVar9;
    ulong uVar10;
    long  s2;
    long  k;
    long  s1;
    long  z;

    iVar6 = lRandSeed2._2_2_;
    uVar5 = (uint)lRandSeed2;
    iVar4 = lRandSeed1._2_2_;
    uVar3 = (uint)lRandSeed1;
    uVar8 = __aFldiv(CONCAT22(lRandSeed1._2_2_, (uint)lRandSeed1), 0xd1a4);
    uVar9 = __aFulmul(uVar8, 0x2fb3);
    uVar10 = 0x9c4e;
    uVar8 = __aFulmul(uVar8, 0xd1a4);
    uVar8 = __aFulmul(CONCAT22((iVar4 - (int)(uVar8 >> 0x10)) - (uint)(uVar3 < (uint)uVar8), uVar3 - (uint)uVar8), uVar10);
    lVar1 = uVar8 - uVar9;
    if ((lVar1 < 0x10000) && (lVar1 < 0)) {
        lVar1 = lVar1 + 0x7fffffab;
    }
    uVar8 = __aFldiv(CONCAT22(iVar6, uVar5), 0xce26);
    uVar9 = __aFulmul(uVar8, 0xecf);
    uVar10 = 0x9ef4;
    uVar8 = __aFulmul(uVar8, 0xce26);
    uVar8 = __aFulmul(CONCAT22((iVar6 - (int)(uVar8 >> 0x10)) - (uint)(uVar5 < (uint)uVar8), uVar5 - (uint)uVar8), uVar10);
    lVar2 = uVar8 - uVar9;
    if ((lVar2 < 0x10000) && (lVar2 < 0)) {
        lVar2 = lVar2 + 0x7fffff07;
    }
    uVar8 = lVar1 - lVar2;
    if ((long)uVar8 < 1) {
        uVar8 = uVar8 + 0x7fffffaa;
    }
    if (c < 1) {
        sVar7 = 0;
    } else {
        lRandSeed2 = lVar2;
        lRandSeed1 = lVar1;
        uVar8 = __aFulrem(uVar8, (long)c);
        sVar7 = (short)uVar8;
        lVar1 = lRandSeed1;
        lVar2 = lRandSeed2;
    }
    lRandSeed2._2_2_ = (int)((ulong)lVar2 >> 0x10);
    lRandSeed2._0_2_ = (uint)lVar2;
    lRandSeed1._2_2_ = (int)((ulong)lVar1 >> 0x10);
    lRandSeed1._0_2_ = (uint)lVar1;
    return sVar7;
}

// ======================================================================
// Function: RandomSeedDlg
// Address: 1040:188a
// Segment: MEMORY_UTILGEN
// ======================================================================

short RandomSeedDlg(HWND hwnd, WMType message, ushort wParam, long lParam)

{
    int        iVar1;
    int        iVar2;
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    undefined2 unaff_SS;
    ulong      uVar3;
    ushort     in_stack_0000ffc8;
    RECT       rc;
    ulong      dw;
    char      *pch;
    char       szValue[33];

    if (message == WM_ERASEBKGND) {
        GetClientRect(hwnd, &rc);
        FillRect(wParam, &rc, hbrButtonFace);
        return 1;
    }
    if (message == WM_CTLCOLOR) {
        uVar3 = __aFulshr(CONCAT22(unaff_SI, unaff_DI), in_stack_0000ffc8);
        if ((int)uVar3 == 6) {
            SetBkColor(wParam, CONCAT22(crButtonFace._2_2_, (undefined2)crButtonFace));
            return hbrButtonFace;
        }
    } else {
        if (message == WM_INITDIALOG) {
            SetWindowPos(hwnd, 0, 0x100, 0x100, 0, 0, 0x15);
            SendDlgItemMessage(hwnd, 0x10c, 0x415, 0x1f, 0);
            return 1;
        }
        if ((message == WM_COMMAND) && ((wParam == 1 || (wParam == 2)))) {
            if (wParam == 1) {
                GetDlgItemText(hwnd, IDC_EDITTEXT, szValue, 0x20);
                pch = szValue;
                uVar3 = 0;
                while ((*(byte *)(*pch + 0x175f) & 4) != 0) {
                    iVar1 = *pch + -0x30;
                    iVar2 = iVar1 >> 0xf;
                    uVar3 = __aFulmul(uVar3, 10);
                    uVar3 = uVar3 + CONCAT22(iVar2, iVar1);
                    pch = pch + 1;
                }
                if (uVar3 == 0) {
                    return 1;
                }
                Randomize(uVar3);
            }
            EndDialog(hwnd, (uint)(wParam == 1));
            return 1;
        }
    }
    return 0;
}

// ======================================================================
// Function: GetFileSeeds
// Address: 1040:1a4e
// Segment: MEMORY_UTILGEN
// ======================================================================

void GetFileSeeds(long *pl1, long *pl2)

{
    undefined2 uVar1;

    uVar1 = lFileSeed1._2_2_;
    *(undefined2 *)pl1 = (undefined2)lFileSeed1;
    *(undefined2 *)((int)pl1 + 2) = uVar1;
    uVar1 = lFileSeed2._2_2_;
    *(undefined2 *)pl2 = (undefined2)lFileSeed2;
    *(undefined2 *)((int)pl2 + 2) = uVar1;
    return;
}

// ======================================================================
// Function: SetFileSeeds
// Address: 1040:1a7c
// Segment: MEMORY_UTILGEN
// ======================================================================

void SetFileSeeds(long l1, long l2)

{
    lFileSeed1 = l1;
    lFileSeed2 = l2;
    return;
}

// ======================================================================
// Function: SetFileXorStream
// Address: 1040:1aa6
// Segment: MEMORY_UTILGEN
// ======================================================================

void SetFileXorStream(long lid, short lSalt, short turn, short iPlayer, short fCrippled)

{
    short b;
    short a;

    a = lSalt & 0x1f;
    b = lSalt >> 5 & 0x1f;
    if ((lSalt & 0x400U) == 0) {
        b = b + 0x20;
    } else {
        a = a + 0x20;
    }
    lFileSeed1._0_2_ = ((short *)rgPrimes)[a];
    lFileSeed1._2_2_ = (int)lFileSeed1 >> 0xf;
    lFileSeed2._0_2_ = ((short *)rgPrimes)[b];
    lFileSeed2._2_2_ = (int)lFileSeed2 >> 0xf;
    a = (((uint)lid & 3) + 1) * ((turn & 3U) + 1) * ((iPlayer & 3U) + 1) + fCrippled;
    while (0 < a) {
        LGetNextFileXor();
        a = a + -1;
    }
    return;
}

// ======================================================================
// Function: LGetNextFileXor
// Address: 1040:1b54
// Segment: MEMORY_UTILGEN
// ======================================================================

long LGetNextFileXor(void)

{
    long  lVar1;
    uint  uVar2;
    int   iVar3;
    uint  uVar4;
    int   iVar5;
    ulong uVar6;
    ulong uVar7;
    ulong uVar8;
    long  s2;
    long  k;
    long  s1;

    iVar5 = lFileSeed2._2_2_;
    uVar4 = (uint)lFileSeed2;
    iVar3 = lFileSeed1._2_2_;
    uVar2 = (uint)lFileSeed1;
    uVar6 = __aFldiv(CONCAT22(lFileSeed1._2_2_, (uint)lFileSeed1), 0xd1a4);
    uVar7 = __aFulmul(uVar6, 0x2fb3);
    uVar8 = 0x9c4e;
    uVar6 = __aFulmul(uVar6, 0xd1a4);
    uVar6 = __aFulmul(CONCAT22((iVar3 - (int)(uVar6 >> 0x10)) - (uint)(uVar2 < (uint)uVar6), uVar2 - (uint)uVar6), uVar8);
    lVar1 = uVar6 - uVar7;
    if ((lVar1 < 0x10000) && (lVar1 < 0)) {
        lVar1 = lVar1 + 0x7fffffab;
    }
    uVar6 = __aFldiv(CONCAT22(iVar5, uVar4), 0xce26);
    uVar7 = __aFulmul(uVar6, 0xecf);
    uVar8 = 0x9ef4;
    uVar6 = __aFulmul(uVar6, 0xce26);
    uVar6 = __aFulmul(CONCAT22((iVar5 - (int)(uVar6 >> 0x10)) - (uint)(uVar4 < (uint)uVar6), uVar4 - (uint)uVar6), uVar8);
    lFileSeed2 = uVar6 - uVar7;
    if ((lFileSeed2 < 0x10000) && (lFileSeed2 < 0)) {
        lFileSeed2 = lFileSeed2 + 0x7fffff07;
    }
    lFileSeed1 = lVar1;
    return lVar1 - lFileSeed2;
}

// ======================================================================
// Function: XorFileBuf
// Address: 1040:1cc4
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Variable defined which should be unmapped: pch */

void XorFileBuf(char *rgb, short cb)

{
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    long       lVar1;
    long       lVar2;
    char      *pch;
    long       lPrev;
    long      *pl;
    long      *plMac;

    lVar2 = CONCAT22(unaff_SI, unaff_DI);
    for (pl = rgb; pl < rgb + (cb >> 2) * 4; pl = pl + 1) {
        lVar1 = LGetNextFileXor();
        *(uint *)pl = *(uint *)pl ^ (uint)lVar1;
        *(uint *)((int)pl + 2) = *(uint *)((int)pl + 2) ^ (uint)((ulong)lVar1 >> 0x10);
    }
    if ((cb & 3U) != 0) {
        pch = pl;
        lVar1 = LGetNextFileXor();
        cb = cb & 3U;
        while (cb != 0) {
            *pch = *pch ^ (byte)lVar1;
            lVar1 = __aFlshr(lVar2, (ushort)pch);
            pch = pch + 1;
            cb = cb + -1;
        }
    }
    return;
}

// ======================================================================
// Function: ICompLong
// Address: 1040:1d74
// Segment: MEMORY_UTILGEN
// ======================================================================

short ICompLong(void *arg1, void *arg2)

{
    return *(int *)arg1 - *(int *)arg2;
}

// ======================================================================
// Function: PszGetCompressedPlanet
// Address: 1040:1d96
// Segment: MEMORY_UTILGEN
// ======================================================================

char *PszGetCompressedPlanet(short id)

{
    int   iVar1;
    bool  bVar2;
    byte *pbVar3;
    bool  bVar4;
    short iLen;
    byte *pch;
    char *pszOut;
    byte *pchLen;
    short iNibble;
    short iBuild;
    short i;
    short iChunk;
    short fHigh;
    short iOffset;
    short fCap;

    iNibble = 0;
    if (0x3e6 < id) {
        id = id % 999;
    }
    if (id != iLastGet) {
        pchLen = (byte *)acPN + (id >> 6) * 0x40;
        for (i = 0; i < (int)(id & 0x3fU); i = i + 1) {
            iNibble = iNibble + (uint)*pchLen;
            pchLen = (byte *)pchLen + 1;
        }
        pch = (byte *)(((short *)aiPNChunkOffset)[id >> 6] + (iNibble >> 1));
        bVar4 = (iNibble & 1U) == 0;
        pszOut = (char *)szLastGet;
        iBuild = 0;
        bVar2 = true;
        iLen = (uint)*pchLen;
        while (pbVar3 = pch, iVar1 = iLen + -1, iLen != 0) {
            if (bVar4) {
                i = (int)(uint)*pch >> 4;
            } else {
                pch = (byte *)pch + 1;
                i = *pbVar3 & 0xf;
            }
            bVar4 = !bVar4;
            iBuild = iBuild + i;
            iLen = iVar1;
            if (i != 0xf) {
                *pszOut = ((char *)rgPNLookupTable)[iBuild];
                if (((bVar2) && ('`' < *pszOut)) && (*pszOut < '{')) {
                    *pszOut = *pszOut + -0x20;
                }
                if ((*pszOut == ' ') || (*pszOut == '-')) {
                    bVar2 = true;
                } else {
                    bVar2 = false;
                }
                pszOut = pszOut + 1;
                iBuild = 0;
            }
        }
        *pszOut = '\0';
    }
    return (char *)szLastGet;
}

// ======================================================================
// Function: OutputFileString
// Address: 1040:1f64
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Variable defined which should be unmapped: w */
/* WARNING: Variable defined which should be unmapped: hf */

void OutputFileString(char *szFile, char *sz)

{
    short      sVar1;
    HFILE      HVar2;
    ushort     uVar3;
    undefined2 unaff_SS;
    char      *pcStack_92;
    short      hf;
    ushort     w;
    OFSTRUCT   of;

    w = 2;
    sVar1 = __access(szFile, 0);
    if (sVar1 == -1) {
        w = 0x1002;
    }
    HVar2 = OpenFile(szFile, &of, w);
    if (HVar2 != 0xffff) {
        __lseek(HVar2, 0, 2);
        pcStack_92 = sz;
        uVar3 = _strlen(sz);
        _lwrite(HVar2, pcStack_92, uVar3);
        _lclose(0x1120);
    }
    return;
}

// ======================================================================
// Function: CopyStarsFile
// Address: 1040:1ffa
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x104020de) */

void CopyStarsFile(char *szSrc, char *szDst)

{
    short (*pasVar1)[9];
    short      sVar2;
    short      sVar3;
    UINT       UVar4;
    undefined2 unaff_SS;
    long       lVar5;
    short (*penvSav)[9];
    long     cb;
    short    hfDst;
    short    env[9];
    OFSTRUCT of;
    short    fFileErrSav;
    char     rgb[2048];

    sVar2 = fFileErrSilent;
    pasVar1 = penvMem;
    hfDst = -1;
    fFileErrSilent = 1;
    penvMem = &env;
    sVar3 = __setjmp(env);
    if (sVar3 == 0) {
        StreamOpen(szSrc, mdRead);
        hfDst = OpenFile(szDst, &of, 0x1012);
        if (hfDst == 0xffff) {
            StreamClose();
            return;
        }
        lVar5 = __filelength(hf);
        while (true) {
            cb._2_2_ = (int)((ulong)lVar5 >> 0x10);
            cb._0_2_ = (uint)lVar5;
            if (lVar5 < 0x801)
                break;
            RgFromStream(rgb, 0x800);
            UVar4 = _lwrite(hfDst, rgb, 0x800);
            if (UVar4 != 0x800)
                goto UTILGEN_LStreamError;
            lVar5 = CONCAT22(cb._2_2_ - (uint)((uint)cb < 0x800), (uint)cb - 0x800);
        }
        if (lVar5 != 0) {
            RgFromStream(rgb, (uint)cb);
            _lwrite(hfDst, rgb, (uint)cb);
        }
    }
UTILGEN_LStreamError:
    StreamClose();
    if (hfDst != -1) {
        _lclose(hf);
    }
    penvMem = pasVar1;
    fFileErrSilent = sVar2;
    return;
}

// ======================================================================
// Function: AlertSz
// Address: 1040:2160
// Segment: MEMORY_UTILGEN
// ======================================================================

short AlertSz(char *sz, short mbType)

{
    short      sVar1;
    HWND       HVar2;
    undefined2 unaff_SS;
    char       szT[256];

    if (((ini.wFlags >> 0xe & 1) == 0) && ((-1 < (int)ini.wFlags || ((ini.wFlags >> 3 & 1) == 0)))) {
        HVar2 = GetFocus();
        sVar1 = MessageBox(HVar2, sz, "Stars!", mbType);
    } else {
        _wsprintf(szT, "Error: %s", sz, 0x1120);
        if ((ini.wFlags >> 0xe & 1) == 0) {
            sVar1 = 6;
        } else {
            sVar1 = 7;
        }
        OutputSz(sVar1, szT);
        sVar1 = 6;
    }
    return sVar1;
}

// ======================================================================
// Function: CchGetString
// Address: 1040:221e
// Segment: MEMORY_UTILGEN
// ======================================================================

short CchGetString(StringId ids, char *psz)

{
    char *pcVar1;
    char *pszTT;
    char *pszT;

    pcVar1 = psz;
    pszT = PszGetCompressedString(ids);
    while (*pszT != '\0') {
        *psz = *pszT;
        psz = psz + 1;
        pszT = pszT + 1;
    }
    *psz = '\0';
    return (int)psz - (int)pcVar1;
}

// ======================================================================
// Function: PszFromInt
// Address: 1040:2274
// Segment: MEMORY_UTILGEN
// ======================================================================

char *PszFromInt(short i, short *pcch)

{
    short sVar1;
    short cch;

    sVar1 = _wsprintf(szFormatNumber, PCTD, i);
    if (pcch != 0) {
        *pcch = sVar1;
    }
    return (char *)szFormatNumber;
}

// ======================================================================
// Function: PszFromLong
// Address: 1040:22b6
// Segment: MEMORY_UTILGEN
// ======================================================================

char *PszFromLong(long l, short *pcch)

{
    short sVar1;
    short cch;

    sVar1 = _wsprintf(szFormatNumber, PCTLD, (undefined2)l, l._2_2_);
    if (*pcch != 0) {
        *pcch = sVar1;
    }
    return (char *)szFormatNumber;
}

// ======================================================================
// Function: PszFromLongK
// Address: 1040:22fe
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x10402315) */
/* WARNING: Removing unreachable block (ram,0x10402339) */

char *PszFromLongK(long l, short *pcch)

{
    int   iVar1;
    bool  bVar2;
    bool  bVar3;
    char *pcVar4;
    char *psz;
    short fLarge;
    short fExtraLarge;

    bVar2 = 9999 < l;
    bVar3 = 999999 < l;
    if (bVar3) {
        l = __aFldiv(l + 500000, 1000000);
        if ((-1 < l) && ((0 < (int)((ulong)l >> 0x10) || (999 < (uint)l)))) {
            l = 999;
        }
    } else if (bVar2) {
        l = __aFldiv(l + 500, 1000);
        if ((-1 < l) && ((0 < (int)((ulong)l >> 0x10) || (999 < (uint)l)))) {
            l = 999;
        }
    }
    pcVar4 = PszFromInt((short)l, pcch);
    if (bVar3) {
        iVar1 = *pcch;
        *pcch = *pcch + 1;
        pcVar4[iVar1] = 'M';
    } else if (bVar2) {
        iVar1 = *pcch;
        *pcch = *pcch + 1;
        pcVar4[iVar1] = 'k';
    }
    return pcVar4;
}

// ======================================================================
// Function: CommaFormatLong
// Address: 1040:2440
// Segment: MEMORY_UTILGEN
// ======================================================================

short CommaFormatLong(char *psz, long l)

{
    short      sVar1;
    undefined2 unaff_SS;
    char      *pch;
    char      *pchOut;
    short      cSkip;
    short      c;
    char       rgch[15];

    sVar1 = _wsprintf(rgch, PCTLD, (undefined2)l, l._2_2_);
    pch = rgch;
    pchOut = psz;
    cSkip = sVar1 % 3;
    if (cSkip == 0) {
        cSkip = 3;
    } else if (((cSkip == 1) && (l < 0x10000)) && (l < 0)) {
        cSkip = 4;
    }
    while (0 < cSkip) {
        *pchOut = *pch;
        pch = pch + 1;
        pchOut = pchOut + 1;
        cSkip = cSkip + -1;
    }
    while (*pch != '\0') {
        cSkip = 3;
        *pchOut = ',';
        while (true) {
            pchOut = pchOut + 1;
            if (cSkip < 1)
                break;
            *pchOut = *pch;
            pch = pch + 1;
            cSkip = cSkip + -1;
        }
    }
    *pchOut = '\0';
    return (int)pchOut - (int)psz;
}

// ======================================================================
// Function: CtrTextOut
// Address: 1040:2534
// Segment: MEMORY_UTILGEN
// ======================================================================

void CtrTextOut(HDC hdc, short x, short y, char *psz, short cLen)

{
    DWORD DVar1;
    short dx;

    if (cLen == 0) {
        cLen = lstrlen(psz);
    }
    DVar1 = GetTextExtent(hdc, psz, cLen);
    TextOut(hdc, x - ((int)DVar1 >> 1), y, psz, cLen);
    return;
}

// ======================================================================
// Function: DxStreamTextOut
// Address: 1040:2590
// Segment: MEMORY_UTILGEN
// ======================================================================

short DxStreamTextOut(HDC hdc, short *px, short y, char *psz, short cLen, short fPrint)

{
    DWORD DVar1;
    short dx;

    if (cLen == 0) {
        cLen = lstrlen(psz);
    }
    DVar1 = GetTextExtent(hdc, psz, cLen);
    if (fPrint != 0) {
        TextOut(hdc, *px, y, psz, cLen);
    }
    *px = *px + (int)DVar1;
    return (int)DVar1;
}

// ======================================================================
// Function: WrapTextOut
// Address: 1040:25fe
// Segment: MEMORY_UTILGEN
// ======================================================================

void WrapTextOut(HDC hdc, short *px, short *py, char *psz, short cLen, short xLeft, short dxWidth, short *pxMax, short fNewLine, short fPrint)

{
    bool  bVar1;
    DWORD DVar2;
    char *pch;
    char *pchStart;
    short dx;
    short xRight;
    short fItFit;
    char *pchEnd;
    short dxRemain;

    dxRemain = dxWidth - (*px - xLeft);
    if (cLen == 0) {
        cLen = _strlen(psz);
    }
    if (fNewLine != 0) {
        *py = *py + dyArial8;
        *px = xLeft;
    }
    pchStart = psz;
    do {
        pchEnd = pchStart + cLen;
        ChopTrailingSpaces(pchStart, &pchEnd);
        DVar2 = GetTextExtent(hdc, pchStart, (int)pchEnd - (int)pchStart);
        bVar1 = true;
        dx = (short)DVar2;
        while (((dxRemain < dx && (pchStart < pchEnd)) && (0 < dx))) {
            bVar1 = false;
            ChopLastWord(pchStart, &pchEnd);
            DVar2 = GetTextExtent(hdc, pchStart, (int)pchEnd - (int)pchStart);
            dx = (short)DVar2;
        }
        if (bVar1) {
            AddBackTrailingSpaces(&pchEnd, pchStart + cLen);
            DVar2 = GetTextExtent(hdc, pchStart, (int)pchEnd - (int)pchStart);
            dx = (short)DVar2;
        }
        if (pchStart == pchEnd) {
            if (*px == xLeft) {
                pchEnd = pchStart + cLen;
                DVar2 = GetTextExtent(hdc, pchStart, (int)pchEnd - (int)pchStart);
                dx = (short)DVar2;
                goto LAB_1040_275f;
            }
        } else {
        LAB_1040_275f:
            if (fPrint != 0) {
                TextOut(hdc, *px, *py, pchStart, (int)pchEnd - (int)pchStart);
            }
            *px = *px + dx;
            if ((pxMax != 0) && (*pxMax < *px)) {
                *pxMax = *px;
            }
            if (pchEnd == pchStart + cLen) {
                return;
            }
        }
        AddBackTrailingSpaces(&pchEnd, pchStart + cLen);
        cLen = cLen - ((int)pchEnd - (int)pchStart);
        pchStart = pchEnd;
        *py = *py + dyArial8;
        *px = xLeft;
        dxRemain = dxWidth;
    } while (true);
}

// ======================================================================
// Function: AddBackTrailingSpaces
// Address: 1040:280c
// Segment: MEMORY_UTILGEN
// ======================================================================

void AddBackTrailingSpaces(char **ppch, char *pchEnd)

{
    while ((*ppch < pchEnd && (**ppch == ' '))) {
        *ppch = *ppch + 1;
    }
    return;
}

// ======================================================================
// Function: ChopLastWord
// Address: 1040:2842
// Segment: MEMORY_UTILGEN
// ======================================================================

void ChopLastWord(char *pBeg, char **ppEnd)

{
    while ((pBeg < *ppEnd && ((*ppEnd)[-1] == ' '))) {
        *ppEnd = *ppEnd + -1;
    }
    while ((pBeg < *ppEnd && ((*ppEnd)[-1] != ' '))) {
        *ppEnd = *ppEnd + -1;
    }
    while ((pBeg < *ppEnd && ((*ppEnd)[-1] == ' '))) {
        *ppEnd = *ppEnd + -1;
    }
    return;
}

// ======================================================================
// Function: ChopTrailingSpaces
// Address: 1040:28c6
// Segment: MEMORY_UTILGEN
// ======================================================================

void ChopTrailingSpaces(char *pBeg, char **ppEnd)

{
    while ((pBeg < *ppEnd && ((*ppEnd)[-1] == ' '))) {
        *ppEnd = *ppEnd + -1;
    }
    return;
}

// ======================================================================
// Function: RcCtrTextOut
// Address: 1040:28fc
// Segment: MEMORY_UTILGEN
// ======================================================================

void RcCtrTextOut(HDC hdc, RECT *prc, char *psz, short cLen)

{
    int        iVar1;
    int        iVar2;
    int        iVar3;
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    DWORD      DVar4;
    ulong      uVar5;
    long       l;
    short      x;
    short      y;

    uVar5 = CONCAT22(unaff_SI, unaff_DI);
    if (cLen == -1) {
        FillRect(hdc, prc, hbrButtonFace);
        cLen = 0;
    }
    if (cLen == 0) {
        cLen = lstrlen(psz);
    }
    DVar4 = GetTextExtent(hdc, psz, cLen);
    iVar1 = prc->right;
    iVar2 = prc->left;
    iVar3 = prc->left;
    uVar5 = __aFulshr(uVar5, (ushort)DVar4);
    TextOut(hdc, (int)((iVar1 - iVar2) - (ushort)DVar4) / 2 + iVar3, ((prc->bottom - prc->top) - (int)uVar5) / 2 + prc->top, psz, cLen);
    return;
}

// ======================================================================
// Function: RightTextOut
// Address: 1040:29d6
// Segment: MEMORY_UTILGEN
// ======================================================================

void RightTextOut(HDC hdc, short x, short y, char *psz, short cLen, short dxErase)

{
    int        iVar1;
    undefined2 unaff_SS;
    DWORD      DVar2;
    RECT       rc;
    short      dx;

    if (cLen == -1) {
        cLen = CchGetString(idsNone2, psz);
    } else if (cLen == 0) {
        cLen = lstrlen(psz);
    }
    DVar2 = GetTextExtent(hdc, psz, cLen);
    iVar1 = (int)DVar2;
    if (iVar1 < dxErase) {
        SetRect(&rc, x - dxErase, y, x - iVar1, y + dyArial8);
        FillRect(hdc, &rc, hbrButtonFace);
    } else if ((0 < dxErase) && (dxErase < iVar1)) {
        SetRect(&rc, x - dxErase, y, x, y + dyArial8);
        ExtTextOut(hdc, x - iVar1, y, 6, &rc, psz, cLen, 0);
        return;
    }
    TextOut(hdc, x - iVar1, y, psz, cLen);
    return;
}

// ======================================================================
// Function: DiaganolTextOut
// Address: 1040:2afa
// Segment: MEMORY_UTILGEN
// ======================================================================

void DiaganolTextOut(HDC hdc, RECT *prc, char *psz, short cLen)

{
    double     dVar1;
    int        iVar2;
    int        iVar3;
    int        iVar4;
    LOGFONT   *pLVar5;
    short      sVar6;
    ushort     uVar7;
    double    *pdVar8;
    HFONT      HVar9;
    HGDIOBJ    HVar10;
    int        iVar11;
    int        iVar12;
    int        iVar13;
    int        iVar14;
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    long       lVar15;
    ulong      uVar16;
    long       local_48;
    short      dHtY;
    short      dHtX;
    long       l;
    double     rotate;
    short      dyFlat;
    short      dx;
    HFONT      hfontSav;
    double     dsin;
    LOGFONT   *plf;
    short      dxText;
    short      dyEstFont;
    short      xStart;
    short      dyText;
    double     dcos;
    short      dy;
    short      yStart;
    short      dxFlat;
    HFONT      hfont;
    double     angle;

    if (cLen == 0) {
        cLen = _strlen(psz);
    }
    iVar3 = prc->right - prc->left;
    iVar4 = prc->bottom - prc->top;
    if ((9 < iVar3) && (9 < iVar4)) {
        pLVar5 = (LOGFONT *)LocalAlloc(0x40, 0x32);
        pLVar5->lfWeight = 900;
        _strcpy(pLVar5->lfFaceName, *(char (*)[32])(rgszArial + 1));
        iVar13 = iVar3;
        if (iVar3 <= iVar4) {
            iVar13 = iVar4;
        }
        pLVar5->lfHeight = -iVar13;
        while (pLVar5->lfHeight < -4) {
            sVar6 = MulDiv(0x6f, -pLVar5->lfHeight, 100);
            if (iVar4 < sVar6) {
                if ((sVar6 - iVar4) / 2 < 2) {
                    iVar13 = 2;
                } else {
                    iVar13 = (sVar6 - iVar4) / 2;
                }
                pLVar5->lfHeight = pLVar5->lfHeight + iVar13;
            } else {
                local_48 = (long)iVar3;
                uVar7 = iVar4 - sVar6;
                iVar13 = (int)uVar7 >> 0xf;
                pdVar8 = _atan2((double)(long)(int)uVar7, (double)local_48);
                dVar1 = *pdVar8;
                lVar15 = __ftol((double)CONCAT26(iVar13, CONCAT24(uVar7, CONCAT22(unaff_SI, unaff_DI))));
                pLVar5->lfEscapement = (short)lVar15;
                HVar9 = CreateFontIndirect(pLVar5);
                HVar10 = SelectObject(hdc, HVar9);
                GetTextExtent(hdc, psz, cLen);
                uVar16 = __aFulshr(CONCAT22(unaff_SI, unaff_DI), uVar7);
                iVar13 = (int)uVar16;
                _sin(dVar1);
                _cos(dVar1);
                iVar14 = iVar13 >> 0xf;
                lVar15 = __ftol((double)CONCAT26(iVar14, CONCAT24(iVar13, CONCAT22(unaff_SI, unaff_DI))));
                iVar11 = (int)lVar15;
                lVar15 = __ftol((double)CONCAT26(iVar14, CONCAT24(iVar13, CONCAT22(unaff_SI, unaff_DI))));
                iVar12 = (int)lVar15;
                if ((iVar11 + 8 <= iVar3) && (iVar12 + 8 <= iVar4)) {
                    iVar2 = prc->left;
                    lVar15 = __ftol((double)CONCAT26(iVar14, CONCAT24(iVar13, CONCAT22(unaff_SI, unaff_DI))));
                    TextOut(hdc, (iVar3 - iVar11) / 2 + iVar2, (prc->bottom - (iVar4 - iVar12) / 2) - (int)lVar15, psz, cLen);
                    SelectObject(hdc, HVar10);
                    DeleteObject(HVar9);
                    break;
                }
                SelectObject(hdc, HVar10);
                DeleteObject(HVar9);
                if (iVar3 < iVar11 + 8) {
                    sVar6 = MulDiv(pLVar5->lfHeight, iVar3, iVar11 + 8);
                    dHtX = MulDiv(sVar6, 100, 0x6f);
                } else {
                    dHtX = -1000;
                }
                if (iVar4 < iVar12 + 8) {
                    sVar6 = MulDiv(pLVar5->lfHeight, iVar4, iVar12 + 8);
                    dHtY = MulDiv(sVar6, 100, 0x6f);
                } else {
                    dHtY = -1000;
                }
                sVar6 = dHtX;
                if (dHtX <= dHtY) {
                    sVar6 = dHtY;
                }
                if (sVar6 - pLVar5->lfHeight < 2) {
                    iVar13 = 2;
                } else {
                    if (dHtX <= dHtY) {
                        dHtX = dHtY;
                    }
                    iVar13 = dHtX - pLVar5->lfHeight;
                }
                pLVar5->lfHeight = pLVar5->lfHeight + iVar13 + 1;
            }
        }
        LocalFree((HLOCAL)pLVar5);
    }
    return;
}

// ======================================================================
// Function: ExpandRc
// Address: 1040:2f0c
// Segment: MEMORY_UTILGEN
// ======================================================================

void ExpandRc(RECT *prc, short dx, short dy)

{
    prc->left = prc->left - dx;
    prc->right = prc->right + dx;
    prc->top = prc->top - dy;
    prc->bottom = prc->bottom + dy;
    return;
}

// ======================================================================
// Function: OffsetRc
// Address: 1040:2f3e
// Segment: MEMORY_UTILGEN
// ======================================================================

void OffsetRc(RECT *prc, short dx, short dy)

{
    prc->left = prc->left + dx;
    prc->right = prc->right + dx;
    prc->top = prc->top + dy;
    prc->bottom = prc->bottom + dy;
    return;
}

// ======================================================================
// Function: BoundPoints
// Address: 1040:2f70
// Segment: MEMORY_UTILGEN
// ======================================================================

void BoundPoints(RECT *prc, POINT *rgpt, short cpt)

{
    short yMin;
    short xMin;
    short yMax;
    short xMax;
    short ipt;

    xMin = rgpt->x;
    yMin = rgpt->y;
    yMax = yMin;
    xMax = xMin;
    for (ipt = 1; ipt < cpt; ipt = ipt + 1) {
        if ((rgpt + ipt)->x <= xMin) {
            xMin = (rgpt + ipt)->x;
        }
        if (xMax <= (rgpt + ipt)->x) {
            xMax = (rgpt + ipt)->x;
        }
        if (rgpt[ipt].y <= yMin) {
            yMin = rgpt[ipt].y;
        }
        if (yMax <= rgpt[ipt].y) {
            yMax = rgpt[ipt].y;
        }
    }
    prc->top = yMin + -1;
    prc->bottom = yMax + 1;
    prc->left = xMin + -1;
    prc->right = xMax + 1;
    return;
}

// ======================================================================
// Function: StickyDlgPos
// Address: 1040:3094
// Segment: MEMORY_UTILGEN
// ======================================================================

void StickyDlgPos(HWND hwnd, POINT *ppt, short fInit)

{
    short      sVar1;
    short      sVar2;
    undefined2 unaff_SS;
    RECT       rc;
    POINT      ptScreenMax;

    GetWindowRect(hwnd, &rc);
    if (fInit == 0) {
        ppt->x = rc.left;
        ppt->y = rc.top;
    } else {
        sVar1 = GetSystemMetrics(0);
        sVar2 = GetSystemMetrics(1);
        if ((ppt->x == -1) && (ppt->y == -1)) {
            rc.left = sVar1 - (rc.right - rc.left) >> 1;
            rc.top = sVar2 - (rc.bottom - rc.top) >> 1;
        } else {
            OffsetRect(&rc, ppt->x - rc.left, ppt->y - rc.top);
            if (sVar1 < rc.right) {
                rc.left = rc.left + (sVar1 - rc.right);
            }
            if (sVar2 < rc.bottom) {
                rc.top = rc.top + (sVar2 - rc.bottom);
            }
            if (rc.left < 0) {
                rc.left = 0;
            }
            if (rc.top < 0) {
                rc.top = 0;
            }
        }
        SetWindowPos(hwnd, 0, rc.left, rc.top, 0, 0, 0x15);
    }
    return;
}

// ======================================================================
// Function: LDrawGauge
// Address: 1040:31a2
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x104031f9) */
/* WARNING: Removing unreachable block (ram,0x10403214) */

long LDrawGauge(HDC hdc, RECT *prc, short cSegs, long *rgSize, ushort *rghbr, long cTot)

{
    int        iVar1;
    undefined2 unaff_SS;
    long       lVar2;
    ulong      uVar3;
    ulong      uVar4;
    undefined2 uVar5;
    undefined2 uVar6;
    RECT       rc;
    long       dx;
    long       lSum;
    short      i;
    short      fHuge;

    uVar4 = 0;
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    FrameRect(hdc, &rc, hbrWindowText);
    ExpandRc(&rc, -1, -1);
    if (0 < cTot) {
        fHuge = (short)(9999999 < cTot);
        if (fHuge != 0) {
            cTot = __aFldiv(cTot, 1000);
        }
        iVar1 = rc.right - rc.left;
        for (i = 0; i < cSegs; i = i + 1) {
            if (fHuge == 0) {
                lVar2 = CONCAT22(*(undefined2 *)((int)(rgSize + i) + 2), (int)rgSize[i]);
            } else {
                lVar2 = __aFldiv(CONCAT22(*(undefined2 *)((int)(rgSize + i) + 2), (int)rgSize[i]), 1000);
            }
            uVar4 = lVar2 + uVar4;
            uVar5 = (undefined2)cTot;
            uVar6 = cTot._2_2_;
            uVar3 = __aFulmul((long)iVar1, uVar4);
            lVar2 = __aFldiv(uVar3, CONCAT22(uVar6, uVar5));
            rc.right = prc->left + 1 + (int)lVar2;
            if (rc.left < rc.right) {
                FillRect(hdc, &rc, rghbr[i]);
            }
            rc.left = rc.right;
        }
    }
    rc.right = prc->right + -1;
    if (rc.left < rc.right) {
        FillRect(hdc, &rc, hbrButtonFace);
    }
    if (fHuge != 0) {
        uVar4 = __aFulmul(uVar4, 1000);
    }
    return uVar4;
}

// ======================================================================
// Function: Draw3dFrame
// Address: 1040:336a
// Segment: MEMORY_UTILGEN
// ======================================================================

void Draw3dFrame(HDC hdc, RECT *prc, short fErase)

{
    HGDIOBJ HVar1;
    RECT    rc;
    HBRUSH  hbrSav;
    short   dx;
    short   dy;

    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    dx = prc->right - prc->left;
    dy = prc->bottom - prc->top;
    HVar1 = SelectObject(hdc, hbrButtonHilite);
    if ((fErase == -1) || (fErase == -2)) {
        PatBlt(hdc, rc.left, rc.bottom, dx + 1, 1, 0xf00021);
        PatBlt(hdc, rc.right, rc.top, 1, dy, 0xf00021);
        SelectObject(hdc, hbrButtonShadow);
        PatBlt(hdc, rc.left, rc.top, dx, 1, 0xf00021);
        PatBlt(hdc, rc.left, rc.top, 1, dy, 0xf00021);
        ExpandRc(&rc, -1, -1);
        SelectObject(hdc, hbrButtonHilite);
        dx = dx + -2;
        dy = dy + -2;
    }
    PatBlt(hdc, rc.left, rc.top, dx, 1, 0xf00021);
    PatBlt(hdc, rc.left, rc.top, 1, dy, 0xf00021);
    SelectObject(hdc, hbrButtonShadow);
    PatBlt(hdc, rc.left, rc.bottom, dx + 1, 1, 0xf00021);
    PatBlt(hdc, rc.right, rc.top, 1, dy, 0xf00021);
    if ((fErase != 0) && (fErase != -2)) {
        SelectObject(hdc, hbrButtonFace);
        PatBlt(hdc, rc.left + 1, rc.top + 1, dx + -1, dy + -1, 0xf00021);
    }
    SelectObject(hdc, HVar1);
    return;
}

// ======================================================================
// Function: InitBtnTrack
// Address: 1040:354c
// Segment: MEMORY_UTILGEN
// ======================================================================

void InitBtnTrack(BTNT *pbtnt, HWND hwnd, HDC hdc, RECT *prc, short btf, short dTimer, short fInitDown, short fNoEndRedraw, char *szText)

{
    pbtnt->hwnd = hwnd;
    pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfff7 | (uint)(hdc == 0) << 3;
    if (hdc == 0) {
        hdc = GetDC(hwnd);
    }
    pbtnt->hdc = hdc;
    (&pbtnt->rc)->left = prc->left;
    (pbtnt->rc).top = prc->top;
    (pbtnt->rc).right = prc->right;
    (pbtnt->rc).bottom = prc->bottom;
    pbtnt->btf = btf;
    pbtnt->dTimer = dTimer;
    pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfffe | 1;
    pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfffb | (fInitDown & 1U) << 2;
    pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xffef | (fNoEndRedraw & 1U) << 4;
    pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfffd | 2;
    pbtnt->szText = szText;
    return;
}

// ======================================================================
// Function: FTrackBtn
// Address: 1040:364a
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x104037b7) */

short FTrackBtn(BTNT *pbtnt)

{
    int   iVar1;
    long  lVar2;
    short sVar3;
    uint  uVar4;
    DWORD DVar5;
    POINT PVar6;
    long  ticksNew;
    short fInBtn;
    POINT pt;

    if ((pbtnt->wFlags_0x16 & 1) == 0) {
        pt.x = (&pbtnt->rc)->left;
        pt.y = (pbtnt->rc).top;
        do {
            sVar3 = FGetMouseMove(&pt);
            if (sVar3 == 0) {
                if (((pbtnt->wFlags_0x16 >> 1 & 1) != 0) && ((pbtnt->wFlags_0x16 >> 4 & 1) == 0)) {
                    pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfffd;
                    DrawBtn(pbtnt->hdc, &pbtnt->rc, pbtnt->btf, pbtnt->wFlags_0x16 >> 1 & 1 ^ pbtnt->wFlags_0x16 >> 2 & 1, pbtnt->szText);
                    pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfffd | 2;
                }
                ReleaseCapture();
                if ((pbtnt->wFlags_0x16 >> 3 & 1) != 0) {
                    ReleaseDC(pbtnt->hwnd, pbtnt->hdc);
                }
                return 0;
            }
            PVar6.y = pt.y;
            PVar6.x = pt.x;
            uVar4 = PtInRect(&pbtnt->rc, PVar6);
            if (uVar4 != (pbtnt->wFlags_0x16 >> 1 & 1)) {
                pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfffd | (uVar4 & 1) << 1;
                DrawBtn(pbtnt->hdc, &pbtnt->rc, pbtnt->btf, pbtnt->wFlags_0x16 >> 1 & 1 ^ pbtnt->wFlags_0x16 >> 2 & 1, pbtnt->szText);
            }
            DVar5 = GetCurrentTime();
        } while (((long)DVar5 < CONCAT22(*(undefined2 *)((int)&pbtnt->lTicks + 2), (int)pbtnt->lTicks)) || ((pbtnt->wFlags_0x16 >> 1 & 1) == 0));
        lVar2 = DVar5 + (long)pbtnt->dTimer;
        *(int *)&pbtnt->lTicks = (int)lVar2;
        *(undefined2 *)((int)&pbtnt->lTicks + 2) = (int)((ulong)lVar2 >> 0x10);
    } else {
        SetCapture(pbtnt->hwnd);
        DrawBtn(pbtnt->hdc, &pbtnt->rc, pbtnt->btf, pbtnt->wFlags_0x16 >> 1 & 1 ^ pbtnt->wFlags_0x16 >> 2 & 1, pbtnt->szText);
        iVar1 = pbtnt->dTimer;
        DVar5 = GetCurrentTime();
        lVar2 = DVar5 + (long)(iVar1 * 3);
        *(int *)&pbtnt->lTicks = (int)lVar2;
        *(undefined2 *)((int)&pbtnt->lTicks + 2) = (int)((ulong)lVar2 >> 0x10);
        pbtnt->wFlags_0x16 = pbtnt->wFlags_0x16 & 0xfffe;
    }
    return 1;
}

// ======================================================================
// Function: DrawBtn
// Address: 1040:38b8
// Segment: MEMORY_UTILGEN
// ======================================================================

void DrawBtn(HDC hdc, RECT *prc, short bt, short fDown, char *szText)

{
    HGDIOBJ    HVar1;
    int        iVar2;
    int        iVar3;
    int        iVar4;
    uint       uVar5;
    int        iVar6;
    HBRUSH     HVar7;
    uint       uVar8;
    short      sVar9;
    short      sVar10;
    short      sVar11;
    short      sVar12;
    int        iVar13;
    undefined2 unaff_SS;
    ulong      uVar14;
    long       lVar15;
    long       lVar16;
    COLORREF   CVar17;
    undefined2 uVar18;
    undefined2 uVar19;
    HFONT      hfontSav;
    RECT       rc;
    short      x;
    short      cpt;
    HBRUSH     hbrSav;
    short      dx;
    COLORREF   crSav;
    HBRUSH     hbrCur;
    POINT      rgptDraw[6];
    short      y;
    short      fNoShaft;
    short      dy;
    short      dxOffset;
    short      fDisabled;
    short      fBar;
    short      d;
    short      dyOffset;
    short      ipt;
    long       dxFace;

    fDisabled = bt & 4;
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    HVar1 = SelectObject(hdc, hbrWindowFrame);
    if ((bt & 0x40U) == 0) {
        FrameRect(hdc, &rc, hbrWindowFrame);
        ExpandRc(&rc, -1, -1);
    }
    iVar2 = rc.right - rc.left;
    iVar3 = rc.bottom - rc.top;
    iVar4 = iVar3 + -1;
    uVar5 = prc->right - prc->left;
    iVar6 = uVar5 - 5;
    iVar13 = ((int)uVar5 >> 0xf) + -1 + (uint)(4 < uVar5);
    HVar7 = hbrButtonShadow;
    if (fDown == 0) {
        HVar7 = hbrButtonHilite;
    }
    SelectObject(hdc, HVar7);
    PatBlt(hdc, rc.left, rc.top, iVar2 + -1, 1, 0xf00021);
    PatBlt(hdc, rc.left, rc.top, 1, iVar4, 0xf00021);
    HVar7 = hbrButtonFace;
    if (fDown == 0) {
        HVar7 = hbrButtonShadow;
    }
    SelectObject(hdc, HVar7);
    PatBlt(hdc, rc.left, rc.bottom + -1, iVar2, 1, 0xf00021);
    PatBlt(hdc, rc.right + -1, rc.top, 1, iVar4, 0xf00021);
    if (((iVar2 + -1 < 0xe) || (iVar4 < 0xe)) || ((bt & 0xc0U) != 0)) {
        ExpandRc(&rc, -1, -1);
    } else {
        PatBlt(hdc, rc.left + 1, rc.bottom + -2, iVar2 + -2, 1, 0xf00021);
        PatBlt(hdc, rc.right + -2, rc.top + 1, 1, iVar3 + -3, 0xf00021);
        SetRect(&rc, rc.left + 1, rc.top + 1, rc.right + -2, rc.bottom + -2);
    }
    SelectObject(hdc, hbrButtonFace);
    FillRect(hdc, &rc, hbrButtonFace);
    if ((bt & 8U) == 0) {
        uVar8 = bt & 0x10;
        uVar5 = bt & 3;
        if ((bt & 0x20U) == 0) {
            cpt = 5;
            _memcpy(rgptDraw, (POINT *)rgptArrow, 0x14);
            dx = 6;
            dy = 6;
        } else {
            cpt = 3;
            _memcpy(rgptDraw, (POINT *)rgptTriangle, 0xc);
            dx = 8;
            dy = 4;
        }
        if (uVar8 != 0) {
            for (ipt = 0; ipt < cpt; ipt = ipt + 1) {
                rgptDraw[ipt].y = rgptDraw[ipt].y + 1;
            }
            dy = dy + 2;
            rgptDraw[cpt].y = 0;
            (rgptDraw + cpt)->x = 0;
            cpt = cpt + 1;
        }
        for (ipt = 0; ipt < cpt; ipt = ipt + 1) {
            if ((rgptDraw + ipt)->x < 0) {
                (rgptDraw + ipt)->x = rgptDraw[0].x * 2 - (rgptDraw + -(rgptDraw + ipt)->x)->x;
            } else {
                uVar19 = 0;
                uVar18 = 0xb;
                uVar14 = __aFulmul((long)(rgptDraw + ipt)->x, CONCAT22(iVar13, iVar6));
                lVar15 = __aFldiv(uVar14, CONCAT22(uVar19, uVar18));
                (rgptDraw + ipt)->x = (short)lVar15;
            }
            uVar19 = 0;
            uVar18 = 0xb;
            uVar14 = __aFulmul((long)rgptDraw[ipt].y, CONCAT22(iVar13, iVar6));
            lVar15 = __aFldiv(uVar14, CONCAT22(uVar19, uVar18));
            rgptDraw[ipt].y = (short)lVar15;
        }
        uVar19 = 0;
        uVar18 = 0xb;
        uVar14 = __aFulmul((long)dx, CONCAT22(iVar13, iVar6));
        lVar15 = __aFldiv(uVar14, CONCAT22(uVar19, uVar18));
        uVar19 = 0;
        uVar18 = 0xb;
        uVar14 = __aFulmul((long)dy, CONCAT22(iVar13, iVar6));
        lVar16 = __aFldiv(uVar14, CONCAT22(uVar19, uVar18));
        iVar2 = (int)lVar16;
        iVar3 = ((prc->right - prc->left) - (int)lVar15 >> 1) + fDown;
        dyOffset = ((prc->bottom - prc->top) - iVar2 >> 1) + fDown;
        if ((uVar5 == 2) || (dxOffset = iVar3, uVar5 == 3)) {
            dxOffset = dyOffset;
            dyOffset = iVar3;
        }
        for (ipt = 0; ipt < cpt; ipt = ipt + 1) {
            if (uVar5 == 1) {
                rgptDraw[ipt].y = iVar2 - rgptDraw[ipt].y;
            }
            if ((uVar5 == 2) || (uVar5 == 3)) {
                iVar3 = (rgptDraw + ipt)->x;
                (rgptDraw + ipt)->x = rgptDraw[ipt].y;
                rgptDraw[ipt].y = (int)lVar15 - iVar3;
                if (uVar5 == 3) {
                    (rgptDraw + ipt)->x = iVar2 - (rgptDraw + ipt)->x;
                }
            }
            (rgptDraw + ipt)->x = (rgptDraw + ipt)->x + prc->left + dxOffset;
            rgptDraw[ipt].y = rgptDraw[ipt].y + prc->top + dyOffset;
        }
        hbrCur = hbrButtonHilite;
        if (fDisabled == 0) {
            hbrCur = hbrButtonText;
        }
        SelectObject(hdc, hbrCur);
        while (true) {
            if ((uVar5 == 0) || (uVar5 == 1)) {
                if (uVar5 == 0) {
                    iVar2 = -1;
                } else {
                    iVar2 = 1;
                }
                x = rgptDraw[1].x;
                dx = (rgptDraw[2].x - rgptDraw[1].x) + 1;
                y = rgptDraw[1].y;
                if (uVar8 != 0) {
                    PatBlt(hdc, rgptDraw[1].x, rgptDraw[cpt + -1].y, dx, 1, 0xf00021);
                }
                for (; 0 < dx; dx = dx + -2) {
                    PatBlt(hdc, x, y, dx, 1, 0xf00021);
                    x = x + 1;
                    y = y + iVar2;
                }
            } else {
                if (uVar5 == 2) {
                    iVar2 = -1;
                } else {
                    iVar2 = 1;
                }
                y = rgptDraw[2].y;
                dy = (rgptDraw[1].y - rgptDraw[2].y) + 1;
                x = rgptDraw[1].x;
                if (uVar8 != 0) {
                    PatBlt(hdc, (rgptDraw + cpt + -1)->x, rgptDraw[2].y, 1, dy, 0xf00021);
                }
                for (; 0 < dy; dy = dy + -2) {
                    PatBlt(hdc, x, y, 1, dy, 0xf00021);
                    y = y + 1;
                    x = x + iVar2;
                }
            }
            if ((bt & 0x20U) == 0) {
                sVar12 = rgptDraw[3].x;
                if (rgptDraw[4].x <= rgptDraw[3].x) {
                    sVar12 = rgptDraw[4].x;
                }
                sVar9 = rgptDraw[3].y;
                if (rgptDraw[4].y <= rgptDraw[3].y) {
                    sVar9 = rgptDraw[4].y;
                }
                sVar10 = rgptDraw[3].x;
                if (rgptDraw[3].x <= rgptDraw[4].x) {
                    sVar10 = rgptDraw[4].x;
                }
                sVar11 = rgptDraw[3].y;
                if (rgptDraw[3].y <= rgptDraw[4].y) {
                    sVar11 = rgptDraw[4].y;
                }
                SetRect(&rc, sVar12, sVar9, sVar10 + 1, sVar11 + 1);
                FillRect(hdc, &rc, hbrCur);
            }
            if (fDisabled == 0)
                break;
            for (ipt = 0; ipt < cpt; ipt = ipt + 1) {
                (rgptDraw + ipt)->x = (rgptDraw + ipt)->x + -1;
                rgptDraw[ipt].y = rgptDraw[ipt].y + -1;
            }
            fDisabled = 0;
            hbrCur = hbrButtonShadow;
            SelectObject(hdc, hbrButtonShadow);
        }
    }
    SelectObject(hdc, HVar1);
    if (szText != 0) {
        HVar1 = SelectObject(hdc, rghfontArial8[1]);
        sVar12 = SetBkMode(hdc, 1);
        uVar18 = (undefined2)crButtonHilite;
        uVar19 = crButtonHilite._2_2_;
        if (fDisabled == 0) {
            uVar18 = (undefined2)crButtonText;
            uVar19 = crButtonText._2_2_;
        }
        CVar17 = SetTextColor(hdc, CONCAT22(uVar19, uVar18));
        rc.left = prc->left;
        rc.top = prc->top;
        rc.right = prc->right;
        rc.bottom = prc->bottom;
        if (fDown != 0) {
            OffsetRc(&rc, 1, 1);
        }
        RcCtrTextOut(hdc, &rc, szText, 0);
        if (fDisabled != 0) {
            OffsetRc(&rc, -1, -1);
            SetTextColor(hdc, CONCAT22(crButtonShadow._2_2_, (undefined2)crButtonShadow));
            RcCtrTextOut(hdc, &rc, szText, 0);
        }
        SetTextColor(hdc, CVar17);
        SetBkMode(hdc, sVar12);
        SelectObject(hdc, HVar1);
    }
    return;
}

// ======================================================================
// Function: FGetMouseMove
// Address: 1040:4146
// Segment: MEMORY_UTILGEN
// ======================================================================

short FGetMouseMove(POINT *ppt)

{
    undefined2 *puVar1;
    BOOL        BVar2;
    undefined2 *puVar3;
    undefined2  uVar4;
    undefined2  unaff_SS;
    ulong       uVar5;
    MSG         msg;

    uVar4 = 0x1040;
    puVar1 = &stack0xffe6;
    do {
        puVar3 = puVar1;
        puVar3[-1] = unaff_SS;
        puVar3[-2] = &msg;
        puVar3[-3] = 0;
        puVar3[-4] = 0;
        puVar3[-5] = 0;
        puVar3[-6] = 1;
        puVar3[-7] = uVar4;
        uVar4 = 0x14f8;
        puVar3[-8] = 0x416e;
        BVar2 = PeekMessage(*(MSG **)(puVar3 + -2), puVar3[-3], puVar3[-4], puVar3[-5], puVar3[-6]);
        if (BVar2 == 0) {
            return 1;
        }
    } while ((msg.message != WM_MOUSEMOVE) && (puVar1 = puVar3 + 1, msg.message != WM_LBUTTONUP));
    ppt->x = (short)msg.lParam;
    *puVar3 = 0x14f8;
    puVar3[-1] = 0x419e;
    uVar5 = __aFulshr(*(ulong *)(puVar3 + 1), puVar3[3]);
    ppt->y = (short)uVar5;
    return (uint)(msg.message != WM_LBUTTONUP);
}

// ======================================================================
// Function: FGetRMouseMove
// Address: 1040:41e0
// Segment: MEMORY_UTILGEN
// ======================================================================

short FGetRMouseMove(POINT *ppt)

{
    undefined2 *puVar1;
    BOOL        BVar2;
    undefined2 *puVar3;
    undefined2  uVar4;
    undefined2  unaff_SS;
    ulong       uVar5;
    MSG         msg;

    uVar4 = 0x1040;
    puVar1 = &stack0xffe6;
    do {
        puVar3 = puVar1;
        puVar3[-1] = unaff_SS;
        puVar3[-2] = &msg;
        puVar3[-3] = 0;
        puVar3[-4] = 0;
        puVar3[-5] = 0;
        puVar3[-6] = 1;
        puVar3[-7] = uVar4;
        uVar4 = 0x14f8;
        puVar3[-8] = 0x4208;
        BVar2 = PeekMessage(*(MSG **)(puVar3 + -2), puVar3[-3], puVar3[-4], puVar3[-5], puVar3[-6]);
        if (BVar2 == 0) {
            return 1;
        }
    } while ((msg.message != WM_MOUSEMOVE) && (puVar1 = puVar3 + 1, msg.message != WM_RBUTTONUP));
    ppt->x = (short)msg.lParam;
    *puVar3 = 0x14f8;
    puVar3[-1] = 0x4238;
    uVar5 = __aFulshr(*(ulong *)(puVar3 + 1), puVar3[3]);
    ppt->y = (short)uVar5;
    return (uint)(msg.message != WM_RBUTTONUP);
}

// ======================================================================
// Function: DrawFuzzyBorder
// Address: 1040:427a
// Segment: MEMORY_UTILGEN
// ======================================================================

void DrawFuzzyBorder(HDC hdc, RECT *prc)

{
    HGDIOBJ  HVar1;
    int      iVar2;
    int      iVar3;
    COLORREF CVar4;
    COLORREF CVar5;
    COLORREF crFore;
    HBRUSH   hbrSav;
    short    dx;
    short    dy;
    COLORREF crBack;

    CVar4 = SetBkColor(hdc, CONCAT22(crButtonFace._2_2_, (undefined2)crButtonFace));
    CVar5 = SetTextColor(hdc, CONCAT22(crWindowText._2_2_, (undefined2)crWindowText));
    HVar1 = SelectObject(hdc, hbr50Screen);
    iVar2 = prc->right - prc->left;
    iVar3 = prc->bottom - prc->top;
    PatBlt(hdc, prc->left, prc->top, iVar2, 2, 0x5a0049);
    PatBlt(hdc, prc->left, prc->bottom + -2, iVar2, 2, 0x5a0049);
    PatBlt(hdc, prc->left, prc->top + 2, 2, iVar3 + -4, 0x5a0049);
    PatBlt(hdc, prc->right + -2, prc->top + 2, 2, iVar3 + -4, 0x5a0049);
    SelectObject(hdc, HVar1);
    SetTextColor(hdc, CVar5);
    SetBkColor(hdc, CVar4);
    return;
}

// ======================================================================
// Function: FStringFitsScreen
// Address: 1040:43aa
// Segment: MEMORY_UTILGEN
// ======================================================================

short FStringFitsScreen(char *lpsz, short dxMax)

{
    HDC     HVar1;
    HGDIOBJ HVar2;
    DWORD   DVar3;
    HFONT   hfontSav;
    short   fFit;
    short   c;
    HDC     hdc;

    fFit = 1;
    HVar1 = GetDC(hwndFrame);
    c = __fstrlen(lpsz);
    HVar2 = SelectObject(HVar1, rghfontArial8[0]);
    while ((0 < c && (DVar3 = GetTextExtent(HVar1, lpsz, c), (uint)dxMax < (uint)DVar3))) {
        fFit = 0;
        c = c + -1;
        ((char *)lpsz)[c] = '\0';
    }
    SelectObject(HVar1, HVar2);
    ReleaseDC(hwndFrame, HVar1);
    return fFit;
}

// ======================================================================
// Function: HbrGet
// Address: 1040:4448
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort HbrGet(COLORREF cr)

{
    ushort uVar1;
    HBRUSH hbr;
    short  i;
    short  iFree;

    iFree = -1;
    i = 0;
    do {
        if (chbrCache <= i) {
            uVar1 = CreateSolidBrush(cr);
            if (uVar1 == 0) {
                uVar1 = 0;
            } else {
                if (iFree == -1) {
                    if (0x1f < chbrCache) {
                        return uVar1;
                    }
                    iFree = chbrCache;
                    chbrCache = chbrCache + 1;
                }
                ((byte *)rghbrCacheUse)[iFree] = 1;
                ((ushort *)rghbrCache)[iFree] = uVar1;
                *(int *)((ulong *)rgcrCache + iFree) = (int)cr;
                *(int *)((int)(ulong *)rgcrCache + iFree * 4 + 2) = cr._2_2_;
            }
            return uVar1;
        }
        if (((byte *)rghbrCacheUse)[i] == 0) {
            iFree = i;
        } else if (((int)((ulong *)rgcrCache)[i] == (int)cr) && (*(int *)((int)(ulong *)rgcrCache + i * 4 + 2) == cr._2_2_)) {
            ((byte *)rghbrCacheUse)[i] = ((byte *)rghbrCacheUse)[i] + 1;
            return ((ushort *)rghbrCache)[i];
        }
        i = i + 1;
    } while (true);
}

// ======================================================================
// Function: FreeHbr
// Address: 1040:4532
// Segment: MEMORY_UTILGEN
// ======================================================================

void FreeHbr(HBRUSH hbr)

{
    short i;

    i = 0;
    do {
        if (chbrCache <= i) {
        UTILGEN_DeleteBrush:
            DeleteObject(hbr);
            return;
        }
        if ((((byte *)rghbrCacheUse)[i] != 0) && (hbr == ((ushort *)rghbrCache)[i])) {
            ((byte *)rghbrCacheUse)[i] = ((byte *)rghbrCacheUse)[i] - 1;
            if (((byte *)rghbrCacheUse)[i] != 0) {
                return;
            }
            goto UTILGEN_DeleteBrush;
        }
        i = i + 1;
    } while (true);
}

// ======================================================================
// Function: FCompressUserString
// Address: 1040:45a0
// Segment: MEMORY_UTILGEN
// ======================================================================

short FCompressUserString(char *szIn, char *szOut, short *pcOut)

{
    bool       bVar1;
    undefined2 unaff_SS;
    short      cNyb;
    char      *pchOut;
    short      iNyb;
    char       szWork[1024];
    short      fHalf;

    bVar1 = false;
    pchOut = szWork;
    do {
        if (*szIn == '\0') {
            if (bVar1) {
                *pchOut = *pchOut | 0xf;
                pchOut = pchOut + 1;
            }
            bVar1 = (int)pchOut - (int)szWork <= *pcOut;
            if (bVar1) {
                *pcOut = (int)pchOut - (int)szWork;
                __fmemcpy(szOut, szWork, *pcOut);
            }
            return (uint)bVar1;
        }
        iNyb = NybbleFromCh(*szIn);
        if (iNyb < 0xb) {
            cNyb = 1;
        } else if ((iNyb & 0xfU) == 0xf) {
            cNyb = 3;
        } else {
            cNyb = 2;
        }
        while (cNyb != 0) {
            if (bVar1) {
                *pchOut = *pchOut | (byte)iNyb & 0xf;
                pchOut = pchOut + 1;
                bVar1 = false;
                if (0x3ff < (int)pchOut - (int)szWork) {
                    return 0;
                }
            } else {
                *pchOut = (char)((iNyb & 0xfU) << 4);
                bVar1 = true;
            }
            iNyb = iNyb >> 4;
            cNyb = cNyb + -1;
        }
        szIn = (char *)szIn + 1;
    } while (true);
}

// ======================================================================
// Function: FDecompressUserString
// Address: 1040:46e8
// Segment: MEMORY_UTILGEN
// ======================================================================

short FDecompressUserString(char *szIn, short cIn, char *szOut, short *pcOut)

{
    bool       bVar1;
    short      sVar2;
    char       cVar3;
    uint       uVar4;
    undefined2 unaff_SS;
    char      *pchOut;
    short      iNyb;
    char       szWork[1024];
    short      fHalf;

    bVar1 = false;
    pchOut = szWork;
    while (0 < cIn) {
        if (bVar1) {
            iNyb = (int)*szIn & 0xf;
            cIn = cIn + -1;
            szIn = (char *)szIn + 1;
            if ((iNyb == 0xf) && (cIn == 0))
                break;
        } else {
            iNyb = (int)*szIn >> 4 & 0xf;
        }
        sVar2 = iNyb;
        bVar1 = !bVar1;
        if (10 < (uint)iNyb) {
            if (bVar1) {
                uVar4 = ((int)*szIn & 0xfU) << 4;
                cIn = cIn + -1;
                szIn = (char *)szIn + 1;
            } else {
                uVar4 = (int)*szIn & 0xf0;
            }
            iNyb = iNyb | uVar4;
            bVar1 = !bVar1;
            if (sVar2 == 0xf) {
                if (bVar1) {
                    uVar4 = ((int)*szIn & 0xfU) << 8;
                    cIn = cIn + -1;
                    szIn = (char *)szIn + 1;
                } else {
                    uVar4 = ((int)*szIn & 0xf0U) << 4;
                }
                iNyb = iNyb | uVar4;
                bVar1 = !bVar1;
            }
        }
        cVar3 = ChFromNybble(iNyb);
        *pchOut = cVar3;
        pchOut = pchOut + 1;
        if (*pcOut < (int)pchOut - (int)szWork) {
            return 0;
        }
    }
    *pchOut = '\0';
    __fstrcpy(szOut, szWork);
    return 1;
}

// ======================================================================
// Function: NybbleFromCh
// Address: 1040:4880
// Segment: MEMORY_UTILGEN
// ======================================================================

short NybbleFromCh(byte ch)

{
    char *pcVar1;
    uint  uVar2;
    char *pch;

    if ((ch < 0x61) || (0x7a < ch)) {
        if (ch == 0x20) {
            uVar2 = 0;
        } else if ((ch < 0x41) || (0x50 < ch)) {
            if ((ch < 0x51) || (0x5a < ch)) {
                if ((ch < 0x30) || (0x35 < ch)) {
                    if ((ch < 0x36) || (0x39 < ch)) {
                        pcVar1 = _strchr((char *)rgchcomp, (uint)ch);
                        if (pcVar1 == 0) {
                            uVar2 = (uint)ch << 4 | 0xf;
                        } else {
                            uVar2 = (int)(pcVar1 + -0x13fc) * 0x10 | 0xe;
                        }
                    } else {
                        uVar2 = (ch - 0x36) * 0x10 | 0xd;
                    }
                } else {
                    uVar2 = (ch - 0x26) * 0x10 | 0xc;
                }
            } else {
                uVar2 = (ch - 0x51) * 0x10 | 0xc;
            }
        } else {
            uVar2 = (ch - 0x41) * 0x10 | 0xb;
        }
    } else {
        uVar2 = ((short *)rgcompstrlower)[ch - 0x61];
    }
    return uVar2;
}

// ======================================================================
// Function: ChFromNybble
// Address: 1040:49ea
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

char ChFromNybble(short nyb)

{
    char  cVar1;
    int   iVar2;
    short iVal;
    short iPage;

    if (nyb < 0xb) {
        cVar1 = *(char *)(_rgchcompstrlower + nyb);
    } else if ((nyb & 0xfU) == 0xf) {
        cVar1 = (char)(nyb >> 4);
    } else {
        iVar2 = ((nyb & 0xfU) - 0xb) * 0x10 + (nyb >> 4);
        if (iVar2 < 0x1a) {
            cVar1 = (char)iVar2 + 'A';
        } else if (iVar2 < 0x24) {
            cVar1 = (char)iVar2 + '\x16';
        } else if (iVar2 < 0x34) {
            cVar1 = *(char *)(_rgchcompstrlower + iVar2 + -0x19);
        } else {
            cVar1 = *(char *)((int)(short *)(rgcompstrlower + 0xf) + iVar2);
        }
    }
    return cVar1;
}

// ======================================================================
// Function: DibNumColors
// Address: 1040:4a9a
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort DibNumColors(void *pv)

{
    void             *pvVar1;
    ushort            uVar2;
    BITMAPINFOHEADER *lpbi;
    BITMAPCOREHEADER *lpbc;
    short             bits;

    pvVar1 = (void *)pv;
    if ((*pv == 0xc) && (*(int *)((int)pvVar1 + 2) == 0)) {
        bits = *(short *)((int)pvVar1 + 10);
    } else {
        if ((*(int *)((int)pvVar1 + 0x20) != 0) || (*(int *)((int)pvVar1 + 0x22) != 0)) {
            return *(ushort *)((int)pvVar1 + 0x20);
        }
        bits = *(short *)((int)pvVar1 + 0xe);
    }
    if (bits == 1) {
        uVar2 = 2;
    } else if (bits == 4) {
        uVar2 = 0x10;
    } else if (bits == 8) {
        uVar2 = 0x100;
    } else {
        uVar2 = 0;
    }
    return uVar2;
}

// ======================================================================
// Function: HpalFromDib
// Address: 1040:4b50
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort HpalFromDib(HGLOBAL hdib)

{
    byte              bVar1;
    ushort            uVar2;
    LOGPALETTE       *pLVar3;
    char             *pv;
    LOGPALETTE       *ppal;
    BITMAPINFOHEADER *lpbi;
    char             *lpb;
    byte              bT;
    short             i;
    short             cColors;
    HPALETTE          hpal;

    pv = LockResource(hdib);
    if (pv == 0) {
        uVar2 = 0;
    } else {
        uVar2 = DibNumColors(pv);
        if ((int)uVar2 < 0x101) {
            pLVar3 = (LOGPALETTE *)LocalAlloc(0x40, uVar2 * 4 + 8);
            pLVar3->palNumEntries = uVar2;
            pLVar3->palVersion = 0x300;
            __fmemcpy(pLVar3->palPalEntry, (char *)CONCAT22((int)((ulong)pv >> 0x10), (char *)pv + 0x28), uVar2 << 2);
            for (i = 0; i < (int)uVar2; i = i + 1) {
                bVar1 = (pLVar3->palPalEntry + i)->peRed;
                (pLVar3->palPalEntry + i)->peRed = pLVar3->palPalEntry[i].peBlue;
                pLVar3->palPalEntry[i].peBlue = bVar1;
            }
            uVar2 = CreatePalette(pLVar3);
            LocalFree((HLOCAL)pLVar3);
            GlobalUnlock(hdib);
        } else {
            GlobalUnlock(hdib);
            uVar2 = 0;
        }
    }
    return uVar2;
}

// ======================================================================
// Function: HpalBlackReserved
// Address: 1040:4c9c
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort HpalBlackReserved(void)

{
    LOGPALETTE *pLVar1;
    HPALETTE    HVar2;
    LOGPALETTE *ppal;
    short       i;
    short       cColors;
    HPALETTE    hpal;

    pLVar1 = (LOGPALETTE *)LocalAlloc(0x40, 0x408);
    pLVar1->palNumEntries = 0x100;
    pLVar1->palVersion = 0x300;
    for (i = 0; i < 0x100; i = i + 1) {
        pLVar1->palPalEntry[i].peBlue = 0;
        pLVar1->palPalEntry[i].peGreen = 0;
        (pLVar1->palPalEntry + i)->peRed = 0;
        pLVar1->palPalEntry[i].peFlags = 1;
    }
    HVar2 = CreatePalette(pLVar1);
    LocalFree((HLOCAL)pLVar1);
    return HVar2;
}

// ======================================================================
// Function: PaletteSize
// Address: 1040:4d60
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort PaletteSize(void *pv)

{
    ushort            uVar1;
    BITMAPINFOHEADER *lpbi;
    ushort            NumColors;

    uVar1 = DibNumColors(pv);
    if ((*pv == 0xc) && (*(int *)((int)(void *)pv + 2) == 0)) {
        uVar1 = uVar1 * 3;
    } else {
        uVar1 = uVar1 << 2;
    }
    return uVar1;
}

// ======================================================================
// Function: DibBlt
// Address: 1040:4db8
// Segment: MEMORY_UTILGEN
// ======================================================================

short DibBlt(HDC hdc, short x0, short y0, short dx, short dy, HGLOBAL hdib, short x1, short y1, short dxSrc, short dySrc, long rop)

{
    ulong             uVar1;
    ushort            uVar2;
    short             sVar3;
    int               iVar4;
    BITMAPINFO       *pv;
    BITMAPINFOHEADER *lpbi;
    char             *pBuf;

    if (hdib == 0) {
        sVar3 = PatBlt(hdc, x0, y0, dx, dy, rop);
    } else {
        pv = GlobalLock(hdib);
        iVar4 = (int)((ulong)pv >> 0x10);
        if (((BITMAPINFO *)pv == 0) && (iVar4 == 0)) {
            sVar3 = 0;
        } else {
            uVar1 = (pv->bmiHeader).biSize;
            uVar2 = PaletteSize(pv);
            StretchDIBits(hdc, x0, y0, dx, dy, x1, y1, dxSrc, dySrc,
                          (void *)CONCAT22(iVar4, (void *)((int)&((((BITMAPINFO *)pv)->bmiColors + -10)->bmiHeader).biSize + uVar2 + (int)uVar1)), pv, 0, rop);
            GlobalUnlock(hdib);
            sVar3 = 1;
        }
    }
    return sVar3;
}

// ======================================================================
// Function: DibFromBitmap
// Address: 1040:4e90
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort DibFromBitmap(HBITMAP hbm, ulong biStyle, ushort biBits, HPALETTE hpal)

{
    BITMAPINFOHEADER *pBVar1;
    BITMAPINFO       *pBVar2;
    ushort            uVar3;
    int               iVar4;
    HDC               HVar5;
    HPALETTE          HVar6;
    HGLOBAL           HVar7;
    ushort            uVar8;
    short             sVar9;
    int               iVar10;
    BITMAPINFOHEADER *pBVar11;
    BITMAPINFO       *pBVar12;
    ushort            unaff_DI;
    BITMAPINFO       *pBVar13;
    undefined2        unaff_SS;
    BITMAPINFO       *pBVar14;
    ulong             uVar15;
    undefined2        uVar16;
    UINT              UVar17;
    undefined2        uVar18;
    UINT              UVar19;
    HDC               HVar20;
    BITMAPINFOHEADER *lpbi;
    HGLOBAL           hdib;
    BITMAPINFOHEADER  bi;
    BITMAP            bm;
    ulong             dwLen;
    ushort            h;
    HDC               hdc;

    if (hbm == 0) {
        uVar3 = 0;
    } else {
        if (hpal == 0) {
            hpal = GetStockObject(0xf);
        }
        GetObject(hbm, 0xe, &bm);
        if (biBits == 0) {
            biBits = (uint)bm.bmPlanes * (uint)bm.bmBitsPixel;
        }
        bi.biSize._0_2_ = 0x28;
        bi.biSize._2_2_ = 0;
        bi.biWidth._2_2_ = bm.bmWidth >> 0xf;
        bi.biWidth._0_2_ = bm.bmWidth;
        bi.biHeight._2_2_ = bm.bmHeight >> 0xf;
        bi.biHeight._0_2_ = bm.bmHeight;
        bi.biPlanes = 1;
        bi.biBitCount = biBits;
        bi.biSizeImage._0_2_ = 0;
        bi.biSizeImage._2_2_ = 0;
        bi.biXPelsPerMeter._0_2_ = 0;
        bi.biXPelsPerMeter._2_2_ = 0;
        bi.biYPelsPerMeter._0_2_ = 0;
        bi.biYPelsPerMeter._2_2_ = 0;
        bi.biClrUsed._0_2_ = 0;
        bi.biClrUsed._2_2_ = 0;
        bi.biClrImportant._0_2_ = 0;
        bi.biClrImportant._2_2_ = 0;
        bi.biCompression = biStyle;
        uVar3 = PaletteSize(&bi);
        iVar4 = uVar3 + (uint)bi.biSize;
        iVar10 = bi.biSize._2_2_ + (uint)CARRY2(uVar3, (uint)bi.biSize);
        HVar5 = GetDC(0);
        HVar6 = SelectPalette(HVar5, hpal, 0);
        RealizePalette(HVar5);
        HVar7 = GlobalAlloc(0x42, CONCAT22(iVar10, iVar4));
        if (HVar7 == 0) {
            SelectPalette(HVar5, HVar6, 0);
            ReleaseDC(0, HVar5);
            uVar3 = 0;
        } else {
            pBVar14 = GlobalLock(HVar7);
            uVar16 = (undefined2)((ulong)pBVar14 >> 0x10);
            pBVar12 = (BITMAPINFO *)pBVar14;
            pBVar11 = &bi;
            pBVar13 = pBVar12;
            for (iVar4 = 0x14; iVar4 != 0; iVar4 = iVar4 + -1) {
                pBVar2 = pBVar13;
                pBVar13 = (BITMAPINFO *)((int)&(pBVar13->bmiHeader).biSize + 2);
                pBVar1 = pBVar11;
                pBVar11 = (BITMAPINFOHEADER *)((int)&pBVar11->biSize + 2);
                *&(pBVar2->bmiHeader).biSize = (int)pBVar1->biSize;
            }
            GetDIBits(HVar5, hbm, 0, (UINT)bi.biHeight, 0, pBVar14, 0);
            pBVar11 = &bi;
            for (iVar4 = 0x14; iVar4 != 0; iVar4 = iVar4 + -1) {
                pBVar1 = pBVar11;
                pBVar11 = (BITMAPINFOHEADER *)((int)&pBVar11->biSize + 2);
                pBVar14 = pBVar12;
                pBVar12 = (BITMAPINFO *)((int)&(pBVar12->bmiHeader).biSize + 2);
                *&pBVar1->biSize = (int)(pBVar14->bmiHeader).biSize;
            }
            GlobalUnlock(HVar7);
            if (((int)bi.biSizeImage == 0) && (bi.biSizeImage = CONCAT22(bi.biSizeImage._2_2_, (int)bi.biSizeImage), bi.biSizeImage._2_2_ == 0)) {
                iVar4 = bm.bmHeight >> 0xf;
                uVar18 = 0;
                uVar16 = 0x20;
                uVar15 = __aFulmul((long)bm.bmWidth, (ulong)biBits);
                __aFuldiv(uVar15 + 0x1f, CONCAT22(uVar18, uVar16));
                uVar15 = __aFlshl(CONCAT22(iVar4, bm.bmHeight), unaff_DI);
                bi.biSizeImage = __aFulmul(uVar15, CONCAT22(iVar4, bm.bmHeight));
                if (biStyle != 0) {
                    uVar18 = 0;
                    uVar16 = 2;
                    uVar15 = __aFulmul(bi.biSizeImage, 3);
                    uVar15 = __aFuldiv(uVar15, CONCAT22(uVar18, uVar16));
                    bi.biSizeImage = uVar15;
                }
            }
            uVar3 = PaletteSize(&bi);
            uVar3 = GlobalReAlloc(HVar7, bi.biSizeImage + CONCAT22(bi.biSize._2_2_ + (uint)CARRY2(uVar3, (uint)bi.biSize), uVar3 + (uint)bi.biSize), 0);
            if (uVar3 == 0) {
                GlobalFree(HVar7);
                SelectPalette(HVar5, HVar6, 0);
                ReleaseDC(0, HVar5);
                uVar3 = 0;
            } else {
                pBVar14 = GlobalLock(uVar3);
                uVar16 = (undefined2)((ulong)pBVar14 >> 0x10);
                pBVar12 = (BITMAPINFO *)pBVar14;
                UVar19 = 0;
                uVar15 = (pBVar14->bmiHeader).biSize;
                UVar17 = (UINT)bi.biHeight;
                HVar20 = HVar5;
                uVar8 = PaletteSize(pBVar14);
                sVar9 = GetDIBits(HVar20, hbm, UVar19, UVar17,
                                  (void *)CONCAT22(uVar16, (void *)((int)&((pBVar12->bmiColors + -10)->bmiHeader).biSize + uVar8 + (int)uVar15)), pBVar14, 0);
                if (sVar9 == 0) {
                    GlobalUnlock(uVar3);
                    SelectPalette(HVar5, HVar6, 0);
                    ReleaseDC(0, HVar5);
                    uVar3 = 0;
                } else {
                    pBVar11 = &bi;
                    for (iVar4 = 0x14; iVar4 != 0; iVar4 = iVar4 + -1) {
                        pBVar1 = pBVar11;
                        pBVar11 = (BITMAPINFOHEADER *)((int)&pBVar11->biSize + 2);
                        pBVar14 = pBVar12;
                        pBVar12 = (BITMAPINFO *)((int)&(pBVar12->bmiHeader).biSize + 2);
                        *&pBVar1->biSize = (int)(pBVar14->bmiHeader).biSize;
                    }
                    GlobalUnlock(uVar3);
                    SelectPalette(HVar5, HVar6, 0);
                    ReleaseDC(0, HVar5);
                }
            }
        }
    }
    return uVar3;
}

// ======================================================================
// Function: HdibLoadBigResource
// Address: 1040:5220
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort HdibLoadBigResource(short idb)

{
    HRSRC   HVar1;
    HGLOBAL HVar2;
    HFILE   hFile;
    short   sVar3;
    char   *lpBuffer;
    DWORD   dwSize;
    HGLOBAL hdib;
    short   hfile;
    char   *lpstr;
    ushort  hrsrc;

    HVar1 = FindResource(hInst, (LPCSTR)(ulong)(uint)idb, (LPCSTR)0x2);
    if ((HVar1 != 0) && (HVar2 = AllocResource(hInst, HVar1, 0), HVar2 != 0)) {
        hFile = AccessResource(hInst, HVar1);
        if (hFile != 0xffff) {
            lpBuffer = LockResource(HVar2);
            if (lpBuffer != 0) {
                dwSize = SizeofResource(hInst, HVar1);
                sVar3 = ReadBigBlock(hFile, lpBuffer, dwSize);
                if (sVar3 != 0) {
                    _lclose(hFile);
                    return HVar2;
                }
            }
            _lclose(hFile);
        }
        FreeResource(HVar2);
    }
    return 0;
}

// ======================================================================
// Function: ReadBigBlock
// Address: 1040:5310
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x1040532e) */

short ReadBigBlock(short hFile, char *lpBuffer, ulong dwSize)

{
    uint  uVar1;
    UINT  UVar2;
    char *lpInBuf;
    short nBytes;

    while (true) {
        lpInBuf._2_2_ = (undefined2)((ulong)lpBuffer >> 0x10);
        lpInBuf._0_2_ = (char *)lpBuffer;
        if (((uint)dwSize == 0) && (dwSize._2_2_ == 0)) {
            return 1;
        }
        if ((dwSize._2_2_ != 0) || (uVar1 = (uint)dwSize, 30000 < (uint)dwSize)) {
            uVar1 = 30000;
        }
        UVar2 = _lread(hFile, lpBuffer, uVar1);
        if (UVar2 != uVar1)
            break;
        dwSize = CONCAT22((dwSize._2_2_ - ((int)uVar1 >> 0xf)) - (uint)((uint)dwSize < uVar1), (uint)dwSize - uVar1);
        lpBuffer = (char *)CONCAT22(lpInBuf._2_2_, (char *)lpInBuf + uVar1);
    }
    return 0;
}

// ======================================================================
// Function: FIntersectCircleLine
// Address: 1040:53b4
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x10405762) */
/* WARNING: Removing unreachable block (ram,0x104057b5) */
/* WARNING: Removing unreachable block (ram,0x1040562c) */
/* WARNING: Removing unreachable block (ram,0x10405791) */
/* WARNING: Removing unreachable block (ram,0x10405733) */

short FIntersectCircleLine(POINT ptL1, POINT ptL2, POINT ptC, long r2, short dMax, short *pdStart, short *pdEnd)

{
    uint       uVar1;
    int        iVar2;
    int        iVar3;
    short      sVar4;
    int        iVar5;
    int        iVar6;
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    ulong      uVar7;
    ulong      uVar8;
    ulong      uVar9;
    long       lVar10;
    long       lVar11;
    long       lVar12;
    long       lVar13;
    undefined8 uVar14;
    int        in_stack_0000ff9c;
    int        in_stack_0000ff9e;
    double     dxI;
    long       r2I;
    long       xI;
    long       dx;
    short      dOff;
    long       dx2;
    long       lT;
    long       dxT;
    long       dyI;
    long       yI;
    long       dy;
    long       dy2;
    short      dCtr;
    long       dxdy;
    long       dyT;

    iVar2 = ptL2.x - ptL1.x;
    iVar3 = ptL2.y - ptL1.y;
    uVar7 = __aFulmul((ulong)CONCAT62(CONCAT42((long)iVar3, iVar2 >> 0xf), iVar2), (long)iVar3);
    uVar8 = __aFulmul((ulong)CONCAT62(CONCAT42((long)iVar2, iVar2 >> 0xf), iVar2), (long)iVar2);
    iVar5 = (int)(uVar8 >> 0x10);
    uVar9 = __aFulmul((ulong)CONCAT62(CONCAT42((long)iVar3, iVar3 >> 0xf), iVar3), (long)iVar3);
    iVar6 = (int)(uVar9 >> 0x10);
    uVar1 = (uint)uVar9;
    dx2._0_2_ = (uint)uVar8;
    if ((((long)uVar7 < 0x80000) && (((((int)(uVar7 >> 0x10) < 7 || ((uint)uVar7 < 0xa121)) && (iVar5 < 8)) && ((iVar5 < 7 || ((uint)dx2 < 0xa121)))))) &&
        ((iVar6 < 7 || ((iVar6 < 8 && (uVar1 < 0xa121)))))) {
        uVar14 = CONCAT62(CONCAT42(CONCAT22(iVar5 + iVar6 + (uint)CARRY2((uint)dx2, uVar1), (uint)dx2 + uVar1), ptL1.x >> 0xf), ptL1.x);
        uVar9 = __aFulmul(uVar9, (ulong)uVar14);
        uVar14 = CONCAT62(CONCAT42((long)((ulonglong)uVar14 >> 0x20), ptC.x >> 0xf), ptC.x);
        uVar8 = __aFulmul(uVar8, (ulong)uVar14);
        uVar14 = CONCAT62(CONCAT42((long)((ulonglong)uVar14 >> 0x20), ptC.y - ptL1.y >> 0xf), ptC.y - ptL1.y);
        uVar7 = __aFulmul(uVar7, (ulong)uVar14);
        lVar10 = uVar7 + uVar8 + uVar9;
        lVar11 = (long)((ulonglong)uVar14 >> 0x20);
        lVar10 = __aFldiv((long)CONCAT62(CONCAT42(lVar11, (int)((ulong)lVar10 >> 0x10)), (int)lVar10), lVar11);
    } else {
        in_stack_0000ff9c = (uint)dx2 + uVar1;
        in_stack_0000ff9e = iVar5 + iVar6 + (uint)CARRY2((uint)dx2, uVar1);
        lVar10 = __ftol((double)CONCAT26(in_stack_0000ff9e, CONCAT24(in_stack_0000ff9c, CONCAT22(unaff_SI, unaff_DI))));
    }
    if (iVar2 == 0) {
        lVar11 = (long)ptL1.y;
    } else {
        uVar14 = CONCAT62(CONCAT42((long)iVar2, iVar3 >> 0xf), iVar3);
        uVar7 = __aFulmul(lVar10 - ptL1.x, (ulong)uVar14);
        lVar11 = (long)((ulonglong)uVar14 >> 0x20);
        lVar11 = __aFldiv((long)CONCAT62(CONCAT42(lVar11, (int)(uVar7 >> 0x10)), (int)uVar7), lVar11);
        lVar11 = lVar11 + ptL1.y;
    }
    uVar7 = __aFulmul((ulong)CONCAT62(CONCAT42(lVar11 - ptC.y, (int)((ulong)(lVar11 - ptC.y) >> 0x10)), (int)(lVar11 - ptC.y)), lVar11 - ptC.y);
    uVar8 = __aFulmul((ulong)CONCAT62(CONCAT42(lVar10 - ptC.x, (int)((ulong)(lVar10 - ptC.x) >> 0x10)), (int)(lVar10 - ptC.x)), lVar10 - ptC.x);
    lVar13 = uVar8 + uVar7;
    if (lVar13 < r2) {
        uVar7 = __aFulmul((ulong)CONCAT62(CONCAT42(lVar11 - ptL1.y, (int)((ulong)(lVar11 - ptL1.y) >> 0x10)), (int)(lVar11 - ptL1.y)), lVar11 - ptL1.y);
        uVar8 = __aFulmul((ulong)CONCAT62(CONCAT42(lVar10 - ptL1.x, (int)((ulong)(lVar10 - ptL1.x) >> 0x10)), (int)(lVar10 - ptL1.x)), lVar10 - ptL1.x);
        _sqrt((double)(long)(uVar8 + uVar7));
        lVar12 = __ftol((double)CONCAT26(in_stack_0000ff9e, CONCAT24(in_stack_0000ff9c, CONCAT22(unaff_SI, unaff_DI))));
        dCtr = (short)lVar12;
        lT = r2 - lVar13;
        if (((int)((ulong)(r2 - lVar13) >> 0x10) < 1) && ((r2 - lVar13 < 0 || ((int)r2 == (int)lVar13)))) {
            sVar4 = 0;
        } else {
            _sqrt((double)lT);
            lVar13 = __ftol((double)CONCAT26(in_stack_0000ff9e, CONCAT24(in_stack_0000ff9c, CONCAT22(unaff_SI, unaff_DI))));
            iVar2 = (int)lVar13;
            if (ptL1.x < ptL2.x) {
                if (lVar10 < ptL1.x) {
                    dCtr = -dCtr;
                }
            } else if (ptL2.x < ptL1.x) {
                if (ptL1.x < lVar10) {
                    dCtr = -dCtr;
                }
            } else if (ptL1.y < ptL2.y) {
                if (lVar11 < ptL1.y) {
                    dCtr = -dCtr;
                }
            } else if (ptL1.y < lVar11) {
                dCtr = -dCtr;
            }
            if ((uint)(dCtr - iVar2) < 0x8000) {
                iVar3 = dCtr - iVar2;
            } else {
                iVar3 = 0;
            }
            *pdStart = iVar3;
            iVar3 = dMax;
            if (dCtr + iVar2 <= dMax) {
                iVar3 = dCtr + iVar2;
            }
            *pdEnd = iVar3;
            if ((*pdEnd < 1) || (dMax <= *pdStart)) {
                sVar4 = 0;
            } else {
                sVar4 = 1;
            }
        }
    } else {
        sVar4 = 0;
    }
    return sVar4;
}

// ======================================================================
// Function: IntToRoman
// Address: 1040:5830
// Segment: MEMORY_UTILGEN
// ======================================================================

void IntToRoman(short i, char *pszOut)

{
    char *pcVar1;

    if (i < 1) {
        *pszOut = '\0';
    } else {
        for (; 9 < i; i = i + -10) {
            *pszOut = 'X';
            pszOut = pszOut + 1;
        }
        if (i == 9) {
            pcVar1 = pszOut + 1;
            *pszOut = 'I';
            pszOut = pszOut + 2;
            *pcVar1 = 'X';
        } else {
            if (3 < i) {
                if (i == 4) {
                    *pszOut = 'I';
                    pszOut = pszOut + 1;
                }
                *pszOut = 'V';
                i = i + -5;
                pszOut = pszOut + 1;
            }
            while (0 < i) {
                *pszOut = 'I';
                i = i + -1;
                pszOut = pszOut + 1;
            }
        }
        *pszOut = '\0';
    }
    return;
}

// ======================================================================
// Function: FCheckPassword
// Address: 1040:58d8
// Segment: MEMORY_UTILGEN
// ======================================================================

short FCheckPassword(void)

{
    HWND       hWndParent;
    short      sVar1;
    long       lVar2;
    FARPROC    lpDlgProc;
    long       lSaltDef;
    short      fRet;
    fn_lpProc *lpProc;

    if (((((int)lSaltCur == 0) && (lSaltCur._2_2_ == 0)) || (((int)lSaltLast == (int)lSaltCur && (lSaltLast._2_2_ == lSaltCur._2_2_)))) || (fAi != 0)) {
        sVar1 = 1;
    } else if ((vszDefPass[0] == '\0') || (lVar2 = LSaltFromSz((char *)vszDefPass), lVar2 != CONCAT22(lSaltCur._2_2_, (int)lSaltCur))) {
        if ((ini.wFlags >> 0xe & 1) == 0) {
            lpDlgProc = MakeProcInstance(PasswordDlg, hInst);
            hWndParent = hwndTitle;
            if (hwndTitle == 0) {
                hWndParent = hwndFrame;
            }
            sVar1 = DialogBox(0, IDD_PASSWORD, hWndParent, lpDlgProc);
            FreeProcInstance(lpDlgProc);
        } else {
            sVar1 = 0;
        }
    } else {
        sVar1 = 1;
    }
    return sVar1;
}

// ======================================================================
// Function: LSaltFromSz
// Address: 1040:59ce
// Segment: MEMORY_UTILGEN
// ======================================================================

long LSaltFromSz(char *psz)

{
    char *pcVar1;
    ulong uVar2;
    long  lSalt;

    uVar2 = 0;
    pcVar1 = psz;
    if (*psz == '\0') {
        uVar2 = 0;
    } else {
        while (psz = pcVar1, *psz != '\0') {
            uVar2 = uVar2 + (long)(int)*psz;
            pcVar1 = psz + 1;
            if (*pcVar1 != '\0') {
                uVar2 = __aFulmul(uVar2, (long)(int)*pcVar1);
                pcVar1 = psz + 2;
            }
        }
        if (uVar2 == 0) {
            uVar2 = 1;
        }
    }
    return uVar2;
}

// ======================================================================
// Function: PasswordDlg
// Address: 1040:5a72
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Variable defined which should be unmapped: lSalt */

short PasswordDlg(HWND hwnd, WMType message, ushort wParam, long lParam)

{
    HWND       HVar1;
    char      *pcVar2;
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    undefined2 unaff_SS;
    ulong      uVar3;
    long       lVar4;
    short      mbType;
    long       lSalt;
    RECT       rc;
    char       szPass[60];

    if (message == WM_ERASEBKGND) {
        GetClientRect(hwnd, &rc);
        FillRect(wParam, &rc, hbrButtonFace);
        return 1;
    }
    if (message == WM_CTLCOLOR) {
        uVar3 = __aFulshr(CONCAT22(unaff_SI, unaff_DI), (ushort)lSalt);
        if ((int)uVar3 == 6) {
            SetBkColor(wParam, CONCAT22(crButtonFace._2_2_, (undefined2)crButtonFace));
            return hbrButtonFace;
        }
    } else {
        if (message == WM_INITDIALOG) {
            SendDlgItemMessage(hwnd, 0x10c, 0x415, 0xf, 0);
            HVar1 = GetDlgItem(hwnd, IDC_U16_0x07E2);
            pcVar2 = PszGetCompressedString(idsEnterPassword);
            SetWindowText(HVar1, pcVar2);
            return 1;
        }
        if (message == WM_COMMAND) {
            if ((wParam == 1) || (wParam == 2)) {
                if (wParam == 1) {
                    GetDlgItemText(hwnd, IDC_EDITTEXT, szPass, 0x3c);
                    lVar4 = LSaltFromSz(szPass);
                    if (lVar4 != CONCAT22(lSaltCur._2_2_, (undefined2)lSaltCur)) {
                        vcPasswordFailures = vcPasswordFailures + 1;
                        if (vcPasswordFailures < 10) {
                            pcVar2 = (char *)0x3e8;
                        } else if (vcPasswordFailures < 100) {
                            pcVar2 = (char *)"Stars!" + 3;
                        } else {
                            pcVar2 = (char *)0x2710;
                        }
                        Delay((short)pcVar2);
                        mbType = 0x10;
                        pcVar2 = PszFormatIds(idsPasswordHaveEnteredIncorrectPleaseTry, 0);
                        AlertSz(pcVar2, mbType);
                        HVar1 = GetDlgItem(hwnd, IDC_EDITTEXT);
                        SetFocus(HVar1);
                        SendDlgItemMessage(hwnd, 0x10c, 0x401, 0, -0x10000);
                        return 0;
                    }
                    if (((uint)gd.grBits2 >> 9 & 1) == 0) {
                        lSaltLast._0_2_ = (undefined2)lSaltCur;
                        lSaltLast._2_2_ = lSaltCur._2_2_;
                        _strcpy((char *)szPassLast, szPass);
                    }
                }
                EndDialog(hwnd, (uint)(wParam == 1));
                return 1;
            }
            if (wParam == 0x76) {
                WinHelp(hwnd, szHelpFile, 1, 0x441);
                return 1;
            }
        }
    }
    return 0;
}

// ======================================================================
// Function: NewPasswordDlg
// Address: 1040:5cba
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Variable defined which should be unmapped: lSalt */

short NewPasswordDlg(HWND hwnd, WMType message, ushort wParam, long lParam)

{
    long        lVar1;
    long        lVar2;
    HWND        HVar3;
    char       *pcVar4;
    HBRUSH      HVar5;
    undefined1 *puVar6;
    undefined2  unaff_SI;
    undefined2  unaff_DI;
    undefined2  uVar7;
    undefined2  unaff_SS;
    ulong       uVar8;
    short       sVar9;
    long        lSalt;
    long        lSalt2;
    RECT        rc;
    char        szPass[20];

    uVar7 = 0x1040;
    puVar6 = &stack0xffd4;
    if (message == WM_ERASEBKGND) {
        GetClientRect(hwnd, &rc);
        FillRect(wParam, &rc, hbrButtonFace);
        HVar5 = 1;
        lVar1 = lSaltLast;
        lVar2 = lSaltCur;
        goto LAB_1040_5fb7;
    }
    if (message == WM_CTLCOLOR) {
        uVar8 = __aFulshr(CONCAT22(unaff_SI, unaff_DI), (ushort)lSalt);
        if ((int)uVar8 == 6) {
            SetBkColor(wParam, CONCAT22(crButtonFace._2_2_, (undefined2)crButtonFace));
            HVar5 = hbrButtonFace;
            lVar1 = lSaltLast;
            lVar2 = lSaltCur;
            goto LAB_1040_5fb7;
        }
    } else {
        if (message == WM_INITDIALOG) {
            SendDlgItemMessage(hwnd, 0x10c, 0x415, 0x10, 0);
            SendDlgItemMessage(hwnd, 0x10d, 0x415, 0x10, 0);
            if (idPlayer == -1) {
                HVar3 = GetDlgItem(hwnd, IDC_U16_0x07E2);
                pcVar4 = PszGetCompressedString(idsNotePasswordEffectiveImmediately);
                SetWindowText(HVar3, pcVar4);
                pcVar4 = PszGetCompressedString(idsChangeHostPassword);
                SetWindowText(hwnd, pcVar4);
            } else {
                HVar3 = GetDlgItem(hwnd, IDC_U16_0x07E2);
                pcVar4 = PszGetCompressedString(idsNoteNewPasswordWillTakeEffectUntil);
                SetWindowText(HVar3, pcVar4);
            }
            HVar5 = 1;
            lVar1 = lSaltLast;
            lVar2 = lSaltCur;
            goto LAB_1040_5fb7;
        }
        if (message == WM_COMMAND) {
            if ((wParam == 1) || (wParam == 2)) {
                lVar1 = lSaltLast;
                if (wParam == 1) {
                    HVar3 = GetDlgItem(hwnd, IDC_EDITTEXT);
                    GetWindowText(HVar3, szPass, 0x12);
                    lSalt = LSaltFromSz(szPass);
                    HVar3 = GetDlgItem(hwnd, IDC_U16_0x010D);
                    GetWindowText(HVar3, szPass, 0x12);
                    lSalt2 = LSaltFromSz(szPass);
                    if (lSalt2 != lSalt) {
                        sVar9 = 0x10;
                        pcVar4 = PszFormatIds(idsPasswordsTypedTwoFieldsSamePleaseReenter, 0);
                        AlertSz(pcVar4, sVar9);
                        HVar3 = GetDlgItem(hwnd, IDC_EDITTEXT);
                        SetFocus(HVar3);
                        SendDlgItemMessage(hwnd, 0x10c, 0x401, 0, -0x10000);
                        goto LAB_1040_5fb1;
                    }
                    if (idPlayer == -1) {
                        uVar7 = 0x1070;
                        lSaltCur = lSalt;
                        sVar9 = FWriteDataFile((char *)szBase, -1, 0);
                        puVar6 = &stack0xffc4;
                        lVar1 = lSalt;
                        if (sVar9 == 0) {
                            sVar9 = 0x10;
                            pcVar4 = PszFormatIds(idsUnableCreateHostFile, 0);
                            uVar7 = 0x1040;
                            AlertSz(pcVar4, sVar9);
                            puVar6 = &stack0xffc4;
                            lVar1 = lSaltLast;
                            lSaltCur = lSaltLast;
                        }
                    } else {
                        uVar7 = 0x1048;
                        WriteMemRt(0x24, 4, &lSalt);
                        puVar6 = &stack0xffc4;
                        lVar1 = lSaltLast;
                    }
                }
                *(HWND *)(puVar6 + -2) = hwnd;
                *(uint *)(puVar6 + -4) = (uint)(wParam == 1);
                *(undefined2 *)(puVar6 + -6) = uVar7;
                *(undefined2 *)(puVar6 + -8) = 0x5f55;
                lSaltLast = lVar1;
                EndDialog(*(HWND *)(puVar6 + -2), *(short *)(puVar6 + -4));
                HVar5 = 1;
                lVar1 = lSaltLast;
                lVar2 = lSaltCur;
                goto LAB_1040_5fb7;
            }
            if (wParam == 0x76) {
                WinHelp(hwnd, szHelpFile, 1, 0x43c);
                HVar5 = 1;
                lVar1 = lSaltLast;
                lVar2 = lSaltCur;
                goto LAB_1040_5fb7;
            }
        }
    }
LAB_1040_5fb1:
    HVar5 = 0;
    lVar1 = lSaltLast;
    lVar2 = lSaltCur;
LAB_1040_5fb7:
    lSaltCur._2_2_ = (undefined2)((ulong)lVar2 >> 0x10);
    lSaltCur._0_2_ = (undefined2)lVar2;
    lSaltLast._2_2_ = (undefined2)((ulong)lVar1 >> 0x10);
    lSaltLast._0_2_ = (undefined2)lVar1;
    return HVar5;
}

// ======================================================================
// Function: GetDiskSerialNumber
// Address: 1040:5fc0
// Segment: MEMORY_UTILGEN
// ======================================================================

/* WARNING: Removing unreachable block (ram,0x104062b2) */
/* WARNING: Removing unreachable block (ram,0x1040631f) */

ulong GetDiskSerialNumber(void)

{
    int        iVar1;
    UINT       UVar2;
    ushort     uVar3;
    undefined2 unaff_SI;
    undefined2 unaff_DI;
    long       lVar4;
    ulong      uVar5;
    long       lVar6;
    uint       in_stack_0000ffa6;
    DISKFREE_T df;
    long       l;
    ushort     uDate;
    byte       uDefault;
    short      iWork;
    short      i;
    FIND_T     fi;
    char       fn[13];
    short      drive;
    short      j;

    lVar6 = CONCAT22(unaff_SI, unaff_DI);
    iWork = 0;
    _memset((byte_0_ *)&vrgbEnvCur, 0, 0xb);
    CchGetString(idsC, fn);
    for (i = 0; i < 2; i = i + 1) {
        fn[0] = (char)i + 'C';
        l._0_2_ = 0;
        UVar2 = GetDriveType(i + 2);
        if ((UVar2 == 3) && (uVar3 = __dos_findfirst(fn, 8, &fi), uVar3 == 0)) {
            for (j = 0; (j < 8 && (fi.name[j] != '\0')); j = j + 1) {
                if (i == 0) {
                    in_stack_0000ffa6 = (int)fi.name[j] & 0xf;
                    lVar4 = __aFlshl(lVar6, in_stack_0000ffa6);
                    l._0_2_ = (uint)lVar4 | in_stack_0000ffa6;
                } else {
                    in_stack_0000ffa6 = (int)fi.name[j] & 7;
                    lVar4 = __aFlshl(lVar6, in_stack_0000ffa6);
                    l._0_2_ = (uint)lVar4 | in_stack_0000ffa6;
                }
            }
            if (i == 0) {
                uDate = fi.wr_date << 0xc | (fi.wr_date >> 5 & 7) << 9 | (fi.wr_time & 0xf) << 5 | (fi.wr_time >> 5 & 0xf) << 1 | fi.wr_time >> 0xb & 1;
            } else {
                uDate = (fi.wr_date & 3) << 6 | (fi.wr_time & 7) << 3 | fi.wr_time >> 5 & 7;
            }
        } else {
            uDate = 0xc57a;
            l._0_1_ = 0xa5;
        }
        ((byte_0_ *)&vrgbEnvCur)[iWork] = (undefined1)l;
        lVar4 = __aFlshr(lVar6, in_stack_0000ffa6);
        *(undefined1 *)(iWork + 0x5469) = (char)lVar4;
        lVar4 = __aFlshr(lVar6, in_stack_0000ffa6);
        *(undefined1 *)(iWork + 0x546a) = (char)lVar4;
        iVar1 = iWork + 3;
        if (i == 0) {
            lVar4 = __aFlshr(lVar6, in_stack_0000ffa6);
            *(undefined1 *)(iWork + 0x546b) = (char)lVar4;
            iVar1 = iWork + 4;
        }
        iWork = iVar1;
        ((byte_0_ *)&vrgbEnvCur)[iWork] = (char)uDate;
        iVar1 = iWork + 1;
        if (i == 0) {
            *(undefined1 *)(iWork + 0x5469) = (char)(uDate >> 8);
            iVar1 = iWork + 2;
        }
        iWork = iVar1;
    }
    uDefault = 0;
    for (i = 0; i < 2; i = i + 1) {
        uDefault = uDefault * '\x10';
        UVar2 = GetDriveType(i + 2);
        if (UVar2 == 3) {
            l._0_2_ = __dos_getdiskfree(i + 3, &df);
        } else {
            l._0_2_ = 1;
        }
        if ((uint)l == 0) {
            lVar6 = 0x200;
            uVar5 = __aFulmul((ulong)df.total_clusters, (ulong)df.bytes_per_sector);
            uVar5 = __aFldiv(uVar5, lVar6);
            uVar5 = __aFulmul(uVar5, (ulong)df.sectors_per_cluster);
            lVar6 = __aFldiv(uVar5, 0x2faf0);
            if (0xf < lVar6) {
                lVar6 = 0xf;
            }
            uDefault = uDefault + ((byte)lVar6 & 0xf);
        }
    }
    ((byte_0_ *)&vrgbEnvCur)[iWork] = uDefault;
    return (ulong)(iWork + 1);
}

// ======================================================================
// Function: ShowProgressGauge
// Address: 1040:636c
// Segment: MEMORY_UTILGEN
// ======================================================================

void ShowProgressGauge(void)

{
    if (hwndProgressGauge == 0) {
        CreateDialog(0, IDD_Gauge, hwndFrame, (fn_lpfnGaugeDlgProc *)CONCAT22(lpfnGaugeDlgProc._2_2_, (fn_lpfnGaugeDlgProc *)lpfnGaugeDlgProc));
    } else {
        UpdateProgressGauge(0);
    }
    return;
}

// ======================================================================
// Function: HideProgressGauge
// Address: 1040:63b2
// Segment: MEMORY_UTILGEN
// ======================================================================

void HideProgressGauge(void)

{
    if (hwndProgressGauge != 0) {
        DestroyWindow(hwndProgressGauge);
        hwndProgressGauge = 0;
    }
    return;
}

// ======================================================================
// Function: UpdateProgressGauge
// Address: 1040:63da
// Segment: MEMORY_UTILGEN
// ======================================================================

void UpdateProgressGauge(short pctX10)

{
    short iNum;

    if (hwndProgressGauge != 0) {
        iNum = 0;
        if (pctX10 == -0x39e) {
            pctX10 = vpctProgressGauge + 4;
        } else if (pctX10 == -0x39f) {
            pctX10 = vpctProgressGauge + 1;
        } else if (pctX10 < 0) {
            pctX10 = 0;
        } else if (1000 < pctX10) {
            if ((gd.grBits._2_2_ >> 10 & 1) == 0) {
                return;
            }
            iNum = pctX10;
            pctX10 = vpctProgressGauge;
        }
        vpctProgressGauge = pctX10;
        DrawProgressGauge(0, 0, iNum);
    }
    return;
}

// ======================================================================
// Function: ProgressGaugeDlg
// Address: 1040:647e
// Segment: MEMORY_UTILGEN
// ======================================================================

short ProgressGaugeDlg(HWND hwnd, WMType message, ushort wParam, long lParam)

{
    short       sVar1;
    short       sVar2;
    char       *pcVar3;
    HWND        HVar4;
    HBRUSH      HVar5;
    HDC         hdcOrig;
    undefined2  unaff_SS;
    short       dx;
    char       *psz;
    short       dy;
    RECT        rc;
    PAINTSTRUCT ps;
    HDC         hdc;

    if (message == WM_PAINT) {
        hdcOrig = BeginPaint(hwnd, &ps);
        DrawProgressGauge(hdcOrig, 1, 0);
        EndPaint(hwnd, &ps);
        HVar5 = 1;
    } else if (message == WM_ERASEBKGND) {
        GetClientRect(hwnd, &rc);
        FillRect(wParam, &rc, hbrButtonFace);
        HVar5 = 1;
    } else if (message == WM_CTLCOLOR) {
        SetBkColor(wParam, CONCAT22(crButtonFace._2_2_, (undefined2)crButtonFace));
        HVar5 = hbrButtonFace;
    } else if (message == WM_INITDIALOG) {
        vpctProgressGauge = 0;
        hwndProgressGauge = hwnd;
        sVar1 = GetSystemMetrics(0);
        sVar2 = GetSystemMetrics(1);
        pcVar3 = PszGetCompressedString(idsGeneratingDataYearD);
        _wsprintf(szWork, pcVar3, game.turn + 0x961);
        HVar4 = GetDlgItem(hwnd, IDC_U16_0x042E | IDOK);
        SetWindowText(HVar4, szWork);
        GetWindowRect(hwnd, &rc);
        rc.left = sVar1 - (rc.right - rc.left) >> 1;
        rc.top = sVar2 - (rc.bottom - rc.top) >> 1;
        SetWindowPos(hwnd, 0, rc.left, rc.top, 0, 0, 5);
        HVar5 = 1;
    } else {
        HVar5 = 0;
    }
    return HVar5;
}

// ======================================================================
// Function: DrawProgressGauge
// Address: 1040:65f6
// Segment: MEMORY_UTILGEN
// ======================================================================

void DrawProgressGauge(HDC hdcOrig, short fFull, short iNumOnly)

{
    int        iVar1;
    bool       bVar2;
    int        iVar3;
    int        iVar4;
    short      cLen;
    undefined2 unaff_SS;
    char       szT[8];
    short      c;
    RECT       rc;
    short      dx;
    short      dx2;
    short      fNumOnly;
    short      dy;
    HDC        hdc;

    bVar2 = iNumOnly < 1;
    if (hwndProgressGauge != 0) {
        if (hdcOrig == 0) {
            hdc = GetDC(hwndProgressGauge);
        } else {
            hdc = hdcOrig;
        }
        GetClientRect(hwndProgressGauge, &rc);
        rc.top = rc.bottom >> 1;
        InflateRect(&rc, -8, -8);
        iVar3 = rc.right - rc.left;
        iVar4 = rc.bottom - rc.top;
        if (fFull != 0) {
            SelectObject(hdc, hbrButtonShadow);
            PatBlt(hdc, rc.left + -1, rc.top + -1, iVar3 + 2, 1, 0xf00021);
            PatBlt(hdc, rc.left + -1, rc.top + -1, 1, iVar4 + 2, 0xf00021);
            SelectObject(hdc, hbrButtonHilite);
            PatBlt(hdc, rc.left, rc.bottom, iVar3 + 1, 1, 0xf00021);
            PatBlt(hdc, rc.right, rc.top, 1, iVar4, 0xf00021);
        }
        InflateRect(&rc, -2, -2);
        iVar1 = iVar4 + -4;
        if ((gd.grBits._2_2_ >> 10 & 1) != 0) {
            SetBkColor(hdc, CONCAT22(crButtonFace._2_2_, (undefined2)crButtonFace));
            SelectObject(hdc, rghfontArial7[0]);
            if (iNumOnly < 1) {
                iNumOnly = vpctProgressGauge;
            }
            cLen = _wsprintf(szT, PCTD, iNumOnly);
            RightTextOut(hdc, rc.right + -2, 1, szT, cLen, 0x50);
        }
        if (bVar2) {
            SelectObject(hdc, hbrBlue);
            for (dx = MulDiv(iVar3 + -4, vpctProgressGauge, 1000); 0 < dx; dx = dx - iVar1) {
                if (dx < iVar1) {
                    dx2 = dx;
                } else {
                    dx2 = iVar4 + -5;
                }
                PatBlt(hdc, rc.left, rc.top, dx2, iVar1, 0xf00021);
                rc.left = rc.left + iVar1;
            }
        }
        if (hdcOrig == 0) {
            ReleaseDC(hwndProgressGauge, hdc);
        }
    }
    return;
}

// ======================================================================
// Function: LDistance2
// Address: 1040:685c
// Segment: MEMORY_UTILGEN
// ======================================================================

long LDistance2(POINT pt1, POINT pt2)

{
    ulong uVar1;
    ulong uVar2;
    long  dx;
    long  dy;

    uVar1 = __aFulmul((long)(pt1.y - pt2.y), (long)(pt1.y - pt2.y));
    uVar2 = __aFulmul((long)(pt1.x - pt2.x), (long)(pt1.x - pt2.x));
    return uVar2 + uVar1;
}

// ======================================================================
// Function: PszGetLine
// Address: 1040:68ba
// Segment: MEMORY_UTILGEN
// ======================================================================

char *PszGetLine(char **ppszBeg)

{
    char *pcVar1;
    char *psz;
    char *pszStart;

    psz = (char *)CONCAT22(ppszBeg[1], *ppszBeg);
    while (true) {
        pcVar1 = psz;
        if (*psz != ' ')
            break;
        psz = (char *)psz + 1;
    }
    while (true) {
        if (((*psz == '\0') || (*psz == '\n')) || (*psz == '\r'))
            break;
        psz = (char *)psz + 1;
    }
    if ((*psz == '\r') && (((char *)psz)[1] == '\n')) {
        *ppszBeg = (char *)psz + 2;
        ppszBeg[1] = psz._2_2_;
    } else {
        *ppszBeg = (char *)psz + 1;
        ppszBeg[1] = psz._2_2_;
    }
    *psz = '\0';
    return pcVar1;
}

// ======================================================================
// Function: CParseNumbers
// Address: 1040:6986
// Segment: MEMORY_UTILGEN
// ======================================================================

short CParseNumbers(char *psz, long *pl, short cMax)

{
    char  cVar1;
    bool  bVar2;
    ulong uVar3;
    long  lNum;
    short fValid;
    short iRead;

    iRead = 0;
    uVar3 = 0;
    bVar2 = false;
    while (true) {
        lNum._2_2_ = (undefined2)(uVar3 >> 0x10);
        lNum._0_2_ = (undefined2)uVar3;
        if ((cMax <= iRead) || (*psz == '\0')) {
            if (bVar2) {
                *(undefined2 *)(pl + iRead) = (undefined2)lNum;
                *(undefined2 *)((int)(pl + iRead) + 2) = lNum._2_2_;
                iRead = iRead + 1;
            }
            return iRead;
        }
        if ((*psz != ' ') && ((*psz < '0' || ('9' < *psz))))
            break;
        if (*psz == ' ') {
            if (bVar2) {
                *(undefined2 *)(pl + iRead) = (undefined2)lNum;
                *(undefined2 *)((int)(pl + iRead) + 2) = lNum._2_2_;
                uVar3 = 0;
                bVar2 = false;
                iRead = iRead + 1;
            }
        } else {
            bVar2 = true;
            cVar1 = *psz;
            uVar3 = __aFulmul(uVar3, 10);
            uVar3 = uVar3 + (long)(cVar1 + -0x30);
        }
        psz = (char *)psz + 1;
    }
    return -1;
}

// ======================================================================
// Function: HfontPrinterCreate
// Address: 1040:6aa6
// Segment: MEMORY_UTILGEN
// ======================================================================

ushort HfontPrinterCreate(HDC hdc, short iSize, short *pdyFont)

{
    LOGFONT   *pLVar1;
    short      sVar2;
    HFONT      HVar3;
    HGDIOBJ    HVar4;
    undefined2 unaff_SS;
    HFONT      hfontSav;
    TEXTMETRIC tm;
    LOGFONT   *plf;
    HFONT      hfontNew;

    pLVar1 = (LOGFONT *)LocalAlloc(0x40, 0x32);
    _memset(pLVar1, 0, 0x32);
    sVar2 = GetDeviceCaps(hdc, 0x5a);
    sVar2 = MulDiv(iSize, sVar2, 0x48);
    pLVar1->lfHeight = -sVar2;
    _strcpy(pLVar1->lfFaceName, *(char (*)[32])(rgszArial + 1));
    HVar3 = CreateFontIndirect(pLVar1);
    if ((pdyFont != 0) && (HVar3 != 0)) {
        HVar4 = SelectObject(hdc, HVar3);
        GetTextMetrics(hdc, &tm);
        *pdyFont = tm.tmHeight + tm.tmExternalLeading;
        SelectObject(hdc, HVar4);
    }
    LocalFree((HLOCAL)pLVar1);
    return HVar3;
}
