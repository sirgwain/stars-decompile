// Decompiled code from stars.exe
// Generated by Ghidra - ExportAllDecompiled.py
// Grouped by nb09_ghidra_globals.json segmap.segname
// 

// ======================================================================
// Function: LphbAlloc
// Address: 1060:0000
// Segment: MEMORY_MEMORY
// ======================================================================


HB * LphbAlloc(ushort cb,HeapType ht)

{
  undefined2 uVar1;
  HB *pHVar2;
  HGLOBAL HVar3;
  char *sz;
  undefined2 uVar4;
  HB *pHVar5;
  short mbType;
  HB *lphb;
  ushort hmem;
  
                    /* Segment:    13
                       Offset:     00062900
                       Length:     0959
                       Min Alloc:  0959
                       Flags:      1d50
                           Code
                           Discardable
                           Moveable
                           Preload
                           Impure (Non-shareable)
                        */
  cb = cb + 0x10;
  if (cb < *(uint *)(ht * 2 + 0xd64)) {
    cb = *(ushort *)(ht * 2 + 0xd64);
  }
  HVar3 = GlobalAlloc(0x22,(ulong)cb);
  if (HVar3 == 0) {
    mbType = 0x10;
    sz = PszFormatIds(idsMemory,(short *)0x0);
    AlertSz(sz,mbType);
    _longjmp(penvMem,-1);
  }
  pHVar5 = (HB *)GlobalLock(HVar3);
  uVar4 = (undefined2)((ulong)pHVar5 >> 0x10);
  pHVar2 = (HB *)pHVar5;
  pHVar2->hmem = HVar3;
  pHVar2->cbBlock = cb;
  pHVar2->cbSlop = cb - 0x10;
  pHVar5->cbFree = cb - 0x10;
  pHVar2->ibTop = 0x10;
  pHVar2->ht = (byte)ht;
  uVar1 = *(undefined2 *)(ht * 4 + 0xd36);
  *(undefined2 *)&pHVar2->lphbNext = *(undefined2 *)(ht * 4 + 0xd34);
  *(undefined2 *)((int)&pHVar2->lphbNext + 2) = uVar1;
  *(int *)(ht * 4 + 0xd34) = (int)pHVar2;
  *(undefined2 *)(ht * 4 + 0xd36) = uVar4;
  return pHVar5;
}



// ======================================================================
// Function: LphbReAlloc
// Address: 1060:0108
// Segment: MEMORY_MEMORY
// ======================================================================


HB * LphbReAlloc(HB *lphb)

{
  uint uVar1;
  HB *pHVar2;
  char *sz;
  undefined2 uVar3;
  int iVar4;
  HB *pHVar5;
  short mbType;
  ushort cbGrow;
  ushort cbCur;
  HB *lphbNew;
  HB *lphbT;
  ushort hmem;
  
  if (lphb == (HB *)0x0) {
    pHVar2 = (HB *)0x0;
    uVar3 = 0;
    goto LAB_1060_02d2;
  }
  hmem = ((HB *)lphb)->hmem;
  uVar1 = ((HB *)lphb)->cbBlock;
  cbGrow = *(ushort *)((uint)((HB *)lphb)->ht * 2 + 0xd64);
  if (uVar1 < 0xffdc) {
    if (-cbGrow - 0x24 < uVar1) {
      cbGrow = -uVar1 - 0x24;
    }
    GlobalUnlock(hmem);
    hmem = GlobalReAlloc(hmem,(ulong)(((HB *)lphb)->cbBlock + cbGrow),0x22);
    if (hmem == 0) goto MEMORY_LReAllocOOM;
  }
  else {
MEMORY_LReAllocOOM:
    mbType = 0x10;
    sz = PszFormatIds(idsMemory,(short *)0x0);
    AlertSz(sz,mbType);
    _longjmp(penvMem,-1);
  }
  pHVar5 = (HB *)GlobalLock(hmem);
  uVar3 = (undefined2)((ulong)pHVar5 >> 0x10);
  pHVar2 = (HB *)pHVar5;
  pHVar2->hmem = hmem;
  iVar4 = (uint)pHVar2->ht * 4;
  if (((HB *)*(int *)(iVar4 + 0xd34) == (HB *)lphb) && (*(int *)(iVar4 + 0xd36) == lphb._2_2_)) {
    iVar4 = (uint)pHVar2->ht * 4;
    *(int *)(iVar4 + 0xd34) = (int)pHVar2;
    *(undefined2 *)(iVar4 + 0xd36) = uVar3;
  }
  else {
    iVar4 = (uint)pHVar2->ht * 4;
    lphbT = (HB *)CONCAT22(*(undefined2 *)(iVar4 + 0xd36),(HB *)*(undefined2 *)(iVar4 + 0xd34));
    while( true ) {
                    /* WARNING: Load size is inaccurate */
      if ((((HB *)lphbT == (HB *)0x0) && (lphbT._2_2_ == 0)) ||
         ((((HB *)lphbT)->lphbNext == (HB *)lphb &&
          (*(int *)((int)&((HB *)lphbT)->lphbNext + 2) == lphb._2_2_)))) break;
                    /* WARNING: Load size is inaccurate */
      lphbT = (HB *)CONCAT22(*(undefined2 *)((int)&((HB *)lphbT)->lphbNext + 2),
                             ((HB *)lphbT)->lphbNext);
    }
    *(HB **)&((HB *)lphbT)->lphbNext = pHVar2;
    *(undefined2 *)((int)&((HB *)lphbT)->lphbNext + 2) = uVar3;
  }
  pHVar2->cbBlock = pHVar2->cbBlock + cbGrow;
  pHVar5->cbFree = pHVar5->cbFree + cbGrow;
  pHVar2->cbSlop = pHVar2->cbSlop + cbGrow;
LAB_1060_02d2:
  return (HB *)CONCAT22(uVar3,pHVar2);
}



// ======================================================================
// Function: FreeHb
// Address: 1060:02d8
// Segment: MEMORY_MEMORY
// ======================================================================


void FreeHb(HB *lphb)

{
  HB *pHVar1;
  undefined2 uVar2;
  HGLOBAL HVar3;
  HB *lphbNext;
  ushort hmem;
  
  if (((HB *)lphb != (HB *)0x0) || (lphb._2_2_ != 0)) {
    while( true ) {
      if (((HB *)lphb == (HB *)0x0) && (lphb._2_2_ == 0)) break;
                    /* WARNING: Load size is inaccurate */
      pHVar1 = ((HB *)lphb)->lphbNext;
      uVar2 = *(undefined2 *)((int)&((HB *)lphb)->lphbNext + 2);
      HVar3 = ((HB *)lphb)->hmem;
      GlobalUnlock(HVar3);
      GlobalFree(HVar3);
      lphb = (HB *)CONCAT22(uVar2,pHVar1);
    }
  }
  return;
}



// ======================================================================
// Function: ResetHb
// Address: 1060:0348
// Segment: MEMORY_MEMORY
// ======================================================================


void ResetHb(HeapType ht)

{
  int iVar1;
  HB *lphb;
  
  lphb = (HB *)CONCAT22(*(undefined2 *)(ht * 4 + 0xd36),(HB *)*(undefined2 *)(ht * 4 + 0xd34));
  while( true ) {
    if (((HB *)lphb == (HB *)0x0) && (lphb._2_2_ == 0)) break;
    ((HB *)lphb)->ibTop = 0x10;
    iVar1 = ((HB *)lphb)->cbBlock + -0x10;
    ((HB *)lphb)->cbSlop = iVar1;
    lphb->cbFree = iVar1;
                    /* WARNING: Load size is inaccurate */
    lphb = (HB *)CONCAT22(*(undefined2 *)((int)&((HB *)lphb)->lphbNext + 2),((HB *)lphb)->lphbNext);
  }
  return;
}



// ======================================================================
// Function: LpAlloc
// Address: 1060:03b2
// Segment: MEMORY_MEMORY
// ======================================================================


void * LpAlloc(ushort cb,HeapType ht)

{
  byte *pbVar1;
  byte *pbVar2;
  uint cb_00;
  byte *pbVar3;
  uint uVar4;
  HB *pHVar5;
  undefined2 uVar6;
  byte *lpb;
  HB *lphb;
  byte *lpbTop;
  byte *lpbPrev;
  ushort cbItem;
  short fFree;
  
  lphb = (HB *)CONCAT22(*(undefined2 *)(ht * 4 + 0xd36),(HB *)*(undefined2 *)(ht * 4 + 0xd34));
  cb_00 = cb + 3 & 0xfffe;
  do {
    if ((((HB *)lphb == (HB *)0x0) && (lphb._2_2_ == 0)) || (cb_00 <= (uint)lphb->cbFree)) {
      if (((HB *)lphb == (HB *)0x0) && (lphb._2_2_ == 0)) {
        lphb = LphbAlloc(cb_00,ht);
      }
      uVar6 = (undefined2)((ulong)lphb >> 0x10);
      pHVar5 = (HB *)lphb;
      pbVar3 = (byte *)((int)&pHVar5->cbFree + pHVar5->ibTop);
      lpbTop = (byte *)CONCAT22(uVar6,pbVar3);
      if (cb_00 <= (uint)pHVar5->cbSlop) {
        *(uint *)lpbTop = cb_00 - 2;
        pHVar5->ibTop = pHVar5->ibTop + cb_00;
        lphb->cbFree = lphb->cbFree - cb_00;
        pHVar5->cbSlop = pHVar5->cbSlop - cb_00;
LAB_1060_0586:
        return (void *)CONCAT22(uVar6,pbVar3 + 2);
      }
      lpb = (byte *)CONCAT22(uVar6,pHVar5 + 1);
      while (pbVar2 = lpb, pbVar1 = (byte *)lpb, (byte *)lpb < pbVar3) {
        uVar6 = lpb._2_2_;
        uVar4 = *(uint *)lpb;
        lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + (*(uint *)lpb & 0xfffe) + 2);
        if ((uVar4 & 1) != 0) {
          for (; (((byte *)lpb < pbVar3 && ((*(uint *)lpb & 1) != 0)) &&
                 ((uint)((int)(byte *)lpb - (int)pbVar1) < cb_00));
              lpb = (byte *)CONCAT22(lpb._2_2_,(byte *)lpb + (*(uint *)lpb & 0xfffe) + 2)) {
          }
          uVar4 = (int)(byte *)lpb - (int)pbVar1;
          *(uint *)pbVar2 = uVar4 - 2 | 1;
          if (cb_00 <= uVar4) {
            *(uint *)pbVar2 = *(uint *)pbVar2 & 0xfffe;
            lphb->cbFree = lphb->cbFree - uVar4;
            pbVar3 = pbVar1;
            goto LAB_1060_0586;
          }
        }
      }
    }
    uVar6 = (undefined2)((ulong)lphb >> 0x10);
                    /* WARNING: Load size is inaccurate */
    lphb = (HB *)CONCAT22(*(undefined2 *)((int)&((HB *)lphb)->lphbNext + 2),((HB *)lphb)->lphbNext);
  } while( true );
}



// ======================================================================
// Function: LphbFromLpHt
// Address: 1060:058c
// Segment: MEMORY_MEMORY
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x106005e0) */
/* WARNING: Removing unreachable block (ram,0x10600608) */

HB * LphbFromLpHt(void *lp,HeapType ht)

{
  HB *lphb;
  
  if (((int)ht < 0) || (0xb < (int)ht)) {
    lphb = (HB *)0x0;
  }
  else {
    lphb = (HB *)CONCAT22(*(undefined2 *)(ht * 4 + 0xd36),(HB *)*(undefined2 *)(ht * 4 + 0xd34));
    while( true ) {
      if ((lphb == (HB *)0x0) ||
         ((lphb < lp &&
          (lp < (void *)CONCAT22(lphb._2_2_,
                                 (void *)((int)&((HB *)lphb)->cbFree + ((HB *)lphb)->cbBlock))))))
      break;
                    /* WARNING: Load size is inaccurate */
      lphb = (HB *)CONCAT22(*(undefined2 *)((int)&((HB *)lphb)->lphbNext + 2),((HB *)lphb)->lphbNext
                           );
    }
    if (lphb == (HB *)0x0) {
      lphb = (HB *)0x0;
    }
  }
  return lphb;
}



// ======================================================================
// Function: LpReAlloc
// Address: 1060:0660
// Segment: MEMORY_MEMORY
// ======================================================================


void * LpReAlloc(void *lp,ushort cb,HeapType ht)

{
  uint uVar1;
  uint cb_00;
  uint uVar2;
  HB *pHVar3;
  int iVar4;
  HB *lphb_00;
  void *pvVar5;
  ushort cbGrow;
  ushort cbCur;
  HB *lphb;
  void *lpNew;
  
  uVar1 = *(uint *)((int)(void *)lp + -2);
  cb_00 = cb + 1 & 0xfffe;
  uVar2 = cb_00 - uVar1;
  pvVar5 = lp;
  if (uVar1 < cb_00) {
    lphb_00 = LphbFromLpHt(lp,ht);
    while( true ) {
      iVar4 = (int)((ulong)lphb_00 >> 0x10);
      pHVar3 = (HB *)lphb_00;
      if ((((int)&pHVar3->cbFree + pHVar3->ibTop == (int)(void *)lp + uVar1) && (iVar4 == lp._2_2_))
         && (uVar2 <= (uint)pHVar3->cbSlop)) {
        pHVar3->cbSlop = pHVar3->cbSlop - uVar2;
        lphb_00->cbFree = lphb_00->cbFree - uVar2;
        pHVar3->ibTop = pHVar3->ibTop + uVar2;
        *(uint *)((int)(void *)lp + -2) = cb_00;
        return lp;
      }
      if ((ht != htPlanets) && (ht != htThings)) break;
      lphb_00 = LphbReAlloc(lphb_00);
      lp = (void *)CONCAT22((int)((ulong)lphb_00 >> 0x10),&((HB *)lphb_00)[1].cbBlock);
    }
    pvVar5 = LpAlloc(cb_00,ht);
    __fmemcpy(pvVar5,lp,uVar1);
    FreeLp(lp,ht);
  }
  return pvVar5;
}



// ======================================================================
// Function: FreeLp
// Address: 1060:07a8
// Segment: MEMORY_MEMORY
// ======================================================================


void FreeLp(void *lp,HeapType ht)

{
  HB *pHVar1;
  int iVar2;
  undefined2 uVar3;
  HB *pHVar4;
  HB *lphb;
  ushort cbFree;
  
  if (lp != (void *)0x0) {
    pHVar4 = LphbFromLpHt(lp,ht);
    uVar3 = (undefined2)((ulong)pHVar4 >> 0x10);
    pHVar1 = (HB *)pHVar4;
    iVar2 = *(int *)((int)(void *)lp + -2) + 2;
    *(uint *)((int)(void *)lp + -2) = *(uint *)((int)(void *)lp + -2) | 1;
    pHVar4->cbFree = pHVar4->cbFree + iVar2;
    if ((int)(void *)lp + (iVar2 - (int)pHVar1) + -2 == pHVar1->ibTop) {
      pHVar1->ibTop = pHVar1->ibTop - iVar2;
      pHVar1->cbSlop = pHVar1->cbSlop + iVar2;
    }
  }
  return;
}



// ======================================================================
// Function: LpplReAlloc
// Address: 1060:0836
// Segment: MEMORY_MEMORY
// ======================================================================


PL * LpplReAlloc(PL *lppl,ushort cAlloc)

{
  PL *pPVar1;
  
  pPVar1 = LpReAlloc(lppl,(lppl->wFlags & 0xffU) * cAlloc + 4,(uint)lppl->wFlags >> 9 & htShips);
  ((PL *)pPVar1)->iMax = (byte)cAlloc;
  return pPVar1;
}



// ======================================================================
// Function: LpplAlloc
// Address: 1060:088c
// Segment: MEMORY_MEMORY
// ======================================================================


PL * LpplAlloc(ushort cbItem,ushort cAlloc,HeapType ht)

{
  undefined2 uVar1;
  PL *pPVar2;
  PL *lppl;
  
  pPVar2 = LpAlloc(cbItem * cAlloc + 4,ht);
  uVar1 = (undefined2)((ulong)pPVar2 >> 0x10);
  ((PL *)pPVar2)->iMax = (byte)cAlloc;
  ((PL *)pPVar2)->iMac = 0;
  pPVar2->wFlags = pPVar2->wFlags & 0xfeff;
  pPVar2->wFlags = pPVar2->wFlags & 0xff00U | cbItem & 0xff;
  pPVar2->wFlags = pPVar2->wFlags & 0xf1ffU | (ht & htShips) << 9;
  return pPVar2;
}



// ======================================================================
// Function: FreePl
// Address: 1060:0918
// Segment: MEMORY_MEMORY
// ======================================================================


void FreePl(PL *lppl)

{
  if (lppl != (PL *)0x0) {
    FreeLp(lppl,(uint)lppl->wFlags >> 9 & htShips);
  }
  return;
}



