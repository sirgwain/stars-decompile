// Call tree decompilation from stars.exe (Stars! 2.60j RC3)
// Root function: SpankTheCheaters
// Max depth: 2
// Total functions: 10
// Generated by Ghidra
//

// ======================================================================
// Function: FSendPlrMsg
// Address: 1030:7ee8
// ======================================================================


short __cdecl16far
MSG::FSendPlrMsg(short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,short p5,
                short p6,short p7)

{
  ushort uVar1;
  uint uVar2;
  undefined2 unaff_SS;
  byte *lpb;
  short cbMsg;
  byte rgbWork [40];
  
  uVar1 = PackageUpMsg(rgbWork,iPlr,iMsg,iObj,p1,p2,p3,p4,p5,p6,p7);
  if ((int)uVar1 < 1) {
    uVar2 = (uint)(uVar1 == 0);
  }
  else {
    PUBLIC::__fmemmove((void *)CONCAT22(_DATA::lpMsg._2_2_,(int)_DATA::lpMsg + _DATA::imemMsgCur),
                       (void *)CONCAT22(unaff_SS,rgbWork),uVar1);
    _DATA::imemMsgCur = _DATA::imemMsgCur + uVar1;
    _DATA::cMsg = _DATA::cMsg + 1;
    uVar2 = 1;
  }
  return uVar2;
}



// ======================================================================
// Function: FSendPlrMsg2
// Address: 1030:7eaa
// ======================================================================


short __cdecl16far MSG::FSendPlrMsg2(short iPlr,MessageId iMsg,short iObj,short p1,short p2)

{
  short sVar1;
  
  sVar1 = FSendPlrMsg(iPlr,iMsg,iObj,p1,p2,0,0,0,0,0);
  return sVar1;
}



// ======================================================================
// Function: PackageUpMsg
// Address: 1030:802a
// ======================================================================


/* WARNING: Could not reconcile some variable overlaps */

short __cdecl16far
MSG::PackageUpMsg(byte *pb,short iPlr,MessageId iMsg,short iObj,short p1,short p2,short p3,short p4,
                 short p5,short p6,short p7)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  short sVar4;
  byte *lpbBase;
  byte *lpb;
  MSGTURN *lpmt;
  ushort grbit;
  short i;
  short *pi;
  
  if (iPlr == -1) {
    sVar4 = 0;
  }
  else if (((((*(uint *)((int)&c_common::rgplr[0].flags4 + iPlr * 0xc0) >> 9 & 1) == 0) ||
            (*(uint *)((int)&c_common::rgplr[0].flags4 + iPlr * 0xc0) >> 0xd == 7)) ||
           (iMsg == idmHasBombedKillingOffEnemyColonists)) ||
          (((iMsg == idmHaveAttackedFirstRateStormTroopersThough ||
            (iMsg == idmColonistsHaveDiedOffLongerControlPlanet)) ||
           (iMsg == idmColonistsHaveJumpedShipLongerControlPlanet)))) {
    if (_DATA::imemMsgCur + 0x14U < 0xffc9) {
      lpmt = (MSGTURN *)CONCAT22(0x1120,pb);
      lpmt->field0_0x0 = lpmt->field0_0x0 & 0xf0 | (byte)iPlr & 0xf;
      *(MessageId *)(pb + 1) = *(uint *)(pb + 1) & 0xfe00 | iMsg & 0x1ff;
      *(uint *)(pb + 1) = *(uint *)(pb + 1) & 0x1ff;
      *(short *)(pb + 3) = iObj;
      lpb = (byte *)CONCAT22(0x1120,pb + 5);
      grbit = 1;
      pi = &p1;
      for (i = 0; i < *(char *)((int)c_common::rgplr[1].szNames + 0xc + iMsg); i = i + 1) {
        if ((*pi & 0xff00U) == 0) {
          *lpb = (byte)*pi;
          iVar3 = (int)lpb + 1;
        }
        else {
          uVar2 = *(uint *)(pb + 1);
          puVar1 = (uint *)(pb + 1);
          *puVar1 = *puVar1 & 0x1ff;
          puVar1 = (uint *)(pb + 1);
          *puVar1 = *puVar1 | grbit << 9 | uVar2 & 0xfe00;
          *(short *)lpb = *pi;
          iVar3 = (int)lpb + 2;
        }
        lpb = (byte *)CONCAT22(lpb._2_2_,iVar3);
        pi = pi + 1;
        grbit = grbit << 1;
      }
      lpmt->field0_0x0 =
           lpmt->field0_0x0 & 0xf | (byte)(((byte)((char)lpb - (char)(pb + 5)) & 0xf) << 4);
      sVar4 = (int)lpb - (int)pb;
    }
    else {
      sVar4 = -1;
    }
  }
  else {
    sVar4 = 0;
  }
  return sVar4;
}



// ======================================================================
// Function: Random
// Address: 1040:16d2
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10401832) */

short __cdecl16far UTILGEN::Random(short c)

{
  long lVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  short sVar7;
  ulong uVar8;
  ulong uVar9;
  ulong uVar10;
  long s2;
  long k;
  long s1;
  long z;
  
  iVar6 = _DATA::lRandSeed2._2_2_;
  uVar5 = (uint)_DATA::lRandSeed2;
  iVar4 = _DATA::lRandSeed1._2_2_;
  uVar3 = (uint)_DATA::lRandSeed1;
  uVar8 = PUBLIC::__aFldiv(CONCAT22(_DATA::lRandSeed1._2_2_,(uint)_DATA::lRandSeed1),0xd1a4);
  uVar9 = PUBLIC::__aFulmul(uVar8,0x2fb3);
  uVar10 = 0x9c4e;
  uVar8 = PUBLIC::__aFulmul(uVar8,0xd1a4);
  uVar8 = PUBLIC::__aFulmul(CONCAT22((iVar4 - (int)(uVar8 >> 0x10)) - (uint)(uVar3 < (uint)uVar8),
                                     uVar3 - (uint)uVar8),uVar10);
  lVar1 = uVar8 - uVar9;
  if ((lVar1 < 0x10000) && (lVar1 < 0)) {
    lVar1 = lVar1 + 0x7fffffab;
  }
  uVar8 = PUBLIC::__aFldiv(CONCAT22(iVar6,uVar5),0xce26);
  uVar9 = PUBLIC::__aFulmul(uVar8,0xecf);
  uVar10 = 0x9ef4;
  uVar8 = PUBLIC::__aFulmul(uVar8,0xce26);
  uVar8 = PUBLIC::__aFulmul(CONCAT22((iVar6 - (int)(uVar8 >> 0x10)) - (uint)(uVar5 < (uint)uVar8),
                                     uVar5 - (uint)uVar8),uVar10);
  lVar2 = uVar8 - uVar9;
  if ((lVar2 < 0x10000) && (lVar2 < 0)) {
    lVar2 = lVar2 + 0x7fffff07;
  }
  uVar8 = lVar1 - lVar2;
  if ((long)uVar8 < 1) {
    uVar8 = uVar8 + 0x7fffffaa;
  }
  if (c < 1) {
    sVar7 = 0;
  }
  else {
    _DATA::lRandSeed2 = lVar2;
    _DATA::lRandSeed1 = lVar1;
    uVar8 = PUBLIC::__aFulrem(uVar8,(long)c);
    sVar7 = (short)uVar8;
    lVar1 = _DATA::lRandSeed1;
    lVar2 = _DATA::lRandSeed2;
  }
  _DATA::lRandSeed2._2_2_ = (int)((ulong)lVar2 >> 0x10);
  _DATA::lRandSeed2._0_2_ = (uint)lVar2;
  _DATA::lRandSeed1._2_2_ = (int)((ulong)lVar1 >> 0x10);
  _DATA::lRandSeed1._0_2_ = (uint)lVar1;
  return sVar7;
}



// ======================================================================
// Function: SpankTheCheaters
// Address: 10f0:192a
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x10f01bdb) */
/* WARNING: Removing unreachable block (ram,0x10f01be0) */
/* WARNING: Removing unreachable block (ram,0x10f01d8c) */
/* WARNING: Removing unreachable block (ram,0x10f01d75) */
/* WARNING: Removing unreachable block (ram,0x10f01c5e) */
/* WARNING: Could not reconcile some variable overlaps */

void __cdecl16far BATTLE::SpankTheCheaters(void)

{
  uint *puVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  bool bVar6;
  short sVar7;
  short sVar8;
  uint uVar9;
  ushort uVar10;
  int *piVar11;
  undefined2 *puVar12;
  uint *puVar13;
  undefined2 unaff_SI;
  undefined2 unaff_DI;
  undefined2 uVar14;
  ulong uVar15;
  long lVar16;
  ulong uVar17;
  ulong uVar18;
  PLANET *lpplMac;
  char rgfCheater [16];
  short fSellOff;
  short fCheater;
  long pctSell;
  short i;
  short ifl;
  FLEET *lpfl;
  PLANET *lppl;
  long lSell;
  
  uVar18 = CONCAT22(unaff_SI,unaff_DI);
  fCheater = 0;
  for (i = 0; i < _DATA::game.cPlayer; i = i + 1) {
    uVar9 = *(uint *)((int)&c_common::rgplr[0].flags43 + i * 0xc0) >> 2;
    rgfCheater[i] = (byte)uVar9 & 1;
    if ((uVar9 & 1) != 0) {
      fCheater = 1;
    }
  }
  if ((fCheater != 0) && (9 < (uint)_DATA::game.turn)) {
    for (ifl = 0; ifl < c_common::cFleet; ifl = ifl + 1) {
      piVar11 = (int *)((int)_DATA::rglpfl + ifl * 4);
      iVar3 = *piVar11;
      iVar2 = piVar11[1];
      lpfl = (FLEET *)CONCAT22(iVar2,iVar3);
      if ((iVar3 == 0) && (iVar2 == 0)) break;
      if (((*(uint *)(iVar3 + 4) >> 10 & 1) == 0) && (rgfCheater[*(int *)(iVar3 + 2)] != '\0')) {
        sVar7 = UTILGEN::Random(0xc);
        if (sVar7 == 0) {
          *(uint *)(iVar3 + 4) = *(uint *)(iVar3 + 4) & 0xfbff | 0x400;
          MSG::FSendPlrMsg2(*(short *)(iVar3 + 2),idmHasDefectedRanksDueInabilityProjectLegitimate,
                            -5,lpfl->flags1,0);
        }
        else {
          bVar6 = false;
          for (i = 0; i < 3; i = i + 1) {
            piVar11 = (int *)(iVar3 + 0x4c + i * 4);
            iVar5 = piVar11[1];
            if ((-1 < iVar5) && ((0 < iVar5 || (*piVar11 != 0)))) {
              if (!bVar6) {
                sVar7 = UTILGEN::Random(0xb);
                pctSell._0_2_ = sVar7 + 10;
                pctSell._2_2_ = (int)pctSell >> 0xf;
                bVar6 = true;
              }
              lVar16 = 100;
              puVar12 = (undefined2 *)(iVar3 + 0x4c + i * 4);
              uVar15 = PUBLIC::__aFulmul(CONCAT22(puVar12[1],*puVar12),
                                         CONCAT22(pctSell._2_2_,(int)pctSell));
              lVar16 = PUBLIC::__aFldiv(uVar15,lVar16);
              if (lVar16 == 0) {
                lVar16 = 1;
              }
              lSell._2_2_ = (int)((ulong)lVar16 >> 0x10);
              lSell._0_2_ = (uint)lVar16;
              puVar13 = (uint *)(iVar3 + 0x4c + i * 4);
              puVar1 = puVar13;
              uVar9 = *puVar1;
              *puVar1 = *puVar1 - (uint)lSell;
              puVar1 = puVar13 + 1;
              *puVar1 = (*puVar1 - lSell._2_2_) - (uint)(uVar9 < (uint)lSell);
            }
          }
          if (bVar6) {
            MSG::FSendPlrMsg2(*(short *)(iVar3 + 2),idmCrewHasSoldOffCargoBlackMarket,-5,
                              lpfl->flags1,(int)pctSell);
          }
        }
      }
    }
    uVar9 = (ushort)_DATA::lpPlanets + c_common::cPlanet * 0x38;
    lppl = (PLANET *)CONCAT22(_DATA::lpPlanets._2_2_,(ushort)_DATA::lpPlanets);
    uVar10 = (ushort)_DATA::lpPlanets;
    while ((uint)lppl < uVar9) {
      uVar14 = (undefined2)((ulong)lppl >> 0x10);
      if ((*(int *)((uint)lppl + 2) != -1) && (rgfCheater[*(int *)((uint)lppl + 2)] != '\0')) {
        uVar15 = PUBLIC::__aFulshr(uVar18,uVar10);
        if (((uVar15 & 0xfff) == 0) || (sVar7 = UTILGEN::Random(8), sVar7 != 0)) {
          sVar7 = UTILGEN::Random(0xf);
          if (sVar7 == 0) {
            sVar7 = UTILGEN::Random(3);
            sVar8 = UTILGEN::Random(0x29);
            lVar16 = 100;
            puVar12 = (undefined2 *)((uint)lppl + 0x1c + sVar7 * 4);
            uVar15 = PUBLIC::__aFulmul(CONCAT22(puVar12[1],*puVar12),(long)(sVar8 + 5));
            lVar16 = PUBLIC::__aFldiv(uVar15,lVar16);
            if (0 < lVar16) {
              if (30000 < lVar16) {
                lVar16 = 30000;
              }
              lSell._2_2_ = (int)((ulong)lVar16 >> 0x10);
              lSell._0_2_ = (uint)lVar16;
              puVar13 = (uint *)((uint)lppl + 0x1c + sVar7 * 4);
              puVar1 = puVar13;
              uVar4 = *puVar1;
              *puVar1 = *puVar1 - (uint)lSell;
              puVar1 = puVar13 + 1;
              *puVar1 = (*puVar1 - lSell._2_2_) - (uint)(uVar4 < (uint)lSell);
              MSG::FSendPlrMsg(*(short *)((uint)lppl + 2),
                               idmFreedomFightersHaveStolenKtStockpilesPress,-5,lppl->id,(uint)lSell
                               ,sVar7 + 1,0,0,0,0);
            }
          }
        }
        else {
          sVar7 = UTILGEN::Random(0x1f);
          lVar16 = 100;
          uVar17 = (ulong)(sVar7 + 5);
          uVar15 = PUBLIC::__aFulshr(uVar17,100);
          uVar15 = PUBLIC::__aFulmul(uVar15 & 0xfff,uVar17);
          lVar16 = PUBLIC::__aFldiv(uVar15,lVar16);
          if (lVar16 < 1) {
            lVar16 = 1;
          }
          lSell._0_2_ = (uint)lVar16;
          uVar4 = *(uint *)((uint)lppl + 0x14);
          iVar3 = *(int *)((uint)lppl + 0x16);
          uVar10 = uVar4 + (uint)lSell * -0x100 & 0xff00;
          puVar1 = (uint *)((uint)lppl + 0x14);
          *puVar1 = *puVar1 & 0xff;
          puVar1 = (uint *)((uint)lppl + 0x16);
          *puVar1 = *puVar1 & 0xfff0;
          puVar1 = (uint *)((uint)lppl + 0x14);
          *puVar1 = *puVar1 | uVar10;
          puVar1 = (uint *)((uint)lppl + 0x16);
          *puVar1 = *puVar1 | iVar3 - (uint)(uVar4 < (uint)lSell * 0x100) & 0xf;
          MSG::FSendPlrMsg2(*(short *)((uint)lppl + 2),
                            idmFreedomFightersHaveAttackedDestroyedMinesPress,-5,lppl->id,
                            (uint)lSell);
        }
      }
      lppl = (PLANET *)CONCAT22(uVar14,(uint)lppl + 0x38);
    }
  }
  return;
}



// ======================================================================
// Function: __aFldiv
// Address: 1118:0be4
// ======================================================================


long __stdcall16far PUBLIC::__aFldiv(long param_1,long param_2)

{
  ulong uVar1;
  long lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar9;
  char cVar10;
  
  cVar10 = param_1 < 0;
  if ((bool)cVar10) {
    param_1 = CONCAT22(-(uint)((uint)param_1 != 0) - param_1._2_2_,-(uint)param_1);
  }
  uVar3 = param_2._2_2_;
  if (param_2 < 0) {
    cVar10 = cVar10 + '\x01';
    uVar3 = -(uint)((uint)param_2 != 0) - param_2._2_2_;
    param_2 = CONCAT22(uVar3,-(uint)param_2);
  }
  uVar5 = (uint)param_1;
  uVar6 = (uint)param_2;
  uVar7 = param_1._2_2_;
  if (uVar3 == 0) {
    uVar3 = param_1._2_2_ / (uint)param_2;
    iVar4 = (int)(((ulong)param_1._2_2_ % (param_2 & 0xffffU) << 0x10 | param_1 & 0xffffU) /
                 (param_2 & 0xffffU));
  }
  else {
    do {
      uVar8 = uVar3 & 1;
      uVar3 = uVar3 >> 1;
      uVar6 = uVar6 >> 1 | (uint)(uVar8 != 0) << 0xf;
      uVar8 = uVar7 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar7 & 1) != 0) << 0xf;
      uVar7 = uVar8;
    } while (uVar3 != 0);
    uVar1 = CONCAT22(uVar8,uVar5) / (ulong)uVar6;
    iVar4 = (int)uVar1;
    lVar2 = (param_2 & 0xffffU) * (uVar1 & 0xffff);
    uVar3 = (uint)((ulong)lVar2 >> 0x10);
    uVar5 = uVar3 + iVar4 * param_2._2_2_;
    if (((CARRY2(uVar3,iVar4 * param_2._2_2_)) || (param_1._2_2_ < uVar5)) ||
       ((param_1._2_2_ <= uVar5 && ((uint)param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar10 == '\x01') {
    bVar9 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar9 - uVar3;
  }
  return CONCAT22(uVar3,iVar4);
}



// ======================================================================
// Function: __aFulmul
// Address: 1118:0c7e
// ======================================================================


ulong __stdcall16far PUBLIC::__aFulmul(ulong param_1,ulong param_2)

{
  if ((param_2._2_2_ | param_1._2_2_) == 0) {
    return (param_1 & 0xffff) * (param_2 & 0xffff);
  }
  return param_2 * param_1;
}



// ======================================================================
// Function: __aFulrem
// Address: 1118:0dc8
// ======================================================================


/* WARNING: Removing unreachable block (ram,0x11180e15) */

ulong __stdcall16far PUBLIC::__aFulrem(ulong param_1,ulong param_2)

{
  ulong uVar1;
  long lVar2;
  ulong uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  bool bVar10;
  
  uVar1 = param_1;
  uVar3 = param_2;
  if (param_2._2_2_ == 0) {
    iVar6 = (int)(((ulong)param_1._2_2_ % (param_2 & 0xffff) << 0x10 | param_1 & 0xffff) %
                 (param_2 & 0xffff));
    iVar7 = 0;
  }
  else {
    do {
      uVar5 = (uint)(uVar3 >> 0x11);
      uVar9 = (uint)uVar3 >> 1 | (uint)((uVar3 & 0x10000) != 0) << 0xf;
      uVar8 = (uint)(uVar1 >> 0x11);
      uVar4 = (uint)uVar1 >> 1 | (uint)((uVar1 & 0x10000) != 0) << 0xf;
      uVar1 = CONCAT22(uVar8,uVar4);
      uVar3 = CONCAT22(uVar5,uVar9);
    } while (uVar5 != 0);
    uVar1 = CONCAT22(uVar8,uVar4) / (ulong)uVar9;
    uVar4 = (int)uVar1 * param_2._2_2_;
    lVar2 = (uVar1 & 0xffff) * (param_2 & 0xffff);
    uVar8 = (uint)((ulong)lVar2 >> 0x10);
    uVar5 = (uint)lVar2;
    iVar7 = uVar8 + uVar4;
    if ((CARRY2(uVar8,uVar4)) || (param_1 < CONCAT22(iVar7,uVar5))) {
      bVar10 = uVar5 < (uint)param_2;
      uVar5 = uVar5 - (uint)param_2;
      iVar7 = (iVar7 - param_2._2_2_) - (uint)bVar10;
    }
    iVar6 = -(uVar5 - (uint)param_1);
    iVar7 = -(uint)(uVar5 - (uint)param_1 != 0) -
            ((iVar7 - param_1._2_2_) - (uint)(uVar5 < (uint)param_1));
  }
  return CONCAT22(iVar7,iVar6);
}



// ======================================================================
// Function: __aFulshr
// Address: 1118:0e32
// ======================================================================


ulong __stdcall16far PUBLIC::__aFulshr(ulong param_1,ushort param_2)

{
  uint uVar1;
  uint in_AX;
  uint in_CX;
  uint uVar2;
  uint in_DX;
  
  for (uVar2 = in_CX & 0xff; uVar2 != 0; uVar2 = uVar2 - 1) {
    uVar1 = in_DX & 1;
    in_DX = in_DX >> 1;
    in_AX = in_AX >> 1 | (uint)(uVar1 != 0) << 0xf;
  }
  return CONCAT22(in_DX,in_AX);
}



// ======================================================================
// Function: __fmemmove
// Address: 1118:105a
// ======================================================================


void * __stdcall16far PUBLIC::__fmemmove(void *param_1,void *param_2,ushort param_3)

{
  undefined *puVar1;
  undefined2 *puVar2;
  undefined *puVar3;
  undefined2 *puVar4;
  void *pvVar5;
  uint in_AX;
  int iVar6;
  undefined *puVar7;
  uint uVar8;
  uint in_DX;
  uint uVar9;
  undefined *puVar10;
  undefined2 *puVar11;
  undefined *puVar12;
  undefined2 *puVar13;
  int iVar14;
  
  iVar6 = (int)((ulong)param_1 >> 0x10);
  if (param_3 != 0) {
    iVar14 = (int)((ulong)param_2 >> 0x10);
    __aFahdiff();
    pvVar5 = param_1;
    if (((int)in_DX < 0) || ((in_AX < param_3) <= in_DX)) {
      while( true ) {
        iVar14 = (int)((ulong)pvVar5 >> 0x10);
        puVar13 = (undefined2 *)pvVar5;
        iVar6 = (int)((ulong)param_2 >> 0x10);
        puVar11 = (undefined2 *)param_2;
        uVar8 = ~(uint)puVar13;
        uVar8 = ((param_3 - 1) - uVar8 & -(uint)(param_3 - 1 < uVar8)) + uVar8;
        uVar9 = ~(uint)puVar11;
        uVar8 = (uVar8 - uVar9 & -(uint)(uVar8 < uVar9)) + uVar9 + 1;
        param_3 = param_3 - uVar8;
        for (uVar9 = uVar8 >> 1; uVar9 != 0; uVar9 = uVar9 - 1) {
          puVar4 = puVar13;
          puVar13 = puVar13 + 1;
          puVar2 = puVar11;
          puVar11 = puVar11 + 1;
          *puVar4 = *puVar2;
        }
        for (uVar8 = (uint)((uVar8 & 1) != 0); pvVar5 = (void *)CONCAT22(iVar14,puVar13), uVar8 != 0
            ; uVar8 = uVar8 - 1) {
          puVar4 = puVar13;
          puVar13 = (undefined2 *)((int)puVar13 + 1);
          puVar2 = puVar11;
          puVar11 = (undefined2 *)((int)puVar11 + 1);
          *(undefined *)puVar4 = *(undefined *)puVar2;
        }
        if (param_3 == 0) break;
        if (puVar11 == (undefined2 *)0x0) {
          iVar6 = iVar6 + 0x94;
        }
        param_2 = (void *)CONCAT22(iVar6,puVar11);
        if (puVar13 == (undefined2 *)0x0) {
          pvVar5 = (void *)((ulong)(iVar14 + 0x94) << 0x10);
          param_2 = (void *)CONCAT22(iVar6,puVar11);
        }
      }
    }
    else {
      uVar8 = param_3 - 1;
      puVar10 = (undefined *)((uint)param_2 + uVar8);
      if (CARRY2((uint)param_2,uVar8)) {
        iVar14 = iVar14 + 0x94;
      }
      puVar12 = (undefined *)((uint)param_1 + uVar8);
      if (CARRY2((uint)param_1,uVar8)) {
        iVar6 = iVar6 + 0x94;
      }
      while( true ) {
        puVar7 = puVar10 + ((int)(puVar12 +
                                 ((int)(undefined *)(param_3 - 1) - (int)puVar12 &
                                 -(uint)((undefined *)(param_3 - 1) < puVar12))) - (int)puVar10 &
                           -(uint)(puVar12 + ((int)(undefined *)(param_3 - 1) - (int)puVar12 &
                                             -(uint)((undefined *)(param_3 - 1) < puVar12)) <
                                  puVar10)) + 1;
        param_3 = param_3 - (int)puVar7;
        for (; puVar7 != (undefined *)0x0; puVar7 = puVar7 + -1) {
          puVar3 = puVar12;
          puVar12 = puVar12 + -1;
          puVar1 = puVar10;
          puVar10 = puVar10 + -1;
          *puVar3 = *puVar1;
        }
        if (param_3 == 0) break;
        if (puVar10 == (undefined *)0xffff) {
          iVar14 = iVar14 + -0x94;
        }
        if (puVar12 == (undefined *)0xffff) {
          iVar6 = iVar6 + -0x94;
        }
      }
    }
  }
  return param_1;
}



// ======================================================================
// Summary: 10 succeeded, 0 failed
// ======================================================================
