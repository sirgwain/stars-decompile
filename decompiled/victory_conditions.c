// Decompiled code from stars.exe (Stars! 2.60j RC3)
// Generated by Ghidra
//
// Victory condition functions for checking and computing win conditions.
// See victory_conditions.h for documentation of the formulas and indices.

#include "victory_conditions.h"


// ======================================================================
// Function: GetVCVal
// Address: 1078:b710
// ======================================================================


uint __cdecl16far CREATE::GetVCVal(int param_1,int param_2,int param_3)

{
  uint uVar1;
  int local_8;
  uint local_6;
  
  uVar1 = *(byte *)(param_1 + 0x14 + param_2) & 0x7f;
  if (param_3 == 0) {
    switch(param_2) {
    case 0:
      uVar1 = uVar1 * 5 + 0x14;
      break;
    case 1:
      uVar1 = uVar1 + 8;
      break;
    case 2:
      uVar1 = uVar1 + 2;
      break;
    case 3:
      uVar1 = uVar1 * 1000 + 1000;
      break;
    case 4:
      uVar1 = uVar1 * 10 + 0x14;
      break;
    case 5:
    case 6:
      uVar1 = uVar1 * 10 + 10;
      break;
    case 7:
      uVar1 = uVar1 * 10 + 0x1e;
      break;
    default:
      local_6 = 0;
      for (local_8 = 0; local_8 < 8; local_8 = local_8 + 1) {
        if ((local_8 != 2) && ((*(byte *)(local_8 + 0x84) & 0x80) != 0)) {
          local_6 = local_6 + 1;
        }
      }
      if ((int)local_6 < (int)uVar1) {
        uVar1 = local_6;
      }
      break;
    case 9:
      uVar1 = uVar1 * 10 + 0x1e;
    }
  }
  return uVar1;
}



// ======================================================================
// Function: GetVCCheck
// Address: 1078:b60c
// ======================================================================


bool __cdecl16far CREATE::GetVCCheck(int param_1,int param_2)

{
  return (*(byte *)(param_1 + 0x14 + param_2) & 0x80) != 0;
}



// ======================================================================
// Function: GetVCRStats
// Address: 10e8:193e
// ======================================================================


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __cdecl16far
VCR::GetVCRStats(uint param_1,undefined2 *param_2,uint *param_3,undefined2 *param_4,int *param_5)

{
  uint uVar1;
  undefined2 uVar2;
  undefined2 *puVar3;
  int iVar4;
  undefined2 uVar5;
  bool bVar6;
  long lVar7;
  undefined4 uVar8;
  long lVar9;
  undefined4 uVar10;
  undefined2 uVar11;
  undefined2 uVar12;
  undefined2 uVar13;
  int local_14;
  int local_12;
  undefined2 local_10;
  undefined2 local_e;
  uint local_c;
  int local_a;
  uint local_8;
  int local_6;
  
  local_c = 0;
  local_a = 0;
  local_14 = 0;
  local_8 = 0xffff;
  puVar3 = (undefined2 *)(_DATA::vrgdpVCR + param_1 * 4);
  uVar2 = *puVar3;
  uVar11 = puVar3[1];
  lVar7 = CONCAT22(uVar11,uVar2);
  local_12 = 0;
  while( true ) {
    uVar10 = CONCAT22(local_a,local_c);
    uVar5 = (undefined2)((ulong)_vlpbrVCR >> 0x10);
    iVar4 = (int)_vlpbrVCR;
    if (*(int *)(iVar4 + 2) <= local_12) break;
    if (*(byte *)(iVar4 + 6 + local_12 * 8) == param_1) {
      local_14 = local_14 + *(int *)(iVar4 + local_12 * 8 + 8);
      iVar4 = 0;
      uVar1 = PUBLIC::__aFlshl();
      bVar6 = CARRY2(local_c,uVar1);
      local_c = local_c + uVar1;
      local_a = local_a + iVar4 + (uint)bVar6;
      local_8 = *(uint *)(c_common::vlpbrVCR + local_12 * 8 + 0xc);
    }
    local_12 = local_12 + 1;
  }
  if (local_8 == 0xffff) {
    local_8 = *(uint *)((int)c_common::vrgtok + param_1 * 0x1d + 0x15);
    if (499 < local_8 >> 7) {
      local_8 = local_8 & 0x7f | 0xf980;
      lVar7 = CONCAT22(uVar11,uVar2);
    }
  }
  else {
    uVar2 = c_common::vrgtok._2_2_;
    iVar4 = BATTLE::LpshdefFromTok((int)c_common::vrgtok + param_1 * 0x1d,c_common::vrgtok._2_2_);
    uVar2 = *(undefined2 *)(iVar4 + 0x38);
    iVar4 = *(int *)((int)c_common::vrgtok + param_1 * 0x1d + 0x13) - local_14;
    lVar7 = PUBLIC::__aFulmul(uVar2,0,iVar4,iVar4 >> 0xf);
    uVar5 = 0;
    uVar11 = 100;
    uVar8 = PUBLIC::__aFulmul(iVar4,iVar4 >> 0xf,local_8 & 0x7f,0);
    local_6 = PUBLIC::__aFldiv(uVar8,uVar11,uVar5);
    if (local_6 < 1) {
      local_6 = 1;
    }
    uVar13 = 0;
    uVar12 = 0x32;
    iVar4 = local_6 >> 0xf;
    uVar5 = 0;
    uVar11 = 10;
    uVar8 = PUBLIC::__aFulmul(uVar2,0,local_8 >> 7,0);
    uVar8 = PUBLIC::__aFldiv(uVar8,uVar11,uVar5);
    uVar8 = PUBLIC::__aFulmul(uVar8,local_6,iVar4);
    lVar9 = PUBLIC::__aFldiv(uVar8,uVar12,uVar13);
    lVar7 = lVar7 - lVar9;
  }
  local_6 = *(int *)((int)c_common::vrgtok + param_1 * 0x1d + 0x13) - local_14;
  if (local_6 < 1) {
    local_6 = 0;
    lVar7 = 0;
    uVar10 = PUBLIC::__aFulmul(*(undefined2 *)((int)c_common::vrgtok + param_1 * 0x1d + 0x11),0,
                               *(undefined2 *)((int)c_common::vrgtok + param_1 * 0x1d + 0x13),0);
  }
  local_a = (int)((ulong)uVar10 >> 0x10);
  local_c = (uint)uVar10;
  local_e = (undefined2)((ulong)lVar7 >> 0x10);
  local_10 = (undefined2)lVar7;
  if (param_3 != (uint *)0x0) {
    *param_3 = local_8;
  }
  if (param_5 != (int *)0x0) {
    *param_5 = local_6;
  }
  if (param_2 != (undefined2 *)0x0) {
    *param_2 = local_10;
    param_2[1] = local_e;
  }
  if (param_4 != (undefined2 *)0x0) {
    *param_4 = local_c;
    param_4[1] = local_a;
  }
  return;
}



